commit f6667702bf075a05fbe336dbf3576ad1a82ec645
Author: Jia Tan <jiat0218@gmail.com>
Date:   Sun Sep 24 22:09:47 2023 +0800

    liblzma: Change quoting style from `...' to '...'.
    
    This was done for both internal and API headers.

diff --git a/src/liblzma/api/lzma/base.h b/src/liblzma/api/lzma/base.h
index 75cdd72a..adac88a4 100644
--- a/src/liblzma/api/lzma/base.h
+++ b/src/liblzma/api/lzma/base.h
@@ -1,748 +1,748 @@
 /**
  * \file        lzma/base.h
  * \brief       Data types and functions used in many places in liblzma API
  * \note        Never include this file directly. Use <lzma.h> instead.
  */
 
 /*
  * Author: Lasse Collin
  *
  * This file has been put into the public domain.
  * You can do whatever you want with this file.
  */
 
 #ifndef LZMA_H_INTERNAL
 #	error Never include this file directly. Use <lzma.h> instead.
 #endif
 
 
 /**
  * \brief       Boolean
  *
  * This is here because C89 doesn't have stdbool.h. To set a value for
  * variables having type lzma_bool, you can use
- *   - C99's `true' and `false' from stdbool.h;
- *   - C++'s internal `true' and `false'; or
+ *   - C99's 'true' and 'false' from stdbool.h;
+ *   - C++'s internal 'true' and 'false'; or
  *   - integers one (true) and zero (false).
  */
 typedef unsigned char lzma_bool;
 
 
 /**
  * \brief       Type of reserved enumeration variable in structures
  *
  * To avoid breaking library ABI when new features are added, several
  * structures contain extra variables that may be used in future. Since
  * sizeof(enum) can be different than sizeof(int), and sizeof(enum) may
  * even vary depending on the range of enumeration constants, we specify
  * a separate type to be used for reserved enumeration variables. All
  * enumeration constants in liblzma API will be non-negative and less
  * than 128, which should guarantee that the ABI won't break even when
  * new constants are added to existing enumerations.
  */
 typedef enum {
 	LZMA_RESERVED_ENUM      = 0
 } lzma_reserved_enum;
 
 
 /**
  * \brief       Return values used by several functions in liblzma
  *
  * Check the descriptions of specific functions to find out which return
  * values they can return. With some functions the return values may have
  * more specific meanings than described here; those differences are
  * described per-function basis.
  */
 typedef enum {
 	LZMA_OK                 = 0,
 		/**<
 		 * \brief       Operation completed successfully
 		 */
 
 	LZMA_STREAM_END         = 1,
 		/**<
 		 * \brief       End of stream was reached
 		 *
 		 * In encoder, LZMA_SYNC_FLUSH, LZMA_FULL_FLUSH, or
 		 * LZMA_FINISH was finished. In decoder, this indicates
 		 * that all the data was successfully decoded.
 		 *
 		 * In all cases, when LZMA_STREAM_END is returned, the last
 		 * output bytes should be picked from strm->next_out.
 		 */
 
 	LZMA_NO_CHECK           = 2,
 		/**<
 		 * \brief       Input stream has no integrity check
 		 *
 		 * This return value can be returned only if the
 		 * LZMA_TELL_NO_CHECK flag was used when initializing
 		 * the decoder. LZMA_NO_CHECK is just a warning, and
 		 * the decoding can be continued normally.
 		 *
 		 * It is possible to call lzma_get_check() immediately after
 		 * lzma_code has returned LZMA_NO_CHECK. The result will
 		 * naturally be LZMA_CHECK_NONE, but the possibility to call
 		 * lzma_get_check() may be convenient in some applications.
 		 */
 
 	LZMA_UNSUPPORTED_CHECK  = 3,
 		/**<
 		 * \brief       Cannot calculate the integrity check
 		 *
 		 * The usage of this return value is different in encoders
 		 * and decoders.
 		 *
 		 * Encoders can return this value only from the initialization
 		 * function. If initialization fails with this value, the
 		 * encoding cannot be done, because there's no way to produce
 		 * output with the correct integrity check.
 		 *
 		 * Decoders can return this value only from lzma_code() and
 		 * only if the LZMA_TELL_UNSUPPORTED_CHECK flag was used when
 		 * initializing the decoder. The decoding can still be
 		 * continued normally even if the check type is unsupported,
 		 * but naturally the check will not be validated, and possible
 		 * errors may go undetected.
 		 *
 		 * With decoder, it is possible to call lzma_get_check()
 		 * immediately after lzma_code() has returned
 		 * LZMA_UNSUPPORTED_CHECK. This way it is possible to find
 		 * out what the unsupported Check ID was.
 		 */
 
 	LZMA_GET_CHECK          = 4,
 		/**<
 		 * \brief       Integrity check type is now available
 		 *
 		 * This value can be returned only by the lzma_code() function
 		 * and only if the decoder was initialized with the
 		 * LZMA_TELL_ANY_CHECK flag. LZMA_GET_CHECK tells the
 		 * application that it may now call lzma_get_check() to find
 		 * out the Check ID. This can be used, for example, to
 		 * implement a decoder that accepts only files that have
 		 * strong enough integrity check.
 		 */
 
 	LZMA_MEM_ERROR          = 5,
 		/**<
 		 * \brief       Cannot allocate memory
 		 *
 		 * Memory allocation failed, or the size of the allocation
 		 * would be greater than SIZE_MAX.
 		 *
 		 * Due to internal implementation reasons, the coding cannot
 		 * be continued even if more memory were made available after
 		 * LZMA_MEM_ERROR.
 		 */
 
 	LZMA_MEMLIMIT_ERROR     = 6,
 		/**<
 		 * \brief       Memory usage limit was reached
 		 *
 		 * Decoder would need more memory than allowed by the
 		 * specified memory usage limit. To continue decoding,
 		 * the memory usage limit has to be increased with
 		 * lzma_memlimit_set().
 		 *
 		 * liblzma 5.2.6 and earlier had a bug in single-threaded .xz
 		 * decoder (lzma_stream_decoder()) which made it impossible
 		 * to continue decoding after LZMA_MEMLIMIT_ERROR even if
 		 * the limit was increased using lzma_memlimit_set().
 		 * Other decoders worked correctly.
 		 */
 
 	LZMA_FORMAT_ERROR       = 7,
 		/**<
 		 * \brief       File format not recognized
 		 *
 		 * The decoder did not recognize the input as supported file
 		 * format. This error can occur, for example, when trying to
 		 * decode .lzma format file with lzma_stream_decoder,
 		 * because lzma_stream_decoder accepts only the .xz format.
 		 */
 
 	LZMA_OPTIONS_ERROR      = 8,
 		/**<
 		 * \brief       Invalid or unsupported options
 		 *
 		 * Invalid or unsupported options, for example
 		 *  - unsupported filter(s) or filter options; or
 		 *  - reserved bits set in headers (decoder only).
 		 *
 		 * Rebuilding liblzma with more features enabled, or
 		 * upgrading to a newer version of liblzma may help.
 		 */
 
 	LZMA_DATA_ERROR         = 9,
 		/**<
 		 * \brief       Data is corrupt
 		 *
 		 * The usage of this return value is different in encoders
 		 * and decoders. In both encoder and decoder, the coding
 		 * cannot continue after this error.
 		 *
 		 * Encoders return this if size limits of the target file
 		 * format would be exceeded. These limits are huge, thus
 		 * getting this error from an encoder is mostly theoretical.
 		 * For example, the maximum compressed and uncompressed
 		 * size of a .xz Stream is roughly 8 EiB (2^63 bytes).
 		 *
 		 * Decoders return this error if the input data is corrupt.
 		 * This can mean, for example, invalid CRC32 in headers
 		 * or invalid check of uncompressed data.
 		 */
 
 	LZMA_BUF_ERROR          = 10,
 		/**<
 		 * \brief       No progress is possible
 		 *
 		 * This error code is returned when the coder cannot consume
 		 * any new input and produce any new output. The most common
 		 * reason for this error is that the input stream being
 		 * decoded is truncated or corrupt.
 		 *
 		 * This error is not fatal. Coding can be continued normally
 		 * by providing more input and/or more output space, if
 		 * possible.
 		 *
 		 * Typically the first call to lzma_code() that can do no
 		 * progress returns LZMA_OK instead of LZMA_BUF_ERROR. Only
 		 * the second consecutive call doing no progress will return
 		 * LZMA_BUF_ERROR. This is intentional.
 		 *
 		 * With zlib, Z_BUF_ERROR may be returned even if the
 		 * application is doing nothing wrong, so apps will need
 		 * to handle Z_BUF_ERROR specially. The above hack
 		 * guarantees that liblzma never returns LZMA_BUF_ERROR
 		 * to properly written applications unless the input file
 		 * is truncated or corrupt. This should simplify the
 		 * applications a little.
 		 */
 
 	LZMA_PROG_ERROR         = 11,
 		/**<
 		 * \brief       Programming error
 		 *
 		 * This indicates that the arguments given to the function are
 		 * invalid or the internal state of the decoder is corrupt.
 		 *   - Function arguments are invalid or the structures
 		 *     pointed by the argument pointers are invalid
 		 *     e.g. if strm->next_out has been set to NULL and
 		 *     strm->avail_out > 0 when calling lzma_code().
 		 *   - lzma_* functions have been called in wrong order
 		 *     e.g. lzma_code() was called right after lzma_end().
 		 *   - If errors occur randomly, the reason might be flaky
 		 *     hardware.
 		 *
 		 * If you think that your code is correct, this error code
 		 * can be a sign of a bug in liblzma. See the documentation
 		 * how to report bugs.
 		 */
 
 	LZMA_SEEK_NEEDED        = 12,
 		/**<
 		 * \brief       Request to change the input file position
 		 *
 		 * Some coders can do random access in the input file. The
 		 * initialization functions of these coders take the file size
 		 * as an argument. No other coders can return LZMA_SEEK_NEEDED.
 		 *
 		 * When this value is returned, the application must seek to
 		 * the file position given in lzma_stream.seek_pos. This value
 		 * is guaranteed to never exceed the file size that was
 		 * specified at the coder initialization.
 		 *
 		 * After seeking the application should read new input and
 		 * pass it normally via lzma_stream.next_in and .avail_in.
 		 */
 
 	/*
 	 * These eumerations may be used internally by liblzma
 	 * but they will never be returned to applications.
 	 */
 	LZMA_RET_INTERNAL1      = 101,
 	LZMA_RET_INTERNAL2      = 102,
 	LZMA_RET_INTERNAL3      = 103,
 	LZMA_RET_INTERNAL4      = 104,
 	LZMA_RET_INTERNAL5      = 105,
 	LZMA_RET_INTERNAL6      = 106,
 	LZMA_RET_INTERNAL7      = 107,
 	LZMA_RET_INTERNAL8      = 108
 } lzma_ret;
 
 
 /**
- * \brief       The `action' argument for lzma_code()
+ * \brief       The 'action' argument for lzma_code()
  *
  * After the first use of LZMA_SYNC_FLUSH, LZMA_FULL_FLUSH, LZMA_FULL_BARRIER,
- * or LZMA_FINISH, the same `action' must be used until lzma_code() returns
+ * or LZMA_FINISH, the same 'action' must be used until lzma_code() returns
  * LZMA_STREAM_END. Also, the amount of input (that is, strm->avail_in) must
  * not be modified by the application until lzma_code() returns
- * LZMA_STREAM_END. Changing the `action' or modifying the amount of input
+ * LZMA_STREAM_END. Changing the 'action' or modifying the amount of input
  * will make lzma_code() return LZMA_PROG_ERROR.
  */
 typedef enum {
 	LZMA_RUN = 0,
 		/**<
 		 * \brief       Continue coding
 		 *
 		 * Encoder: Encode as much input as possible. Some internal
 		 * buffering will probably be done (depends on the filter
 		 * chain in use), which causes latency: the input used won't
 		 * usually be decodeable from the output of the same
 		 * lzma_code() call.
 		 *
 		 * Decoder: Decode as much input as possible and produce as
 		 * much output as possible.
 		 */
 
 	LZMA_SYNC_FLUSH = 1,
 		/**<
 		 * \brief       Make all the input available at output
 		 *
 		 * Normally the encoder introduces some latency.
 		 * LZMA_SYNC_FLUSH forces all the buffered data to be
 		 * available at output without resetting the internal
 		 * state of the encoder. This way it is possible to use
 		 * compressed stream for example for communication over
 		 * network.
 		 *
 		 * Only some filters support LZMA_SYNC_FLUSH. Trying to use
 		 * LZMA_SYNC_FLUSH with filters that don't support it will
 		 * make lzma_code() return LZMA_OPTIONS_ERROR. For example,
 		 * LZMA1 doesn't support LZMA_SYNC_FLUSH but LZMA2 does.
 		 *
 		 * Using LZMA_SYNC_FLUSH very often can dramatically reduce
 		 * the compression ratio. With some filters (for example,
 		 * LZMA2), fine-tuning the compression options may help
 		 * mitigate this problem significantly (for example,
 		 * match finder with LZMA2).
 		 *
 		 * Decoders don't support LZMA_SYNC_FLUSH.
 		 */
 
 	LZMA_FULL_FLUSH = 2,
 		/**<
 		 * \brief       Finish encoding of the current Block
 		 *
 		 * All the input data going to the current Block must have
 		 * been given to the encoder (the last bytes can still be
 		 * pending in *next_in). Call lzma_code() with LZMA_FULL_FLUSH
 		 * until it returns LZMA_STREAM_END. Then continue normally
 		 * with LZMA_RUN or finish the Stream with LZMA_FINISH.
 		 *
 		 * This action is currently supported only by Stream encoder
 		 * and easy encoder (which uses Stream encoder). If there is
 		 * no unfinished Block, no empty Block is created.
 		 */
 
 	LZMA_FULL_BARRIER = 4,
 		/**<
 		 * \brief       Finish encoding of the current Block
 		 *
 		 * This is like LZMA_FULL_FLUSH except that this doesn't
 		 * necessarily wait until all the input has been made
 		 * available via the output buffer. That is, lzma_code()
 		 * might return LZMA_STREAM_END as soon as all the input
 		 * has been consumed (avail_in == 0).
 		 *
 		 * LZMA_FULL_BARRIER is useful with a threaded encoder if
 		 * one wants to split the .xz Stream into Blocks at specific
 		 * offsets but doesn't care if the output isn't flushed
 		 * immediately. Using LZMA_FULL_BARRIER allows keeping
 		 * the threads busy while LZMA_FULL_FLUSH would make
 		 * lzma_code() wait until all the threads have finished
 		 * until more data could be passed to the encoder.
 		 *
 		 * With a lzma_stream initialized with the single-threaded
 		 * lzma_stream_encoder() or lzma_easy_encoder(),
 		 * LZMA_FULL_BARRIER is an alias for LZMA_FULL_FLUSH.
 		 */
 
 	LZMA_FINISH = 3
 		/**<
 		 * \brief       Finish the coding operation
 		 *
 		 * All the input data must have been given to the encoder
 		 * (the last bytes can still be pending in next_in).
 		 * Call lzma_code() with LZMA_FINISH until it returns
 		 * LZMA_STREAM_END. Once LZMA_FINISH has been used,
 		 * the amount of input must no longer be changed by
 		 * the application.
 		 *
 		 * When decoding, using LZMA_FINISH is optional unless the
 		 * LZMA_CONCATENATED flag was used when the decoder was
 		 * initialized. When LZMA_CONCATENATED was not used, the only
 		 * effect of LZMA_FINISH is that the amount of input must not
 		 * be changed just like in the encoder.
 		 */
 } lzma_action;
 
 
 /**
  * \brief       Custom functions for memory handling
  *
  * A pointer to lzma_allocator may be passed via lzma_stream structure
  * to liblzma, and some advanced functions take a pointer to lzma_allocator
  * as a separate function argument. The library will use the functions
  * specified in lzma_allocator for memory handling instead of the default
  * malloc() and free(). C++ users should note that the custom memory
  * handling functions must not throw exceptions.
  *
  * Single-threaded mode only: liblzma doesn't make an internal copy of
  * lzma_allocator. Thus, it is OK to change these function pointers in
  * the middle of the coding process, but obviously it must be done
- * carefully to make sure that the replacement `free' can deallocate
- * memory allocated by the earlier `alloc' function(s).
+ * carefully to make sure that the replacement 'free' can deallocate
+ * memory allocated by the earlier 'alloc' function(s).
  *
  * Multithreaded mode: liblzma might internally store pointers to the
  * lzma_allocator given via the lzma_stream structure. The application
  * must not change the allocator pointer in lzma_stream or the contents
  * of the pointed lzma_allocator structure until lzma_end() has been used
  * to free the memory associated with that lzma_stream. The allocation
  * functions might be called simultaneously from multiple threads, and
  * thus they must be thread safe.
  */
 typedef struct {
 	/**
 	 * \brief       Pointer to a custom memory allocation function
 	 *
 	 * If you don't want a custom allocator, but still want
 	 * custom free(), set this to NULL and liblzma will use
 	 * the standard malloc().
 	 *
 	 * \param       opaque  lzma_allocator.opaque (see below)
 	 * \param       nmemb   Number of elements like in calloc(). liblzma
 	 *                      will always set nmemb to 1, so it is safe to
 	 *                      ignore nmemb in a custom allocator if you like.
 	 *                      The nmemb argument exists only for
 	 *                      compatibility with zlib and libbzip2.
 	 * \param       size    Size of an element in bytes.
 	 *                      liblzma never sets this to zero.
 	 *
 	 * \return      Pointer to the beginning of a memory block of
-	 *              `size' bytes, or NULL if allocation fails
+	 *              'size' bytes, or NULL if allocation fails
 	 *              for some reason. When allocation fails, functions
 	 *              of liblzma return LZMA_MEM_ERROR.
 	 *
 	 * The allocator should not waste time zeroing the allocated buffers.
 	 * This is not only about speed, but also memory usage, since the
 	 * operating system kernel doesn't necessarily allocate the requested
 	 * memory in physical memory until it is actually used. With small
 	 * input files, liblzma may actually need only a fraction of the
 	 * memory that it requested for allocation.
 	 *
 	 * \note        LZMA_MEM_ERROR is also used when the size of the
 	 *              allocation would be greater than SIZE_MAX. Thus,
 	 *              don't assume that the custom allocator must have
 	 *              returned NULL if some function from liblzma
 	 *              returns LZMA_MEM_ERROR.
 	 */
 	void *(LZMA_API_CALL *alloc)(void *opaque, size_t nmemb, size_t size);
 
 	/**
 	 * \brief       Pointer to a custom memory freeing function
 	 *
 	 * If you don't want a custom freeing function, but still
 	 * want a custom allocator, set this to NULL and liblzma
 	 * will use the standard free().
 	 *
 	 * \param       opaque  lzma_allocator.opaque (see below)
 	 * \param       ptr     Pointer returned by lzma_allocator.alloc(),
 	 *                      or when it is set to NULL, a pointer returned
 	 *                      by the standard malloc().
 	 */
 	void (LZMA_API_CALL *free)(void *opaque, void *ptr);
 
 	/**
 	 * \brief       Pointer passed to .alloc() and .free()
 	 *
 	 * opaque is passed as the first argument to lzma_allocator.alloc()
 	 * and lzma_allocator.free(). This intended to ease implementing
 	 * custom memory allocation functions for use with liblzma.
 	 *
 	 * If you don't need this, you should set this to NULL.
 	 */
 	void *opaque;
 
 } lzma_allocator;
 
 
 /**
  * \brief       Internal data structure
  *
  * The contents of this structure is not visible outside the library.
  */
 typedef struct lzma_internal_s lzma_internal;
 
 
 /**
  * \brief       Passing data to and from liblzma
  *
  * The lzma_stream structure is used for
  *  - passing pointers to input and output buffers to liblzma;
  *  - defining custom memory handler functions; and
  *  - holding a pointer to coder-specific internal data structures.
  *
  * Typical usage:
  *
  *  - After allocating lzma_stream (on stack or with malloc()), it must be
  *    initialized to LZMA_STREAM_INIT (see LZMA_STREAM_INIT for details).
  *
  *  - Initialize a coder to the lzma_stream, for example by using
  *    lzma_easy_encoder() or lzma_auto_decoder(). Some notes:
  *      - In contrast to zlib, strm->next_in and strm->next_out are
  *        ignored by all initialization functions, thus it is safe
  *        to not initialize them yet.
  *      - The initialization functions always set strm->total_in and
  *        strm->total_out to zero.
  *      - If the initialization function fails, no memory is left allocated
  *        that would require freeing with lzma_end() even if some memory was
  *        associated with the lzma_stream structure when the initialization
  *        function was called.
  *
  *  - Use lzma_code() to do the actual work.
  *
  *  - Once the coding has been finished, the existing lzma_stream can be
  *    reused. It is OK to reuse lzma_stream with different initialization
  *    function without calling lzma_end() first. Old allocations are
  *    automatically freed.
  *
  *  - Finally, use lzma_end() to free the allocated memory. lzma_end() never
  *    frees the lzma_stream structure itself.
  *
  * Application may modify the values of total_in and total_out as it wants.
  * They are updated by liblzma to match the amount of data read and
  * written but aren't used for anything else except as a possible return
  * values from lzma_get_progress().
  */
 typedef struct {
 	const uint8_t *next_in; /**< Pointer to the next input byte. */
 	size_t avail_in;    /**< Number of available input bytes in next_in. */
 	uint64_t total_in;  /**< Total number of bytes read by liblzma. */
 
 	uint8_t *next_out;  /**< Pointer to the next output position. */
 	size_t avail_out;   /**< Amount of free space in next_out. */
 	uint64_t total_out; /**< Total number of bytes written by liblzma. */
 
 	/**
 	 * \brief       Custom memory allocation functions
 	 *
 	 * In most cases this is NULL which makes liblzma use
 	 * the standard malloc() and free().
 	 *
 	 * \note        In 5.0.x this is not a const pointer.
 	 */
 	const lzma_allocator *allocator;
 
 	/** Internal state is not visible to applications. */
 	lzma_internal *internal;
 
 	/*
 	 * Reserved space to allow possible future extensions without
 	 * breaking the ABI. Excluding the initialization of this structure,
 	 * you should not touch these, because the names of these variables
 	 * may change.
 	 */
 
 	/** \private     Reserved member. */
 	void *reserved_ptr1;
 
 	/** \private     Reserved member. */
 	void *reserved_ptr2;
 
 	/** \private     Reserved member. */
 	void *reserved_ptr3;
 
 	/** \private     Reserved member. */
 	void *reserved_ptr4;
 
 	/**
 	 * \brief       New seek input position for LZMA_SEEK_NEEDED
 	 *
 	 * When lzma_code() returns LZMA_SEEK_NEEDED, the new input position
 	 * needed by liblzma will be available seek_pos. The value is
 	 * guaranteed to not exceed the file size that was specified when
 	 * this lzma_stream was initialized.
 	 *
 	 * In all other situations the value of this variable is undefined.
 	 */
 	uint64_t seek_pos;
 
 	/** \private     Reserved member. */
 	uint64_t reserved_int2;
 
 	/** \private     Reserved member. */
 	size_t reserved_int3;
 
 	/** \private     Reserved member. */
 	size_t reserved_int4;
 
 	/** \private     Reserved member. */
 	lzma_reserved_enum reserved_enum1;
 
 	/** \private     Reserved member. */
 	lzma_reserved_enum reserved_enum2;
 
 } lzma_stream;
 
 
 /**
  * \brief       Initialization for lzma_stream
  *
  * When you declare an instance of lzma_stream, you can immediately
  * initialize it so that initialization functions know that no memory
  * has been allocated yet:
  *
  *     lzma_stream strm = LZMA_STREAM_INIT;
  *
  * If you need to initialize a dynamically allocated lzma_stream, you can use
  * memset(strm_pointer, 0, sizeof(lzma_stream)). Strictly speaking, this
  * violates the C standard since NULL may have different internal
  * representation than zero, but it should be portable enough in practice.
  * Anyway, for maximum portability, you can use something like this:
  *
  *     lzma_stream tmp = LZMA_STREAM_INIT;
  *     *strm = tmp;
  */
 #define LZMA_STREAM_INIT \
 	{ NULL, 0, 0, NULL, 0, 0, NULL, NULL, \
 	NULL, NULL, NULL, NULL, 0, 0, 0, 0, \
 	LZMA_RESERVED_ENUM, LZMA_RESERVED_ENUM }
 
 
 /**
  * \brief       Encode or decode data
  *
  * Once the lzma_stream has been successfully initialized (e.g. with
  * lzma_stream_encoder()), the actual encoding or decoding is done
  * using this function. The application has to update strm->next_in,
  * strm->avail_in, strm->next_out, and strm->avail_out to pass input
  * to and get output from liblzma.
  *
  * See the description of the coder-specific initialization function to find
- * out what `action' values are supported by the coder.
+ * out what 'action' values are supported by the coder.
  *
  * \param       strm    Pointer to lzma_stream that is at least initialized
  *                      with LZMA_STREAM_INIT.
  * \param       action  Action for this function to take. Must be a valid
  *                      lzma_action enum value.
  *
  * \return      Any valid lzma_ret. See the lzma_ret enum description for more
  *              information.
  */
 extern LZMA_API(lzma_ret) lzma_code(lzma_stream *strm, lzma_action action)
 		lzma_nothrow lzma_attr_warn_unused_result;
 
 
 /**
  * \brief       Free memory allocated for the coder data structures
  *
  * After lzma_end(strm), strm->internal is guaranteed to be NULL. No other
  * members of the lzma_stream structure are touched.
  *
  * \note        zlib indicates an error if application end()s unfinished
  *              stream structure. liblzma doesn't do this, and assumes that
  *              application knows what it is doing.
  *
  * \param       strm    Pointer to lzma_stream that is at least initialized
  *                      with LZMA_STREAM_INIT.
  */
 extern LZMA_API(void) lzma_end(lzma_stream *strm) lzma_nothrow;
 
 
 /**
  * \brief       Get progress information
  *
  * In single-threaded mode, applications can get progress information from
  * strm->total_in and strm->total_out. In multi-threaded mode this is less
  * useful because a significant amount of both input and output data gets
  * buffered internally by liblzma. This makes total_in and total_out give
  * misleading information and also makes the progress indicator updates
  * non-smooth.
  *
  * This function gives realistic progress information also in multi-threaded
  * mode by taking into account the progress made by each thread. In
  * single-threaded mode *progress_in and *progress_out are set to
  * strm->total_in and strm->total_out, respectively.
  *
  * \param       strm          Pointer to lzma_stream that is at least
  *                            initialized with LZMA_STREAM_INIT.
  * \param[out]  progress_in   Pointer to the number of input bytes processed.
  * \param[out]  progress_out  Pointer to the number of output bytes processed.
  */
 extern LZMA_API(void) lzma_get_progress(lzma_stream *strm,
 		uint64_t *progress_in, uint64_t *progress_out) lzma_nothrow;
 
 
 /**
  * \brief       Get the memory usage of decoder filter chain
  *
  * This function is currently supported only when *strm has been initialized
  * with a function that takes a memlimit argument. With other functions, you
  * should use e.g. lzma_raw_encoder_memusage() or lzma_raw_decoder_memusage()
  * to estimate the memory requirements.
  *
  * This function is useful e.g. after LZMA_MEMLIMIT_ERROR to find out how big
  * the memory usage limit should have been to decode the input. Note that
  * this may give misleading information if decoding .xz Streams that have
  * multiple Blocks, because each Block can have different memory requirements.
  *
  * \param       strm    Pointer to lzma_stream that is at least initialized
  *                      with LZMA_STREAM_INIT.
  *
  * \return      How much memory is currently allocated for the filter
  *              decoders. If no filter chain is currently allocated,
  *              some non-zero value is still returned, which is less than
  *              or equal to what any filter chain would indicate as its
  *              memory requirement.
  *
  *              If this function isn't supported by *strm or some other error
  *              occurs, zero is returned.
  */
 extern LZMA_API(uint64_t) lzma_memusage(const lzma_stream *strm)
 		lzma_nothrow lzma_attr_pure;
 
 
 /**
  * \brief       Get the current memory usage limit
  *
  * This function is supported only when *strm has been initialized with
  * a function that takes a memlimit argument.
  *
  * \param       strm    Pointer to lzma_stream that is at least initialized
  *                      with LZMA_STREAM_INIT.
  *
  * \return      On success, the current memory usage limit is returned
  *              (always non-zero). On error, zero is returned.
  */
 extern LZMA_API(uint64_t) lzma_memlimit_get(const lzma_stream *strm)
 		lzma_nothrow lzma_attr_pure;
 
 
 /**
  * \brief       Set the memory usage limit
  *
  * This function is supported only when *strm has been initialized with
  * a function that takes a memlimit argument.
  *
  * liblzma 5.2.3 and earlier has a bug where memlimit value of 0 causes
  * this function to do nothing (leaving the limit unchanged) and still
  * return LZMA_OK. Later versions treat 0 as if 1 had been specified (so
  * lzma_memlimit_get() will return 1 even if you specify 0 here).
  *
  * liblzma 5.2.6 and earlier had a bug in single-threaded .xz decoder
  * (lzma_stream_decoder()) which made it impossible to continue decoding
  * after LZMA_MEMLIMIT_ERROR even if the limit was increased using
  * lzma_memlimit_set(). Other decoders worked correctly.
  *
  * \return      Possible lzma_ret values:
  *              - LZMA_OK: New memory usage limit successfully set.
  *              - LZMA_MEMLIMIT_ERROR: The new limit is too small.
  *                The limit was not changed.
  *              - LZMA_PROG_ERROR: Invalid arguments, e.g. *strm doesn't
  *                support memory usage limit.
  */
 extern LZMA_API(lzma_ret) lzma_memlimit_set(
 		lzma_stream *strm, uint64_t memlimit) lzma_nothrow;
diff --git a/src/liblzma/api/lzma/container.h b/src/liblzma/api/lzma/container.h
index 4cbb1b7b..ed8aa921 100644
--- a/src/liblzma/api/lzma/container.h
+++ b/src/liblzma/api/lzma/container.h
@@ -1,996 +1,996 @@
 /**
  * \file        lzma/container.h
  * \brief       File formats
  * \note        Never include this file directly. Use <lzma.h> instead.
  */
 
 /*
  * Author: Lasse Collin
  *
  * This file has been put into the public domain.
  * You can do whatever you want with this file.
  */
 
 #ifndef LZMA_H_INTERNAL
 #	error Never include this file directly. Use <lzma.h> instead.
 #endif
 
 
 /************
  * Encoding *
  ************/
 
 /**
  * \brief       Default compression preset
  *
  * It's not straightforward to recommend a default preset, because in some
  * cases keeping the resource usage relatively low is more important that
  * getting the maximum compression ratio.
  */
 #define LZMA_PRESET_DEFAULT     UINT32_C(6)
 
 
 /**
  * \brief       Mask for preset level
  *
  * This is useful only if you need to extract the level from the preset
  * variable. That should be rare.
  */
 #define LZMA_PRESET_LEVEL_MASK  UINT32_C(0x1F)
 
 
 /*
  * Preset flags
  *
  * Currently only one flag is defined.
  */
 
 /**
  * \brief       Extreme compression preset
  *
  * This flag modifies the preset to make the encoding significantly slower
  * while improving the compression ratio only marginally. This is useful
  * when you don't mind spending time to get as small result as possible.
  *
  * This flag doesn't affect the memory usage requirements of the decoder (at
  * least not significantly). The memory usage of the encoder may be increased
  * a little but only at the lowest preset levels (0-3).
  */
 #define LZMA_PRESET_EXTREME       (UINT32_C(1) << 31)
 
 
 /**
  * \brief       Multithreading options
  */
 typedef struct {
 	/**
 	 * \brief       Flags
 	 *
 	 * Set this to zero if no flags are wanted.
 	 *
 	 * Encoder: No flags are currently supported.
 	 *
 	 * Decoder: Bitwise-or of zero or more of the decoder flags:
 	 * - LZMA_TELL_NO_CHECK
 	 * - LZMA_TELL_UNSUPPORTED_CHECK
 	 * - LZMA_TELL_ANY_CHECK
 	 * - LZMA_IGNORE_CHECK
 	 * - LZMA_CONCATENATED
 	 * - LZMA_FAIL_FAST
 	 */
 	uint32_t flags;
 
 	/**
 	 * \brief       Number of worker threads to use
 	 */
 	uint32_t threads;
 
 	/**
 	 * \brief       Encoder only: Maximum uncompressed size of a Block
 	 *
 	 * The encoder will start a new .xz Block every block_size bytes.
 	 * Using LZMA_FULL_FLUSH or LZMA_FULL_BARRIER with lzma_code()
 	 * the caller may tell liblzma to start a new Block earlier.
 	 *
 	 * With LZMA2, a recommended block size is 2-4 times the LZMA2
 	 * dictionary size. With very small dictionaries, it is recommended
 	 * to use at least 1 MiB block size for good compression ratio, even
 	 * if this is more than four times the dictionary size. Note that
 	 * these are only recommendations for typical use cases; feel free
 	 * to use other values. Just keep in mind that using a block size
 	 * less than the LZMA2 dictionary size is waste of RAM.
 	 *
 	 * Set this to 0 to let liblzma choose the block size depending
 	 * on the compression options. For LZMA2 it will be 3*dict_size
 	 * or 1 MiB, whichever is more.
 	 *
 	 * For each thread, about 3 * block_size bytes of memory will be
 	 * allocated. This may change in later liblzma versions. If so,
 	 * the memory usage will probably be reduced, not increased.
 	 */
 	uint64_t block_size;
 
 	/**
 	 * \brief       Timeout to allow lzma_code() to return early
 	 *
 	 * Multithreading can make liblzma consume input and produce
 	 * output in a very bursty way: it may first read a lot of input
 	 * to fill internal buffers, then no input or output occurs for
 	 * a while.
 	 *
 	 * In single-threaded mode, lzma_code() won't return until it has
 	 * either consumed all the input or filled the output buffer. If
 	 * this is done in multithreaded mode, it may cause a call
 	 * lzma_code() to take even tens of seconds, which isn't acceptable
 	 * in all applications.
 	 *
 	 * To avoid very long blocking times in lzma_code(), a timeout
 	 * (in milliseconds) may be set here. If lzma_code() would block
 	 * longer than this number of milliseconds, it will return with
 	 * LZMA_OK. Reasonable values are 100 ms or more. The xz command
 	 * line tool uses 300 ms.
 	 *
 	 * If long blocking times are acceptable, set timeout to a special
 	 * value of 0. This will disable the timeout mechanism and will make
 	 * lzma_code() block until all the input is consumed or the output
 	 * buffer has been filled.
 	 *
 	 * \note        Even with a timeout, lzma_code() might sometimes take
 	 *              a long time to return. No timing guarantees are made.
 	 */
 	uint32_t timeout;
 
 	/**
 	 * \brief       Encoder only: Compression preset
 	 *
 	 * The preset is set just like with lzma_easy_encoder().
 	 * The preset is ignored if filters below is non-NULL.
 	 */
 	uint32_t preset;
 
 	/**
 	 * \brief       Encoder only: Filter chain (alternative to a preset)
 	 *
 	 * If this is NULL, the preset above is used. Otherwise the preset
 	 * is ignored and the filter chain specified here is used.
 	 */
 	const lzma_filter *filters;
 
 	/**
 	 * \brief       Encoder only: Integrity check type
 	 *
 	 * See check.h for available checks. The xz command line tool
 	 * defaults to LZMA_CHECK_CRC64, which is a good choice if you
 	 * are unsure.
 	 */
 	lzma_check check;
 
 	/*
 	 * Reserved space to allow possible future extensions without
 	 * breaking the ABI. You should not touch these, because the names
 	 * of these variables may change. These are and will never be used
 	 * with the currently supported options, so it is safe to leave these
 	 * uninitialized.
 	 */
 	/** \private     Reserved member. */
 	lzma_reserved_enum reserved_enum1;
 
 	/** \private     Reserved member. */
 	lzma_reserved_enum reserved_enum2;
 
 	/** \private     Reserved member. */
 	lzma_reserved_enum reserved_enum3;
 
 	/** \private     Reserved member. */
 	uint32_t reserved_int1;
 
 	/** \private     Reserved member. */
 	uint32_t reserved_int2;
 
 	/** \private     Reserved member. */
 	uint32_t reserved_int3;
 
 	/** \private     Reserved member. */
 	uint32_t reserved_int4;
 
 	/**
 	 * \brief       Memory usage limit to reduce the number of threads
 	 *
 	 * Encoder: Ignored.
 	 *
 	 * Decoder:
 	 *
 	 * If the number of threads has been set so high that more than
 	 * memlimit_threading bytes of memory would be needed, the number
 	 * of threads will be reduced so that the memory usage will not exceed
 	 * memlimit_threading bytes. However, if memlimit_threading cannot
 	 * be met even in single-threaded mode, then decoding will continue
 	 * in single-threaded mode and memlimit_threading may be exceeded
 	 * even by a large amount. That is, memlimit_threading will never make
 	 * lzma_code() return LZMA_MEMLIMIT_ERROR. To truly cap the memory
 	 * usage, see memlimit_stop below.
 	 *
 	 * Setting memlimit_threading to UINT64_MAX or a similar huge value
 	 * means that liblzma is allowed to keep the whole compressed file
 	 * and the whole uncompressed file in memory in addition to the memory
 	 * needed by the decompressor data structures used by each thread!
 	 * In other words, a reasonable value limit must be set here or it
 	 * will cause problems sooner or later. If you have no idea what
 	 * a reasonable value could be, try lzma_physmem() / 4 as a starting
 	 * point. Setting this limit will never prevent decompression of
 	 * a file; this will only reduce the number of threads.
 	 *
 	 * If memlimit_threading is greater than memlimit_stop, then the value
 	 * of memlimit_stop will be used for both.
 	 */
 	uint64_t memlimit_threading;
 
 	/**
 	 * \brief       Memory usage limit that should never be exceeded
 	 *
 	 * Encoder: Ignored.
 	 *
 	 * Decoder: If decompressing will need more than this amount of
 	 * memory even in the single-threaded mode, then lzma_code() will
 	 * return LZMA_MEMLIMIT_ERROR.
 	 */
 	uint64_t memlimit_stop;
 
 	/** \private     Reserved member. */
 	uint64_t reserved_int7;
 
 	/** \private     Reserved member. */
 	uint64_t reserved_int8;
 
 	/** \private     Reserved member. */
 	void *reserved_ptr1;
 
 	/** \private     Reserved member. */
 	void *reserved_ptr2;
 
 	/** \private     Reserved member. */
 	void *reserved_ptr3;
 
 	/** \private     Reserved member. */
 	void *reserved_ptr4;
 
 } lzma_mt;
 
 
 /**
  * \brief       Calculate approximate memory usage of easy encoder
  *
  * This function is a wrapper for lzma_raw_encoder_memusage().
  *
  * \param       preset  Compression preset (level and possible flags)
  *
  * \return      Number of bytes of memory required for the given
  *              preset when encoding or UINT64_MAX on error.
  */
 extern LZMA_API(uint64_t) lzma_easy_encoder_memusage(uint32_t preset)
 		lzma_nothrow lzma_attr_pure;
 
 
 /**
  * \brief       Calculate approximate decoder memory usage of a preset
  *
  * This function is a wrapper for lzma_raw_decoder_memusage().
  *
  * \param       preset  Compression preset (level and possible flags)
  *
  * \return      Number of bytes of memory required to decompress a file
  *              that was compressed using the given preset or UINT64_MAX
  *              on error.
  */
 extern LZMA_API(uint64_t) lzma_easy_decoder_memusage(uint32_t preset)
 		lzma_nothrow lzma_attr_pure;
 
 
 /**
  * \brief       Initialize .xz Stream encoder using a preset number
  *
  * This function is intended for those who just want to use the basic features
  * of liblzma (that is, most developers out there).
  *
  * If initialization fails (return value is not LZMA_OK), all the memory
  * allocated for *strm by liblzma is always freed. Thus, there is no need
  * to call lzma_end() after failed initialization.
  *
  * If initialization succeeds, use lzma_code() to do the actual encoding.
- * Valid values for `action' (the second argument of lzma_code()) are
+ * Valid values for 'action' (the second argument of lzma_code()) are
  * LZMA_RUN, LZMA_SYNC_FLUSH, LZMA_FULL_FLUSH, and LZMA_FINISH. In future,
  * there may be compression levels or flags that don't support LZMA_SYNC_FLUSH.
  *
  * \param       strm    Pointer to lzma_stream that is at least initialized
  *                      with LZMA_STREAM_INIT.
  * \param       preset  Compression preset to use. A preset consist of level
  *                      number and zero or more flags. Usually flags aren't
  *                      used, so preset is simply a number [0, 9] which match
  *                      the options -0 ... -9 of the xz command line tool.
  *                      Additional flags can be be set using bitwise-or with
  *                      the preset level number, e.g. 6 | LZMA_PRESET_EXTREME.
  * \param       check   Integrity check type to use. See check.h for available
  *                      checks. The xz command line tool defaults to
  *                      LZMA_CHECK_CRC64, which is a good choice if you are
  *                      unsure. LZMA_CHECK_CRC32 is good too as long as the
  *                      uncompressed file is not many gigabytes.
  *
  * \return      Possible lzma_ret values:
  *              - LZMA_OK: Initialization succeeded. Use lzma_code() to
  *                encode your data.
  *              - LZMA_MEM_ERROR: Memory allocation failed.
  *              - LZMA_OPTIONS_ERROR: The given compression preset is not
  *                supported by this build of liblzma.
  *              - LZMA_UNSUPPORTED_CHECK: The given check type is not
  *                supported by this liblzma build.
  *              - LZMA_PROG_ERROR: One or more of the parameters have values
  *                that will never be valid. For example, strm == NULL.
  */
 extern LZMA_API(lzma_ret) lzma_easy_encoder(
 		lzma_stream *strm, uint32_t preset, lzma_check check)
 		lzma_nothrow lzma_attr_warn_unused_result;
 
 
 /**
  * \brief       Single-call .xz Stream encoding using a preset number
  *
  * The maximum required output buffer size can be calculated with
  * lzma_stream_buffer_bound().
  *
  * \param       preset      Compression preset to use. See the description
  *                          in lzma_easy_encoder().
  * \param       check       Type of the integrity check to calculate from
  *                          uncompressed data.
  * \param       allocator   lzma_allocator for custom allocator functions.
  *                          Set to NULL to use malloc() and free().
  * \param       in          Beginning of the input buffer
  * \param       in_size     Size of the input buffer
  * \param[out]  out         Beginning of the output buffer
  * \param[out]  out_pos     The next byte will be written to out[*out_pos].
  *                          *out_pos is updated only if encoding succeeds.
  * \param       out_size    Size of the out buffer; the first byte into
  *                          which no data is written to is out[out_size].
  *
  * \return      Possible lzma_ret values:
  *              - LZMA_OK: Encoding was successful.
  *              - LZMA_BUF_ERROR: Not enough output buffer space.
  *              - LZMA_UNSUPPORTED_CHECK
  *              - LZMA_OPTIONS_ERROR
  *              - LZMA_MEM_ERROR
  *              - LZMA_DATA_ERROR
  *              - LZMA_PROG_ERROR
  */
 extern LZMA_API(lzma_ret) lzma_easy_buffer_encode(
 		uint32_t preset, lzma_check check,
 		const lzma_allocator *allocator,
 		const uint8_t *in, size_t in_size,
 		uint8_t *out, size_t *out_pos, size_t out_size) lzma_nothrow;
 
 
 /**
  * \brief       Initialize .xz Stream encoder using a custom filter chain
  *
  * \param       strm    Pointer to lzma_stream that is at least initialized
  *                      with LZMA_STREAM_INIT.
  * \param       filters Array of filters terminated with
  *                      .id == LZMA_VLI_UNKNOWN. See filters.h for more
  *                      information.
  * \param       check   Type of the integrity check to calculate from
  *                      uncompressed data.
  *
  * \return      Possible lzma_ret values:
  *              - LZMA_OK: Initialization was successful.
  *              - LZMA_MEM_ERROR
  *              - LZMA_UNSUPPORTED_CHECK
  *              - LZMA_OPTIONS_ERROR
  *              - LZMA_PROG_ERROR
  */
 extern LZMA_API(lzma_ret) lzma_stream_encoder(lzma_stream *strm,
 		const lzma_filter *filters, lzma_check check)
 		lzma_nothrow lzma_attr_warn_unused_result;
 
 
 /**
  * \brief       Calculate approximate memory usage of multithreaded .xz encoder
  *
  * Since doing the encoding in threaded mode doesn't affect the memory
  * requirements of single-threaded decompressor, you can use
  * lzma_easy_decoder_memusage(options->preset) or
  * lzma_raw_decoder_memusage(options->filters) to calculate
  * the decompressor memory requirements.
  *
  * \param       options Compression options
  *
  * \return      Number of bytes of memory required for encoding with the
  *              given options. If an error occurs, for example due to
  *              unsupported preset or filter chain, UINT64_MAX is returned.
  */
 extern LZMA_API(uint64_t) lzma_stream_encoder_mt_memusage(
 		const lzma_mt *options) lzma_nothrow lzma_attr_pure;
 
 
 /**
  * \brief       Initialize multithreaded .xz Stream encoder
  *
  * This provides the functionality of lzma_easy_encoder() and
  * lzma_stream_encoder() as a single function for multithreaded use.
  *
  * The supported actions for lzma_code() are LZMA_RUN, LZMA_FULL_FLUSH,
  * LZMA_FULL_BARRIER, and LZMA_FINISH. Support for LZMA_SYNC_FLUSH might be
  * added in the future.
  *
  * \param       strm    Pointer to lzma_stream that is at least initialized
  *                      with LZMA_STREAM_INIT.
  * \param       options Pointer to multithreaded compression options
  *
  * \return      Possible lzma_ret values:
  *              - LZMA_OK
  *              - LZMA_MEM_ERROR
  *              - LZMA_UNSUPPORTED_CHECK
  *              - LZMA_OPTIONS_ERROR
  *              - LZMA_PROG_ERROR
  */
 extern LZMA_API(lzma_ret) lzma_stream_encoder_mt(
 		lzma_stream *strm, const lzma_mt *options)
 		lzma_nothrow lzma_attr_warn_unused_result;
 
 
 /**
  * \brief       Calculate recommended Block size for multithreaded .xz encoder
  *
  * This calculates a recommended Block size for multithreaded encoding given
  * a filter chain. This is used internally by lzma_stream_encoder_mt() to
  * determine the Block size if the block_size member is not set to the
  * special value of 0 in the lzma_mt options struct.
  *
  * If one wishes to change the filters between Blocks, this function is
  * helpful to set the block_size member of the lzma_mt struct before calling
  * lzma_stream_encoder_mt(). Since the block_size member represents the
  * maximum possible Block size for the multithreaded .xz encoder, one can
  * use this function to find the maximum recommended Block size based on
  * all planned filter chains. Otherwise, the multithreaded encoder will
  * base its maximum Block size on the first filter chain used (if the
  * block_size member is not set), which may unnecessarily limit the Block
  * size for a later filter chain.
  *
  * \param       filters   Array of filters terminated with
  *                        .id == LZMA_VLI_UNKNOWN.
  *
  * \return      Recommended Block size in bytes, or UINT64_MAX if
  *              an error occurred.
  */
 extern LZMA_API(uint64_t) lzma_mt_block_size(const lzma_filter *filters)
 		lzma_nothrow;
 
 
 /**
  * \brief       Initialize .lzma encoder (legacy file format)
  *
  * The .lzma format is sometimes called the LZMA_Alone format, which is the
  * reason for the name of this function. The .lzma format supports only the
  * LZMA1 filter. There is no support for integrity checks like CRC32.
  *
  * Use this function if and only if you need to create files readable by
  * legacy LZMA tools such as LZMA Utils 4.32.x. Moving to the .xz format
  * is strongly recommended.
  *
  * The valid action values for lzma_code() are LZMA_RUN and LZMA_FINISH.
  * No kind of flushing is supported, because the file format doesn't make
  * it possible.
  *
  * \param       strm    Pointer to lzma_stream that is at least initialized
  *                      with LZMA_STREAM_INIT.
  * \param       options Pointer to encoder options
  *
  * \return      Possible lzma_ret values:
  *              - LZMA_OK
  *              - LZMA_MEM_ERROR
  *              - LZMA_OPTIONS_ERROR
  *              - LZMA_PROG_ERROR
  */
 extern LZMA_API(lzma_ret) lzma_alone_encoder(
 		lzma_stream *strm, const lzma_options_lzma *options)
 		lzma_nothrow lzma_attr_warn_unused_result;
 
 
 /**
  * \brief       Calculate output buffer size for single-call Stream encoder
  *
  * When trying to compress incompressible data, the encoded size will be
  * slightly bigger than the input data. This function calculates how much
  * output buffer space is required to be sure that lzma_stream_buffer_encode()
  * doesn't return LZMA_BUF_ERROR.
  *
  * The calculated value is not exact, but it is guaranteed to be big enough.
  * The actual maximum output space required may be slightly smaller (up to
  * about 100 bytes). This should not be a problem in practice.
  *
  * If the calculated maximum size doesn't fit into size_t or would make the
  * Stream grow past LZMA_VLI_MAX (which should never happen in practice),
  * zero is returned to indicate the error.
  *
  * \note        The limit calculated by this function applies only to
  *              single-call encoding. Multi-call encoding may (and probably
  *              will) have larger maximum expansion when encoding
  *              incompressible data. Currently there is no function to
  *              calculate the maximum expansion of multi-call encoding.
  *
  * \param       uncompressed_size   Size in bytes of the uncompressed
  *                                  input data
  *
  * \return      Maximum number of bytes needed to store the compressed data.
  */
 extern LZMA_API(size_t) lzma_stream_buffer_bound(size_t uncompressed_size)
 		lzma_nothrow;
 
 
 /**
  * \brief       Single-call .xz Stream encoder
  *
  * \param       filters     Array of filters terminated with
  *                          .id == LZMA_VLI_UNKNOWN. See filters.h for more
  *                          information.
  * \param       check       Type of the integrity check to calculate from
  *                          uncompressed data.
  * \param       allocator   lzma_allocator for custom allocator functions.
  *                          Set to NULL to use malloc() and free().
  * \param       in          Beginning of the input buffer
  * \param       in_size     Size of the input buffer
  * \param[out]  out         Beginning of the output buffer
  * \param[out]  out_pos     The next byte will be written to out[*out_pos].
  *                          *out_pos is updated only if encoding succeeds.
  * \param       out_size    Size of the out buffer; the first byte into
  *                          which no data is written to is out[out_size].
  *
  * \return      Possible lzma_ret values:
  *              - LZMA_OK: Encoding was successful.
  *              - LZMA_BUF_ERROR: Not enough output buffer space.
  *              - LZMA_UNSUPPORTED_CHECK
  *              - LZMA_OPTIONS_ERROR
  *              - LZMA_MEM_ERROR
  *              - LZMA_DATA_ERROR
  *              - LZMA_PROG_ERROR
  */
 extern LZMA_API(lzma_ret) lzma_stream_buffer_encode(
 		lzma_filter *filters, lzma_check check,
 		const lzma_allocator *allocator,
 		const uint8_t *in, size_t in_size,
 		uint8_t *out, size_t *out_pos, size_t out_size)
 		lzma_nothrow lzma_attr_warn_unused_result;
 
 
 /**
  * \brief       MicroLZMA encoder
  *
  * The MicroLZMA format is a raw LZMA stream whose first byte (always 0x00)
  * has been replaced with bitwise-negation of the LZMA properties (lc/lp/pb).
  * This encoding ensures that the first byte of MicroLZMA stream is never
  * 0x00. There is no end of payload marker and thus the uncompressed size
  * must be stored separately. For the best error detection the dictionary
  * size should be stored separately as well but alternatively one may use
  * the uncompressed size as the dictionary size when decoding.
  *
  * With the MicroLZMA encoder, lzma_code() behaves slightly unusually.
  * The action argument must be LZMA_FINISH and the return value will never be
  * LZMA_OK. Thus the encoding is always done with a single lzma_code() after
  * the initialization. The benefit of the combination of initialization
  * function and lzma_code() is that memory allocations can be re-used for
  * better performance.
  *
  * lzma_code() will try to encode as much input as is possible to fit into
  * the given output buffer. If not all input can be encoded, the stream will
  * be finished without encoding all the input. The caller must check both
  * input and output buffer usage after lzma_code() (total_in and total_out
  * in lzma_stream can be convenient). Often lzma_code() can fill the output
  * buffer completely if there is a lot of input, but sometimes a few bytes
  * may remain unused because the next LZMA symbol would require more space.
  *
  * lzma_stream.avail_out must be at least 6. Otherwise LZMA_PROG_ERROR
  * will be returned.
  *
  * The LZMA dictionary should be reasonably low to speed up the encoder
  * re-initialization. A good value is bigger than the resulting
  * uncompressed size of most of the output chunks. For example, if output
  * size is 4 KiB, dictionary size of 32 KiB or 64 KiB is good. If the
  * data compresses extremely well, even 128 KiB may be useful.
  *
  * The MicroLZMA format and this encoder variant were made with the EROFS
  * file system in mind. This format may be convenient in other embedded
  * uses too where many small streams are needed. XZ Embedded includes a
  * decoder for this format.
  *
  * \param       strm    Pointer to lzma_stream that is at least initialized
  *                      with LZMA_STREAM_INIT.
  * \param       options Pointer to encoder options
  *
  * \return      Possible lzma_ret values:
  *              - LZMA_STREAM_END: All good. Check the amounts of input used
  *                and output produced. Store the amount of input used
  *                (uncompressed size) as it needs to be known to decompress
  *                the data.
  *              - LZMA_OPTIONS_ERROR
  *              - LZMA_MEM_ERROR
  *              - LZMA_PROG_ERROR: In addition to the generic reasons for this
  *                error code, this may also be returned if there isn't enough
  *                output space (6 bytes) to create a valid MicroLZMA stream.
  */
 extern LZMA_API(lzma_ret) lzma_microlzma_encoder(
 		lzma_stream *strm, const lzma_options_lzma *options)
 		lzma_nothrow;
 
 
 /************
  * Decoding *
  ************/
 
 /**
  * This flag makes lzma_code() return LZMA_NO_CHECK if the input stream
  * being decoded has no integrity check. Note that when used with
  * lzma_auto_decoder(), all .lzma files will trigger LZMA_NO_CHECK
  * if LZMA_TELL_NO_CHECK is used.
  */
 #define LZMA_TELL_NO_CHECK              UINT32_C(0x01)
 
 
 /**
  * This flag makes lzma_code() return LZMA_UNSUPPORTED_CHECK if the input
  * stream has an integrity check, but the type of the integrity check is not
  * supported by this liblzma version or build. Such files can still be
  * decoded, but the integrity check cannot be verified.
  */
 #define LZMA_TELL_UNSUPPORTED_CHECK     UINT32_C(0x02)
 
 
 /**
  * This flag makes lzma_code() return LZMA_GET_CHECK as soon as the type
  * of the integrity check is known. The type can then be got with
  * lzma_get_check().
  */
 #define LZMA_TELL_ANY_CHECK             UINT32_C(0x04)
 
 
 /**
  * This flag makes lzma_code() not calculate and verify the integrity check
  * of the compressed data in .xz files. This means that invalid integrity
  * check values won't be detected and LZMA_DATA_ERROR won't be returned in
  * such cases.
  *
  * This flag only affects the checks of the compressed data itself; the CRC32
  * values in the .xz headers will still be verified normally.
  *
  * Don't use this flag unless you know what you are doing. Possible reasons
  * to use this flag:
  *
  *   - Trying to recover data from a corrupt .xz file.
  *
  *   - Speeding up decompression, which matters mostly with SHA-256
  *     or with files that have compressed extremely well. It's recommended
  *     to not use this flag for this purpose unless the file integrity is
  *     verified externally in some other way.
  *
  * Support for this flag was added in liblzma 5.1.4beta.
  */
 #define LZMA_IGNORE_CHECK               UINT32_C(0x10)
 
 
 /**
  * This flag enables decoding of concatenated files with file formats that
  * allow concatenating compressed files as is. From the formats currently
  * supported by liblzma, only the .xz and .lz formats allow concatenated
  * files. Concatenated files are not allowed with the legacy .lzma format.
  *
- * This flag also affects the usage of the `action' argument for lzma_code().
+ * This flag also affects the usage of the 'action' argument for lzma_code().
  * When LZMA_CONCATENATED is used, lzma_code() won't return LZMA_STREAM_END
- * unless LZMA_FINISH is used as `action'. Thus, the application has to set
+ * unless LZMA_FINISH is used as 'action'. Thus, the application has to set
  * LZMA_FINISH in the same way as it does when encoding.
  *
  * If LZMA_CONCATENATED is not used, the decoders still accept LZMA_FINISH
- * as `action' for lzma_code(), but the usage of LZMA_FINISH isn't required.
+ * as 'action' for lzma_code(), but the usage of LZMA_FINISH isn't required.
  */
 #define LZMA_CONCATENATED               UINT32_C(0x08)
 
 
 /**
  * This flag makes the threaded decoder report errors (like LZMA_DATA_ERROR)
  * as soon as they are detected. This saves time when the application has no
  * interest in a partially decompressed truncated or corrupt file. Note that
  * due to timing randomness, if the same truncated or corrupt input is
  * decompressed multiple times with this flag, a different amount of output
  * may be produced by different runs, and even the error code might vary.
  *
  * When using LZMA_FAIL_FAST, it is recommended to use LZMA_FINISH to tell
  * the decoder when no more input will be coming because it can help fast
  * detection and reporting of truncated files. Note that in this situation
  * truncated files might be diagnosed with LZMA_DATA_ERROR instead of
  * LZMA_OK or LZMA_BUF_ERROR!
  *
  * Without this flag the threaded decoder will provide as much output as
  * possible at first and then report the pending error. This default behavior
  * matches the single-threaded decoder and provides repeatable behavior
  * with truncated or corrupt input. There are a few special cases where the
  * behavior can still differ like memory allocation failures (LZMA_MEM_ERROR).
  *
  * Single-threaded decoders currently ignore this flag.
  *
  * Support for this flag was added in liblzma 5.3.3alpha. Note that in older
  * versions this flag isn't supported (LZMA_OPTIONS_ERROR) even by functions
  * that ignore this flag in newer liblzma versions.
  */
 #define LZMA_FAIL_FAST                  UINT32_C(0x20)
 
 
 /**
  * \brief       Initialize .xz Stream decoder
  *
  * \param       strm        Pointer to lzma_stream that is at least initialized
  *                          with LZMA_STREAM_INIT.
  * \param       memlimit    Memory usage limit as bytes. Use UINT64_MAX
  *                          to effectively disable the limiter. liblzma
  *                          5.2.3 and earlier don't allow 0 here and return
  *                          LZMA_PROG_ERROR; later versions treat 0 as if 1
  *                          had been specified.
  * \param       flags       Bitwise-or of zero or more of the decoder flags:
  *                          LZMA_TELL_NO_CHECK, LZMA_TELL_UNSUPPORTED_CHECK,
  *                          LZMA_TELL_ANY_CHECK, LZMA_IGNORE_CHECK,
  *                          LZMA_CONCATENATED, LZMA_FAIL_FAST
  *
  * \return      Possible lzma_ret values:
  *              - LZMA_OK: Initialization was successful.
  *              - LZMA_MEM_ERROR: Cannot allocate memory.
  *              - LZMA_OPTIONS_ERROR: Unsupported flags
  *              - LZMA_PROG_ERROR
  */
 extern LZMA_API(lzma_ret) lzma_stream_decoder(
 		lzma_stream *strm, uint64_t memlimit, uint32_t flags)
 		lzma_nothrow lzma_attr_warn_unused_result;
 
 
 /**
  * \brief       Initialize multithreaded .xz Stream decoder
  *
  * The decoder can decode multiple Blocks in parallel. This requires that each
  * Block Header contains the Compressed Size and Uncompressed size fields
  * which are added by the multi-threaded encoder, see lzma_stream_encoder_mt().
  *
  * A Stream with one Block will only utilize one thread. A Stream with multiple
  * Blocks but without size information in Block Headers will be processed in
  * single-threaded mode in the same way as done by lzma_stream_decoder().
  * Concatenated Streams are processed one Stream at a time; no inter-Stream
  * parallelization is done.
  *
  * This function behaves like lzma_stream_decoder() when options->threads == 1
  * and options->memlimit_threading <= 1.
  *
  * \param       strm        Pointer to lzma_stream that is at least initialized
  *                          with LZMA_STREAM_INIT.
  * \param       options     Pointer to multithreaded compression options
  *
  * \return      Possible lzma_ret values:
  *              - LZMA_OK: Initialization was successful.
  *              - LZMA_MEM_ERROR: Cannot allocate memory.
  *              - LZMA_MEMLIMIT_ERROR: Memory usage limit was reached.
  *              - LZMA_OPTIONS_ERROR: Unsupported flags.
  *              - LZMA_PROG_ERROR
  */
 extern LZMA_API(lzma_ret) lzma_stream_decoder_mt(
 		lzma_stream *strm, const lzma_mt *options)
 		lzma_nothrow lzma_attr_warn_unused_result;
 
 
 /**
  * \brief       Decode .xz, .lzma, and .lz (lzip) files with autodetection
  *
  * This decoder autodetects between the .xz, .lzma, and .lz file formats,
  * and calls lzma_stream_decoder(), lzma_alone_decoder(), or
  * lzma_lzip_decoder() once the type of the input file has been detected.
  *
  * Support for .lz was added in 5.4.0.
  *
  * If the flag LZMA_CONCATENATED is used and the input is a .lzma file:
  * For historical reasons concatenated .lzma files aren't supported.
  * If there is trailing data after one .lzma stream, lzma_code() will
  * return LZMA_DATA_ERROR. (lzma_alone_decoder() doesn't have such a check
  * as it doesn't support any decoder flags. It will return LZMA_STREAM_END
  * after one .lzma stream.)
  *
   * \param       strm       Pointer to lzma_stream that is at least initialized
  *                          with LZMA_STREAM_INIT.
  * \param       memlimit    Memory usage limit as bytes. Use UINT64_MAX
  *                          to effectively disable the limiter. liblzma
  *                          5.2.3 and earlier don't allow 0 here and return
  *                          LZMA_PROG_ERROR; later versions treat 0 as if 1
  *                          had been specified.
  * \param       flags       Bitwise-or of zero or more of the decoder flags:
  *                          LZMA_TELL_NO_CHECK, LZMA_TELL_UNSUPPORTED_CHECK,
  *                          LZMA_TELL_ANY_CHECK, LZMA_IGNORE_CHECK,
  *                          LZMA_CONCATENATED, LZMA_FAIL_FAST
  *
  * \return      Possible lzma_ret values:
  *              - LZMA_OK: Initialization was successful.
  *              - LZMA_MEM_ERROR: Cannot allocate memory.
  *              - LZMA_OPTIONS_ERROR: Unsupported flags
  *              - LZMA_PROG_ERROR
  */
 extern LZMA_API(lzma_ret) lzma_auto_decoder(
 		lzma_stream *strm, uint64_t memlimit, uint32_t flags)
 		lzma_nothrow lzma_attr_warn_unused_result;
 
 
 /**
  * \brief       Initialize .lzma decoder (legacy file format)
  *
- * Valid `action' arguments to lzma_code() are LZMA_RUN and LZMA_FINISH.
+ * Valid 'action' arguments to lzma_code() are LZMA_RUN and LZMA_FINISH.
  * There is no need to use LZMA_FINISH, but it's allowed because it may
  * simplify certain types of applications.
  *
  * \param       strm        Pointer to lzma_stream that is at least initialized
  *                          with LZMA_STREAM_INIT.
  * \param       memlimit    Memory usage limit as bytes. Use UINT64_MAX
  *                          to effectively disable the limiter. liblzma
  *                          5.2.3 and earlier don't allow 0 here and return
  *                          LZMA_PROG_ERROR; later versions treat 0 as if 1
  *                          had been specified.
  *
  * \return      Possible lzma_ret values:
  *              - LZMA_OK
  *              - LZMA_MEM_ERROR
  *              - LZMA_PROG_ERROR
  */
 extern LZMA_API(lzma_ret) lzma_alone_decoder(
 		lzma_stream *strm, uint64_t memlimit)
 		lzma_nothrow lzma_attr_warn_unused_result;
 
 
 /**
  * \brief       Initialize .lz (lzip) decoder (a foreign file format)
  *
  * This decoder supports the .lz format version 0 and the unextended .lz
  * format version 1:
  *
  *   - Files in the format version 0 were produced by lzip 1.3 and older.
  *     Such files aren't common but may be found from file archives
  *     as a few source packages were released in this format. People
  *     might have old personal files in this format too. Decompression
  *     support for the format version 0 was removed in lzip 1.18.
  *
  *   - lzip 1.3 added decompression support for .lz format version 1 files.
  *     Compression support was added in lzip 1.4. In lzip 1.6 the .lz format
  *     version 1 was extended to support the Sync Flush marker. This extension
  *     is not supported by liblzma. lzma_code() will return LZMA_DATA_ERROR
  *     at the location of the Sync Flush marker. In practice files with
  *     the Sync Flush marker are very rare and thus liblzma can decompress
  *     almost all .lz files.
  *
  * Just like with lzma_stream_decoder() for .xz files, LZMA_CONCATENATED
  * should be used when decompressing normal standalone .lz files.
  *
  * The .lz format allows putting non-.lz data at the end of a file after at
  * least one valid .lz member. That is, one can append custom data at the end
  * of a .lz file and the decoder is required to ignore it. In liblzma this
  * is relevant only when LZMA_CONCATENATED is used. In that case lzma_code()
  * will return LZMA_STREAM_END and leave lzma_stream.next_in pointing to
  * the first byte of the non-.lz data. An exception to this is if the first
  * 1-3 bytes of the non-.lz data are identical to the .lz magic bytes
  * (0x4C, 0x5A, 0x49, 0x50; "LZIP" in US-ASCII). In such a case the 1-3 bytes
  * will have been ignored by lzma_code(). If one wishes to locate the non-.lz
  * data reliably, one must ensure that the first byte isn't 0x4C. Actually
  * one should ensure that none of the first four bytes of trailing data are
  * equal to the magic bytes because lzip >= 1.20 requires it by default.
  *
  * \param       strm        Pointer to lzma_stream that is at least initialized
  *                          with LZMA_STREAM_INIT.
  * \param       memlimit    Memory usage limit as bytes. Use UINT64_MAX
  *                          to effectively disable the limiter.
  * \param       flags       Bitwise-or of flags, or zero for no flags.
  *                          All decoder flags listed above are supported
  *                          although only LZMA_CONCATENATED and (in very rare
  *                          cases) LZMA_IGNORE_CHECK are actually useful.
  *                          LZMA_TELL_NO_CHECK, LZMA_TELL_UNSUPPORTED_CHECK,
  *                          and LZMA_FAIL_FAST do nothing. LZMA_TELL_ANY_CHECK
  *                          is supported for consistency only as CRC32 is
  *                          always used in the .lz format.
  *
  * \return      Possible lzma_ret values:
  *              - LZMA_OK: Initialization was successful.
  *              - LZMA_MEM_ERROR: Cannot allocate memory.
  *              - LZMA_OPTIONS_ERROR: Unsupported flags
  *              - LZMA_PROG_ERROR
  */
 extern LZMA_API(lzma_ret) lzma_lzip_decoder(
 		lzma_stream *strm, uint64_t memlimit, uint32_t flags)
 		lzma_nothrow lzma_attr_warn_unused_result;
 
 
 /**
  * \brief       Single-call .xz Stream decoder
  *
  * \param       memlimit    Pointer to how much memory the decoder is allowed
  *                          to allocate. The value pointed by this pointer is
  *                          modified if and only if LZMA_MEMLIMIT_ERROR is
  *                          returned.
  * \param       flags       Bitwise-or of zero or more of the decoder flags:
  *                          LZMA_TELL_NO_CHECK, LZMA_TELL_UNSUPPORTED_CHECK,
  *                          LZMA_IGNORE_CHECK, LZMA_CONCATENATED,
  *                          LZMA_FAIL_FAST. Note that LZMA_TELL_ANY_CHECK
  *                          is not allowed and will return LZMA_PROG_ERROR.
  * \param       allocator   lzma_allocator for custom allocator functions.
  *                          Set to NULL to use malloc() and free().
  * \param       in          Beginning of the input buffer
  * \param       in_pos      The next byte will be read from in[*in_pos].
  *                          *in_pos is updated only if decoding succeeds.
  * \param       in_size     Size of the input buffer; the first byte that
  *                          won't be read is in[in_size].
  * \param[out]  out         Beginning of the output buffer
  * \param[out]  out_pos     The next byte will be written to out[*out_pos].
  *                          *out_pos is updated only if decoding succeeds.
  * \param       out_size    Size of the out buffer; the first byte into
  *                          which no data is written to is out[out_size].
  *
  * \return      Possible lzma_ret values:
  *              - LZMA_OK: Decoding was successful.
  *              - LZMA_FORMAT_ERROR
  *              - LZMA_OPTIONS_ERROR
  *              - LZMA_DATA_ERROR
  *              - LZMA_NO_CHECK: This can be returned only if using
  *                the LZMA_TELL_NO_CHECK flag.
  *              - LZMA_UNSUPPORTED_CHECK: This can be returned only if using
  *                the LZMA_TELL_UNSUPPORTED_CHECK flag.
  *              - LZMA_MEM_ERROR
  *              - LZMA_MEMLIMIT_ERROR: Memory usage limit was reached.
  *                The minimum required memlimit value was stored to *memlimit.
  *              - LZMA_BUF_ERROR: Output buffer was too small.
  *              - LZMA_PROG_ERROR
  */
 extern LZMA_API(lzma_ret) lzma_stream_buffer_decode(
 		uint64_t *memlimit, uint32_t flags,
 		const lzma_allocator *allocator,
 		const uint8_t *in, size_t *in_pos, size_t in_size,
 		uint8_t *out, size_t *out_pos, size_t out_size)
 		lzma_nothrow lzma_attr_warn_unused_result;
 
 
 /**
  * \brief       MicroLZMA decoder
  *
  * See lzma_microlzma_encoder() for more information.
  *
  * The lzma_code() usage with this decoder is completely normal. The
  * special behavior of lzma_code() applies to lzma_microlzma_encoder() only.
  *
  * \param       strm        Pointer to lzma_stream that is at least initialized
  *                          with LZMA_STREAM_INIT.
  * \param       comp_size   Compressed size of the MicroLZMA stream.
  *                          The caller must somehow know this exactly.
  * \param       uncomp_size Uncompressed size of the MicroLZMA stream.
  *                          If the exact uncompressed size isn't known, this
  *                          can be set to a value that is at most as big as
  *                          the exact uncompressed size would be, but then the
  *                          next argument uncomp_size_is_exact must be false.
  * \param       uncomp_size_is_exact
  *                          If true, uncomp_size must be exactly correct.
  *                          This will improve error detection at the end of
  *                          the stream. If the exact uncompressed size isn't
  *                          known, this must be false. uncomp_size must still
  *                          be at most as big as the exact uncompressed size
  *                          is. Setting this to false when the exact size is
  *                          known will work but error detection at the end of
  *                          the stream will be weaker.
  * \param       dict_size   LZMA dictionary size that was used when
  *                          compressing the data. It is OK to use a bigger
  *                          value too but liblzma will then allocate more
  *                          memory than would actually be required and error
  *                          detection will be slightly worse. (Note that with
  *                          the implementation in XZ Embedded it doesn't
  *                          affect the memory usage if one specifies bigger
  *                          dictionary than actually required.)
  *
  * \return      Possible lzma_ret values:
  *              - LZMA_OK
  *              - LZMA_MEM_ERROR
  *              - LZMA_OPTIONS_ERROR
  *              - LZMA_PROG_ERROR
  */
 extern LZMA_API(lzma_ret) lzma_microlzma_decoder(
 		lzma_stream *strm, uint64_t comp_size,
 		uint64_t uncomp_size, lzma_bool uncomp_size_is_exact,
 		uint32_t dict_size) lzma_nothrow;
diff --git a/src/liblzma/api/lzma/filter.h b/src/liblzma/api/lzma/filter.h
index 1d887b4f..4f601d6c 100644
--- a/src/liblzma/api/lzma/filter.h
+++ b/src/liblzma/api/lzma/filter.h
@@ -1,770 +1,770 @@
 /**
  * \file        lzma/filter.h
  * \brief       Common filter related types and functions
  * \note        Never include this file directly. Use <lzma.h> instead.
  */
 
 /*
  * Author: Lasse Collin
  *
  * This file has been put into the public domain.
  * You can do whatever you want with this file.
  */
 
 #ifndef LZMA_H_INTERNAL
 #	error Never include this file directly. Use <lzma.h> instead.
 #endif
 
 
 /**
  * \brief       Maximum number of filters in a chain
  *
  * A filter chain can have 1-4 filters, of which three are allowed to change
  * the size of the data. Usually only one or two filters are needed.
  */
 #define LZMA_FILTERS_MAX 4
 
 
 /**
  * \brief       Filter options
  *
  * This structure is used to pass a Filter ID and a pointer to the filter's
  * options to liblzma. A few functions work with a single lzma_filter
  * structure, while most functions expect a filter chain.
  *
  * A filter chain is indicated with an array of lzma_filter structures.
  * The array is terminated with .id = LZMA_VLI_UNKNOWN. Thus, the filter
  * array must have LZMA_FILTERS_MAX + 1 elements (that is, five) to
  * be able to hold any arbitrary filter chain. This is important when
  * using lzma_block_header_decode() from block.h, because a filter array
  * that is too small would make liblzma write past the end of the array.
  */
 typedef struct {
 	/**
 	 * \brief       Filter ID
 	 *
-	 * Use constants whose name begin with `LZMA_FILTER_' to specify
+	 * Use constants whose name begin with 'LZMA_FILTER_' to specify
 	 * different filters. In an array of lzma_filter structures, use
 	 * LZMA_VLI_UNKNOWN to indicate end of filters.
 	 *
 	 * \note        This is not an enum, because on some systems enums
 	 *              cannot be 64-bit.
 	 */
 	lzma_vli id;
 
 	/**
 	 * \brief       Pointer to filter-specific options structure
 	 *
 	 * If the filter doesn't need options, set this to NULL. If id is
 	 * set to LZMA_VLI_UNKNOWN, options is ignored, and thus
 	 * doesn't need be initialized.
 	 */
 	void *options;
 
 } lzma_filter;
 
 
 /**
  * \brief       Test if the given Filter ID is supported for encoding
  *
  * \param       id      Filter ID
  *
  * \return      lzma_bool:
  *              - true if the Filter ID is supported for encoding by this
  *                liblzma build.
   *             - false otherwise.
  */
 extern LZMA_API(lzma_bool) lzma_filter_encoder_is_supported(lzma_vli id)
 		lzma_nothrow lzma_attr_const;
 
 
 /**
  * \brief       Test if the given Filter ID is supported for decoding
  *
  * \param       id      Filter ID
  *
  * \return      lzma_bool:
  *              - true if the Filter ID is supported for decoding by this
  *                liblzma build.
  *              - false otherwise.
  */
 extern LZMA_API(lzma_bool) lzma_filter_decoder_is_supported(lzma_vli id)
 		lzma_nothrow lzma_attr_const;
 
 
 /**
  * \brief       Copy the filters array
  *
  * Copy the Filter IDs and filter-specific options from src to dest.
  * Up to LZMA_FILTERS_MAX filters are copied, plus the terminating
  * .id == LZMA_VLI_UNKNOWN. Thus, dest should have at least
  * LZMA_FILTERS_MAX + 1 elements space unless the caller knows that
  * src is smaller than that.
  *
  * Unless the filter-specific options is NULL, the Filter ID has to be
  * supported by liblzma, because liblzma needs to know the size of every
  * filter-specific options structure. The filter-specific options are not
  * validated. If options is NULL, any unsupported Filter IDs are copied
  * without returning an error.
  *
  * Old filter-specific options in dest are not freed, so dest doesn't
  * need to be initialized by the caller in any way.
  *
  * If an error occurs, memory possibly already allocated by this function
  * is always freed. liblzma versions older than 5.2.7 may modify the dest
  * array and leave its contents in an undefined state if an error occurs.
  * liblzma 5.2.7 and newer only modify the dest array when returning LZMA_OK.
  *
  * \param       src         Array of filters terminated with
  *                          .id == LZMA_VLI_UNKNOWN.
  * \param[out]  dest        Destination filter array
  * \param       allocator   lzma_allocator for custom allocator functions.
  *                          Set to NULL to use malloc() and free().
  *
  * \return      Possible lzma_ret values:
  *              - LZMA_OK
  *              - LZMA_MEM_ERROR
  *              - LZMA_OPTIONS_ERROR: Unsupported Filter ID and its options
  *                is not NULL.
  *              - LZMA_PROG_ERROR: src or dest is NULL.
  */
 extern LZMA_API(lzma_ret) lzma_filters_copy(
 		const lzma_filter *src, lzma_filter *dest,
 		const lzma_allocator *allocator)
 		lzma_nothrow lzma_attr_warn_unused_result;
 
 
 /**
  * \brief       Free the options in the array of lzma_filter structures
  *
  * This frees the filter chain options. The filters array itself is not freed.
  *
  * The filters array must have at most LZMA_FILTERS_MAX + 1 elements
  * including the terminating element which must have .id = LZMA_VLI_UNKNOWN.
  * For all elements before the terminating element:
  *   - options will be freed using the given lzma_allocator or,
  *     if allocator is NULL, using free().
  *   - options will be set to NULL.
  *   - id will be set to LZMA_VLI_UNKNOWN.
  *
  * If filters is NULL, this does nothing. Again, this never frees the
  * filters array itself.
  *
  * \param       filters     Array of filters terminated with
  *                          .id == LZMA_VLI_UNKNOWN.
  * \param       allocator   lzma_allocator for custom allocator functions.
  *                          Set to NULL to use malloc() and free().
  */
 extern LZMA_API(void) lzma_filters_free(
 		lzma_filter *filters, const lzma_allocator *allocator)
 		lzma_nothrow;
 
 
 /**
  * \brief       Calculate approximate memory requirements for raw encoder
  *
  * This function can be used to calculate the memory requirements for
  * Block and Stream encoders too because Block and Stream encoders don't
  * need significantly more memory than raw encoder.
  *
  * \param       filters     Array of filters terminated with
  *                          .id == LZMA_VLI_UNKNOWN.
  *
  * \return      Number of bytes of memory required for the given
  *              filter chain when encoding or UINT64_MAX on error.
  */
 extern LZMA_API(uint64_t) lzma_raw_encoder_memusage(const lzma_filter *filters)
 		lzma_nothrow lzma_attr_pure;
 
 
 /**
  * \brief       Calculate approximate memory requirements for raw decoder
  *
  * This function can be used to calculate the memory requirements for
  * Block and Stream decoders too because Block and Stream decoders don't
  * need significantly more memory than raw decoder.
  *
  * \param       filters     Array of filters terminated with
  *                          .id == LZMA_VLI_UNKNOWN.
  *
  * \return      Number of bytes of memory required for the given
  *              filter chain when decoding or UINT64_MAX on error.
  */
 extern LZMA_API(uint64_t) lzma_raw_decoder_memusage(const lzma_filter *filters)
 		lzma_nothrow lzma_attr_pure;
 
 
 /**
  * \brief       Initialize raw encoder
  *
  * This function may be useful when implementing custom file formats.
  *
- * The `action' with lzma_code() can be LZMA_RUN, LZMA_SYNC_FLUSH (if the
+ * The 'action' with lzma_code() can be LZMA_RUN, LZMA_SYNC_FLUSH (if the
  * filter chain supports it), or LZMA_FINISH.
  *
  * \param       strm      Pointer to lzma_stream that is at least
  *                        initialized with LZMA_STREAM_INIT.
  * \param       filters   Array of filters terminated with
  *                        .id == LZMA_VLI_UNKNOWN.
  *
  * \return      Possible lzma_ret values:
  *              - LZMA_OK
  *              - LZMA_MEM_ERROR
  *              - LZMA_OPTIONS_ERROR
  *              - LZMA_PROG_ERROR
  */
 extern LZMA_API(lzma_ret) lzma_raw_encoder(
 		lzma_stream *strm, const lzma_filter *filters)
 		lzma_nothrow lzma_attr_warn_unused_result;
 
 
 /**
  * \brief       Initialize raw decoder
  *
  * The initialization of raw decoder goes similarly to raw encoder.
  *
- * The `action' with lzma_code() can be LZMA_RUN or LZMA_FINISH. Using
+ * The 'action' with lzma_code() can be LZMA_RUN or LZMA_FINISH. Using
  * LZMA_FINISH is not required, it is supported just for convenience.
  *
  * \param       strm      Pointer to lzma_stream that is at least
  *                        initialized with LZMA_STREAM_INIT.
  * \param       filters   Array of filters terminated with
  *                        .id == LZMA_VLI_UNKNOWN.
  *
  * \return      Possible lzma_ret values:
  *              - LZMA_OK
  *              - LZMA_MEM_ERROR
  *              - LZMA_OPTIONS_ERROR
  *              - LZMA_PROG_ERROR
  */
 extern LZMA_API(lzma_ret) lzma_raw_decoder(
 		lzma_stream *strm, const lzma_filter *filters)
 		lzma_nothrow lzma_attr_warn_unused_result;
 
 
 /**
  * \brief       Update the filter chain in the encoder
  *
  * This function may be called after lzma_code() has returned LZMA_STREAM_END
  * when LZMA_FULL_BARRIER, LZMA_FULL_FLUSH, or LZMA_SYNC_FLUSH was used:
  *
  *  - After LZMA_FULL_BARRIER or LZMA_FULL_FLUSH: Single-threaded .xz Stream
  *    encoder (lzma_stream_encoder()) and (since liblzma 5.4.0) multi-threaded
  *    Stream encoder (lzma_stream_encoder_mt()) allow setting a new filter
  *    chain to be used for the next Block(s).
  *
  *  - After LZMA_SYNC_FLUSH: Raw encoder (lzma_raw_encoder()),
  *    Block encoder (lzma_block_encoder()), and single-threaded .xz Stream
  *    encoder (lzma_stream_encoder()) allow changing certain filter-specific
  *    options in the middle of encoding. The actual filters in the chain
  *    (Filter IDs) must not be changed! Currently only the lc, lp, and pb
  *    options of LZMA2 (not LZMA1) can be changed this way.
  *
  *  - In the future some filters might allow changing some of their options
  *    without any barrier or flushing but currently such filters don't exist.
  *
  * This function may also be called when no data has been compressed yet
  * although this is rarely useful. In that case, this function will behave
  * as if LZMA_FULL_FLUSH (Stream encoders) or LZMA_SYNC_FLUSH (Raw or Block
  * encoder) had been used right before calling this function.
  *
  * \param       strm      Pointer to lzma_stream that is at least
  *                        initialized with LZMA_STREAM_INIT.
  * \param       filters   Array of filters terminated with
  *                        .id == LZMA_VLI_UNKNOWN.
  *
  * \return      Possible lzma_ret values:
  *              - LZMA_OK
  *              - LZMA_MEM_ERROR
  *              - LZMA_MEMLIMIT_ERROR
  *              - LZMA_OPTIONS_ERROR
  *              - LZMA_PROG_ERROR
  */
 extern LZMA_API(lzma_ret) lzma_filters_update(
 		lzma_stream *strm, const lzma_filter *filters) lzma_nothrow;
 
 
 /**
  * \brief       Single-call raw encoder
  *
  * \note        There is no function to calculate how big output buffer
  *              would surely be big enough. (lzma_stream_buffer_bound()
  *              works only for lzma_stream_buffer_encode(); raw encoder
  *              won't necessarily meet that bound.)
  *
  * \param       filters     Array of filters terminated with
  *                          .id == LZMA_VLI_UNKNOWN.
  * \param       allocator   lzma_allocator for custom allocator functions.
  *                          Set to NULL to use malloc() and free().
  * \param       in          Beginning of the input buffer
  * \param       in_size     Size of the input buffer
  * \param[out]  out         Beginning of the output buffer
  * \param[out]  out_pos     The next byte will be written to out[*out_pos].
  *                          *out_pos is updated only if encoding succeeds.
  * \param       out_size    Size of the out buffer; the first byte into
  *                          which no data is written to is out[out_size].
  *
  * \return      Possible lzma_ret values:
  *              - LZMA_OK: Encoding was successful.
  *              - LZMA_BUF_ERROR: Not enough output buffer space.
  *              - LZMA_OPTIONS_ERROR
  *              - LZMA_MEM_ERROR
  *              - LZMA_DATA_ERROR
  *              - LZMA_PROG_ERROR
  */
 extern LZMA_API(lzma_ret) lzma_raw_buffer_encode(
 		const lzma_filter *filters, const lzma_allocator *allocator,
 		const uint8_t *in, size_t in_size, uint8_t *out,
 		size_t *out_pos, size_t out_size) lzma_nothrow;
 
 
 /**
  * \brief       Single-call raw decoder
  *
  * \param       filters     Array of filters terminated with
  *                          .id == LZMA_VLI_UNKNOWN.
  * \param       allocator   lzma_allocator for custom allocator functions.
  *                          Set to NULL to use malloc() and free().
  * \param       in          Beginning of the input buffer
  * \param       in_pos      The next byte will be read from in[*in_pos].
  *                          *in_pos is updated only if decoding succeeds.
  * \param       in_size     Size of the input buffer; the first byte that
  *                          won't be read is in[in_size].
  * \param[out]  out         Beginning of the output buffer
  * \param[out]  out_pos     The next byte will be written to out[*out_pos].
  *                          *out_pos is updated only if encoding succeeds.
  * \param       out_size    Size of the out buffer; the first byte into
  *                          which no data is written to is out[out_size].
  *
  * \return      Possible lzma_ret values:
  *              - LZMA_OK: Decoding was successful.
  *              - LZMA_BUF_ERROR: Not enough output buffer space.
  *              - LZMA_OPTIONS_ERROR
  *              - LZMA_MEM_ERROR
  *              - LZMA_DATA_ERROR
  *              - LZMA_PROG_ERROR
  */
 extern LZMA_API(lzma_ret) lzma_raw_buffer_decode(
 		const lzma_filter *filters, const lzma_allocator *allocator,
 		const uint8_t *in, size_t *in_pos, size_t in_size,
 		uint8_t *out, size_t *out_pos, size_t out_size) lzma_nothrow;
 
 
 /**
  * \brief       Get the size of the Filter Properties field
  *
  * This function may be useful when implementing custom file formats
  * using the raw encoder and decoder.
  *
  * \note        This function validates the Filter ID, but does not
  *              necessarily validate the options. Thus, it is possible
  *              that this returns LZMA_OK while the following call to
  *              lzma_properties_encode() returns LZMA_OPTIONS_ERROR.
  *
  * \param[out]  size    Pointer to uint32_t to hold the size of the properties
  * \param       filter  Filter ID and options (the size of the properties may
  *                      vary depending on the options)
  *
  * \return      Possible lzma_ret values:
  *              - LZMA_OK
  *              - LZMA_OPTIONS_ERROR
  *              - LZMA_PROG_ERROR
  */
 extern LZMA_API(lzma_ret) lzma_properties_size(
 		uint32_t *size, const lzma_filter *filter) lzma_nothrow;
 
 
 /**
  * \brief       Encode the Filter Properties field
  *
  * \note        Even this function won't validate more options than actually
  *              necessary. Thus, it is possible that encoding the properties
  *              succeeds but using the same options to initialize the encoder
  *              will fail.
  *
  * \note        If lzma_properties_size() indicated that the size
  *              of the Filter Properties field is zero, calling
  *              lzma_properties_encode() is not required, but it
  *              won't do any harm either.
  *
  * \param       filter  Filter ID and options
  * \param[out]  props   Buffer to hold the encoded options. The size of
  *                      the buffer must have been already determined with
  *                      lzma_properties_size().
  *
  * \return      Possible lzma_ret values:
  *              - LZMA_OK
  *              - LZMA_PROG_ERROR
  */
 extern LZMA_API(lzma_ret) lzma_properties_encode(
 		const lzma_filter *filter, uint8_t *props) lzma_nothrow;
 
 
 /**
  * \brief       Decode the Filter Properties field
  *
  * \param       filter      filter->id must have been set to the correct
  *                          Filter ID. filter->options doesn't need to be
  *                          initialized (it's not freed by this function). The
  *                          decoded options will be stored in filter->options;
  *                          it's application's responsibility to free it when
  *                          appropriate. filter->options is set to NULL if
  *                          there are no properties or if an error occurs.
  * \param       allocator   lzma_allocator for custom allocator functions.
  *                          Set to NULL to use malloc() and free().
  *                          and in case of an error, also free().
  * \param       props       Input buffer containing the properties.
  * \param       props_size  Size of the properties. This must be the exact
  *                          size; giving too much or too little input will
  *                          return LZMA_OPTIONS_ERROR.
  *
  * \return      Possible lzma_ret values:
  *              - LZMA_OK
  *              - LZMA_OPTIONS_ERROR
  *              - LZMA_MEM_ERROR
  */
 extern LZMA_API(lzma_ret) lzma_properties_decode(
 		lzma_filter *filter, const lzma_allocator *allocator,
 		const uint8_t *props, size_t props_size) lzma_nothrow;
 
 
 /**
  * \brief       Calculate encoded size of a Filter Flags field
  *
  * Knowing the size of Filter Flags is useful to know when allocating
  * memory to hold the encoded Filter Flags.
  *
  * \note        If you need to calculate size of List of Filter Flags,
  *              you need to loop over every lzma_filter entry.
  *
  * \param[out]  size    Pointer to integer to hold the calculated size
  * \param       filter  Filter ID and associated options whose encoded
  *                      size is to be calculated
  *
  * \return      Possible lzma_ret values:
  *              - LZMA_OK: *size set successfully. Note that this doesn't
  *                guarantee that filter->options is valid, thus
  *                lzma_filter_flags_encode() may still fail.
  *              - LZMA_OPTIONS_ERROR: Unknown Filter ID or unsupported options.
  *              - LZMA_PROG_ERROR: Invalid options
  */
 extern LZMA_API(lzma_ret) lzma_filter_flags_size(
 		uint32_t *size, const lzma_filter *filter)
 		lzma_nothrow lzma_attr_warn_unused_result;
 
 
 /**
  * \brief       Encode Filter Flags into given buffer
  *
  * In contrast to some functions, this doesn't allocate the needed buffer.
  * This is due to how this function is used internally by liblzma.
  *
  * \param       filter      Filter ID and options to be encoded
  * \param[out]  out         Beginning of the output buffer
  * \param[out]  out_pos     out[*out_pos] is the next write position. This
  *                          is updated by the encoder.
  * \param       out_size    out[out_size] is the first byte to not write.
  *
  * \return      Possible lzma_ret values:
  *              - LZMA_OK: Encoding was successful.
  *              - LZMA_OPTIONS_ERROR: Invalid or unsupported options.
  *              - LZMA_PROG_ERROR: Invalid options or not enough output
  *                buffer space (you should have checked it with
  *                lzma_filter_flags_size()).
  */
 extern LZMA_API(lzma_ret) lzma_filter_flags_encode(const lzma_filter *filter,
 		uint8_t *out, size_t *out_pos, size_t out_size)
 		lzma_nothrow lzma_attr_warn_unused_result;
 
 
 /**
  * \brief       Decode Filter Flags from given buffer
  *
  * The decoded result is stored into *filter. The old value of
  * filter->options is not free()d. If anything other than LZMA_OK
  * is returned, filter->options is set to NULL.
  *
  * \param[out]  filter      Destination filter. The decoded Filter ID will
  *                          be stored in filter->id. If options are needed
  *                          they will be allocated and the pointer will be
  *                          stored in filter->options.
  * \param       allocator   lzma_allocator for custom allocator functions.
  *                          Set to NULL to use malloc() and free().
  * \param       in          Beginning of the input buffer
  * \param[out]  in_pos      The next byte will be read from in[*in_pos].
  *                          *in_pos is updated only if decoding succeeds.
  * \param       in_size     Size of the input buffer; the first byte that
  *                          won't be read is in[in_size].
  *
  * \return      Possible lzma_ret values:
  *              - LZMA_OK
  *              - LZMA_OPTIONS_ERROR
  *              - LZMA_MEM_ERROR
  *              - LZMA_DATA_ERROR
  *              - LZMA_PROG_ERROR
  */
 extern LZMA_API(lzma_ret) lzma_filter_flags_decode(
 		lzma_filter *filter, const lzma_allocator *allocator,
 		const uint8_t *in, size_t *in_pos, size_t in_size)
 		lzma_nothrow lzma_attr_warn_unused_result;
 
 
 /***********
  * Strings *
  ***********/
 
 /**
  * \brief       Allow or show all filters
  *
  * By default only the filters supported in the .xz format are accept by
  * lzma_str_to_filters() or shown by lzma_str_list_filters().
  */
 #define LZMA_STR_ALL_FILTERS    UINT32_C(0x01)
 
 
 /**
  * \brief       Do not validate the filter chain in lzma_str_to_filters()
  *
  * By default lzma_str_to_filters() can return an error if the filter chain
  * as a whole isn't usable in the .xz format or in the raw encoder or decoder.
  * With this flag, this validation is skipped. This flag doesn't affect the
  * handling of the individual filter options. To allow non-.xz filters also
  * LZMA_STR_ALL_FILTERS is needed.
  */
 #define LZMA_STR_NO_VALIDATION  UINT32_C(0x02)
 
 
 /**
  * \brief       Stringify encoder options
  *
  * Show the filter-specific options that the encoder will use.
  * This may be useful for verbose diagnostic messages.
  *
  * Note that if options were decoded from .xz headers then the encoder options
  * may be undefined. This flag shouldn't be used in such a situation.
  */
 #define LZMA_STR_ENCODER        UINT32_C(0x10)
 
 
 /**
  * \brief       Stringify decoder options
  *
  * Show the filter-specific options that the decoder will use.
  * This may be useful for showing what filter options were decoded
  * from file headers.
  */
 #define LZMA_STR_DECODER        UINT32_C(0x20)
 
 
 /**
  * \brief       Produce xz-compatible getopt_long() syntax
  *
  * That is, "delta:dist=2 lzma2:dict=4MiB,pb=1,lp=1" becomes
  * "--delta=dist=2 --lzma2=dict=4MiB,pb=1,lp=1".
  *
  * This syntax is compatible with xz 5.0.0 as long as the filters and
  * their options are supported too.
  */
 #define LZMA_STR_GETOPT_LONG    UINT32_C(0x40)
 
 
 /**
  * \brief       Use two dashes "--" instead of a space to separate filters
  *
  * That is, "delta:dist=2 lzma2:pb=1,lp=1" becomes
  * "delta:dist=2--lzma2:pb=1,lp=1". This looks slightly odd but this
  * kind of strings should be usable on the command line without quoting.
  * However, it is possible that future versions with new filter options
  * might produce strings that require shell quoting anyway as the exact
  * set of possible characters isn't frozen for now.
  *
  * It is guaranteed that the single quote (') will never be used in
  * filter chain strings (even if LZMA_STR_NO_SPACES isn't used).
  */
 #define LZMA_STR_NO_SPACES      UINT32_C(0x80)
 
 
 /**
  * \brief       Convert a string to a filter chain
  *
  * This tries to make it easier to write applications that allow users
  * to set custom compression options. This only handles the filter
  * configuration (including presets) but not the number of threads,
  * block size, check type, or memory limits.
  *
  * The input string can be either a preset or a filter chain. Presets
  * begin with a digit 0-9 and may be followed by zero or more flags
  * which are lower-case letters. Currently only "e" is supported, matching
  * LZMA_PRESET_EXTREME. For partial xz command line syntax compatibility,
  * a preset string may start with a single dash "-".
  *
  * A filter chain consists of one or more "filtername:opt1=value1,opt2=value2"
  * strings separated by one or more spaces. Leading and trailing spaces are
  * ignored. All names and values must be lower-case. Extra commas in the
  * option list are ignored. The order of filters is significant: when
  * encoding, the uncompressed input data goes to the leftmost filter first.
  * Normally "lzma2" is the last filter in the chain.
  *
  * If one wishes to avoid spaces, for example, to avoid shell quoting,
  * it is possible to use two dashes "--" instead of spaces to separate
  * the filters.
  *
  * For xz command line compatibility, each filter may be prefixed with
  * two dashes "--" and the colon ":" separating the filter name from
  * the options may be replaced with an equals sign "=".
  *
  * By default, only filters that can be used in the .xz format are accepted.
  * To allow all filters (LZMA1) use the flag LZMA_STR_ALL_FILTERS.
  *
  * By default, very basic validation is done for the filter chain as a whole,
  * for example, that LZMA2 is only used as the last filter in the chain.
  * The validation isn't perfect though and it's possible that this function
  * succeeds but using the filter chain for encoding or decoding will still
  * result in LZMA_OPTIONS_ERROR. To disable this validation, use the flag
  * LZMA_STR_NO_VALIDATION.
  *
  * The available filter names and their options are available via
  * lzma_str_list_filters(). See the xz man page for the description
  * of filter names and options.
  *
  * For command line applications, below is an example how an error message
  * can be displayed. Note the use of an empty string for the field width.
  * If "^" was used there it would create an off-by-one error except at
  * the very beginning of the line.
  *
  * \code{.c}
  * const char *str = ...; // From user
  * lzma_filter filters[LZMA_FILTERS_MAX + 1];
  * int pos;
  * const char *msg = lzma_str_to_filters(str, &pos, filters, 0, NULL);
  * if (msg != NULL) {
  *     printf("%s: Error in XZ compression options:\n", argv[0]);
  *     printf("%s: %s\n", argv[0], str);
  *     printf("%s: %*s^\n", argv[0], errpos, "");
  *     printf("%s: %s\n", argv[0], msg);
  * }
  * \endcode
  *
  * \param       str         User-supplied string describing a preset or
  *                          a filter chain. If a default value is needed and
  *                          you don't know what would be good, use "6" since
  *                          that is the default preset in xz too.
  * \param[out]  error_pos   If this isn't NULL, this value will be set on
  *                          both success and on all errors. This tells the
  *                          location of the error in the string. This is
  *                          an int to make it straightforward to use this
  *                          as printf() field width. The value is guaranteed
  *                          to be in the range [0, INT_MAX] even if strlen(str)
  *                          somehow was greater than INT_MAX.
  * \param[out]  filters     An array of lzma_filter structures. There must
  *                          be LZMA_FILTERS_MAX + 1 (that is, five) elements
  *                          in the array. The old contents are ignored so it
  *                          doesn't need to be initialized. This array is
  *                          modified only if this function returns NULL.
  *                          Once the allocated filter options are no longer
  *                          needed, lzma_filters_free() can be used to free the
  *                          options (it doesn't free the filters array itself).
  * \param       flags       Bitwise-or of zero or more of the flags
  *                          LZMA_STR_ALL_FILTERS and LZMA_STR_NO_VALIDATION.
  * \param       allocator   lzma_allocator for custom allocator functions.
  *                          Set to NULL to use malloc() and free().
  *
  * \return      On success, NULL is returned. On error, a statically-allocated
  *              error message is returned which together with the error_pos
  *              should give some idea what is wrong.
  */
 extern LZMA_API(const char *) lzma_str_to_filters(
 		const char *str, int *error_pos, lzma_filter *filters,
 		uint32_t flags, const lzma_allocator *allocator)
 		lzma_nothrow lzma_attr_warn_unused_result;
 
 
 /**
  * \brief       Convert a filter chain to a string
  *
  * Use cases:
  *
  *   - Verbose output showing the full encoder options to the user
  *     (use LZMA_STR_ENCODER in flags)
  *
  *   - Showing the filters and options that are required to decode a file
  *     (use LZMA_STR_DECODER in flags)
  *
  *   - Showing the filter names without any options in informational messages
  *     where the technical details aren't important (no flags). In this case
  *     the .options in the filters array are ignored and may be NULL even if
  *     a filter has a mandatory options structure.
  *
  * Note that even if the filter chain was specified using a preset,
  * the resulting filter chain isn't reversed to a preset. So if you
  * specify "6" to lzma_str_to_filters() then lzma_str_from_filters()
  * will produce a string containing "lzma2".
  *
  * \param[out]  str         On success *str will be set to point to an
  *                          allocated string describing the given filter
  *                          chain. Old value is ignored. On error *str is
  *                          always set to NULL.
  * \param       filters     Array of filters terminated with
  *                          .id == LZMA_VLI_UNKNOWN.
  * \param       flags       Bitwise-or of zero or more of the flags
  *                          LZMA_STR_ENCODER, LZMA_STR_DECODER,
  *                          LZMA_STR_GETOPT_LONG, and LZMA_STR_NO_SPACES.
  * \param       allocator   lzma_allocator for custom allocator functions.
  *                          Set to NULL to use malloc() and free().
  *
  * \return      Possible lzma_ret values:
  *              - LZMA_OK
  *              - LZMA_OPTIONS_ERROR: Empty filter chain
  *                (filters[0].id == LZMA_VLI_UNKNOWN) or the filter chain
  *                includes a Filter ID that is not supported by this function.
  *              - LZMA_MEM_ERROR
  *              - LZMA_PROG_ERROR
  */
 extern LZMA_API(lzma_ret) lzma_str_from_filters(
 		char **str, const lzma_filter *filters, uint32_t flags,
 		const lzma_allocator *allocator)
 		lzma_nothrow lzma_attr_warn_unused_result;
 
 
 /**
  * \brief       List available filters and/or their options (for help message)
  *
  * If a filter_id is given then only one line is created which contains the
  * filter name. If LZMA_STR_ENCODER or LZMA_STR_DECODER is used then the
  * options read by the encoder or decoder are printed on the same line.
  *
  * If filter_id is LZMA_VLI_UNKNOWN then all supported .xz-compatible filters
  * are listed:
  *
  *   - If neither LZMA_STR_ENCODER nor LZMA_STR_DECODER is used then
  *     the supported filter names are listed on a single line separated
  *     by spaces.
  *
  *   - If LZMA_STR_ENCODER or LZMA_STR_DECODER is used then filters and
  *     the supported options are listed one filter per line. There won't
  *     be a newline after the last filter.
  *
  *   - If LZMA_STR_ALL_FILTERS is used then the list will include also
  *     those filters that cannot be used in the .xz format (LZMA1).
  *
  * \param       str         On success *str will be set to point to an
  *                          allocated string listing the filters and options.
  *                          Old value is ignored. On error *str is always set
  *                          to NULL.
  * \param       filter_id   Filter ID or LZMA_VLI_UNKNOWN.
  * \param       flags       Bitwise-or of zero or more of the flags
  *                          LZMA_STR_ALL_FILTERS, LZMA_STR_ENCODER,
  *                          LZMA_STR_DECODER, and LZMA_STR_GETOPT_LONG.
  * \param       allocator   lzma_allocator for custom allocator functions.
  *                          Set to NULL to use malloc() and free().
  *
  * \return      Possible lzma_ret values:
  *              - LZMA_OK
  *              - LZMA_OPTIONS_ERROR: Unsupported filter_id or flags
  *              - LZMA_MEM_ERROR
  *              - LZMA_PROG_ERROR
  */
 extern LZMA_API(lzma_ret) lzma_str_list_filters(
 		char **str, lzma_vli filter_id, uint32_t flags,
 		const lzma_allocator *allocator)
 		lzma_nothrow lzma_attr_warn_unused_result;
diff --git a/src/liblzma/api/lzma/index.h b/src/liblzma/api/lzma/index.h
index 46455b12..6fd2f618 100644
--- a/src/liblzma/api/lzma/index.h
+++ b/src/liblzma/api/lzma/index.h
@@ -1,883 +1,883 @@
 /**
  * \file        lzma/index.h
  * \brief       Handling of .xz Index and related information
  * \note        Never include this file directly. Use <lzma.h> instead.
  */
 
 /*
  * Author: Lasse Collin
  *
  * This file has been put into the public domain.
  * You can do whatever you want with this file.
  */
 
 #ifndef LZMA_H_INTERNAL
 #	error Never include this file directly. Use <lzma.h> instead.
 #endif
 
 
 /**
  * \brief       Opaque data type to hold the Index(es) and other information
  *
  * lzma_index often holds just one .xz Index and possibly the Stream Flags
  * of the same Stream and size of the Stream Padding field. However,
  * multiple lzma_indexes can be concatenated with lzma_index_cat() and then
  * there may be information about multiple Streams in the same lzma_index.
  *
  * Notes about thread safety: Only one thread may modify lzma_index at
  * a time. All functions that take non-const pointer to lzma_index
  * modify it. As long as no thread is modifying the lzma_index, getting
  * information from the same lzma_index can be done from multiple threads
  * at the same time with functions that take a const pointer to
  * lzma_index or use lzma_index_iter. The same iterator must be used
  * only by one thread at a time, of course, but there can be as many
  * iterators for the same lzma_index as needed.
  */
 typedef struct lzma_index_s lzma_index;
 
 
 /**
  * \brief       Iterator to get information about Blocks and Streams
  */
 typedef struct {
 	struct {
 		/**
 		 * \brief       Pointer to Stream Flags
 		 *
 		 * This is NULL if Stream Flags have not been set for
 		 * this Stream with lzma_index_stream_flags().
 		 */
 		const lzma_stream_flags *flags;
 
 		/** \private     Reserved member. */
 		const void *reserved_ptr1;
 
 		/** \private     Reserved member. */
 		const void *reserved_ptr2;
 
 		/** \private     Reserved member. */
 		const void *reserved_ptr3;
 
 		/**
 		 * \brief       Stream number in the lzma_index
 		 *
 		 * The first Stream is 1.
 		 */
 		lzma_vli number;
 
 		/**
 		 * \brief       Number of Blocks in the Stream
 		 *
 		 * If this is zero, the block structure below has
 		 * undefined values.
 		 */
 		lzma_vli block_count;
 
 		/**
 		 * \brief       Compressed start offset of this Stream
 		 *
 		 * The offset is relative to the beginning of the lzma_index
 		 * (i.e. usually the beginning of the .xz file).
 		 */
 		lzma_vli compressed_offset;
 
 		/**
 		 * \brief       Uncompressed start offset of this Stream
 		 *
 		 * The offset is relative to the beginning of the lzma_index
 		 * (i.e. usually the beginning of the .xz file).
 		 */
 		lzma_vli uncompressed_offset;
 
 		/**
 		 * \brief       Compressed size of this Stream
 		 *
 		 * This includes all headers except the possible
 		 * Stream Padding after this Stream.
 		 */
 		lzma_vli compressed_size;
 
 		/**
 		 * \brief       Uncompressed size of this Stream
 		 */
 		lzma_vli uncompressed_size;
 
 		/**
 		 * \brief       Size of Stream Padding after this Stream
 		 *
 		 * If it hasn't been set with lzma_index_stream_padding(),
 		 * this defaults to zero. Stream Padding is always
 		 * a multiple of four bytes.
 		 */
 		lzma_vli padding;
 
 
 		/** \private     Reserved member. */
 		lzma_vli reserved_vli1;
 
 		/** \private     Reserved member. */
 		lzma_vli reserved_vli2;
 
 		/** \private     Reserved member. */
 		lzma_vli reserved_vli3;
 
 		/** \private     Reserved member. */
 		lzma_vli reserved_vli4;
 	} stream;
 
 	struct {
 		/**
 		 * \brief       Block number in the file
 		 *
 		 * The first Block is 1.
 		 */
 		lzma_vli number_in_file;
 
 		/**
 		 * \brief       Compressed start offset of this Block
 		 *
 		 * This offset is relative to the beginning of the
 		 * lzma_index (i.e. usually the beginning of the .xz file).
 		 * Normally this is where you should seek in the .xz file
 		 * to start decompressing this Block.
 		 */
 		lzma_vli compressed_file_offset;
 
 		/**
 		 * \brief       Uncompressed start offset of this Block
 		 *
 		 * This offset is relative to the beginning of the lzma_index
 		 * (i.e. usually the beginning of the .xz file).
 		 *
 		 * When doing random-access reading, it is possible that
 		 * the target offset is not exactly at Block boundary. One
 		 * will need to compare the target offset against
 		 * uncompressed_file_offset or uncompressed_stream_offset,
 		 * and possibly decode and throw away some amount of data
 		 * before reaching the target offset.
 		 */
 		lzma_vli uncompressed_file_offset;
 
 		/**
 		 * \brief       Block number in this Stream
 		 *
 		 * The first Block is 1.
 		 */
 		lzma_vli number_in_stream;
 
 		/**
 		 * \brief       Compressed start offset of this Block
 		 *
 		 * This offset is relative to the beginning of the Stream
 		 * containing this Block.
 		 */
 		lzma_vli compressed_stream_offset;
 
 		/**
 		 * \brief       Uncompressed start offset of this Block
 		 *
 		 * This offset is relative to the beginning of the Stream
 		 * containing this Block.
 		 */
 		lzma_vli uncompressed_stream_offset;
 
 		/**
 		 * \brief       Uncompressed size of this Block
 		 *
 		 * You should pass this to the Block decoder if you will
 		 * decode this Block. It will allow the Block decoder to
 		 * validate the uncompressed size.
 		 */
 		lzma_vli uncompressed_size;
 
 		/**
 		 * \brief       Unpadded size of this Block
 		 *
 		 * You should pass this to the Block decoder if you will
 		 * decode this Block. It will allow the Block decoder to
 		 * validate the unpadded size.
 		 */
 		lzma_vli unpadded_size;
 
 		/**
 		 * \brief       Total compressed size
 		 *
 		 * This includes all headers and padding in this Block.
 		 * This is useful if you need to know how many bytes
 		 * the Block decoder will actually read.
 		 */
 		lzma_vli total_size;
 
 		/** \private     Reserved member. */
 		lzma_vli reserved_vli1;
 
 		/** \private     Reserved member. */
 		lzma_vli reserved_vli2;
 
 		/** \private     Reserved member. */
 		lzma_vli reserved_vli3;
 
 		/** \private     Reserved member. */
 		lzma_vli reserved_vli4;
 
 		/** \private     Reserved member. */
 		const void *reserved_ptr1;
 
 		/** \private     Reserved member. */
 		const void *reserved_ptr2;
 
 		/** \private     Reserved member. */
 		const void *reserved_ptr3;
 
 		/** \private     Reserved member. */
 		const void *reserved_ptr4;
 	} block;
 
 	/**
 	 * \private     Internal struct.
 	 *
 	 * Internal data which is used to store the state of the iterator.
 	 * The exact format may vary between liblzma versions, so don't
 	 * touch these in any way.
 	 */
 	union {
 		/** \private     Internal member. */
 		const void *p;
 
 		/** \private     Internal member. */
 		size_t s;
 
 		/** \private     Internal member. */
 		lzma_vli v;
 	} internal[6];
 } lzma_index_iter;
 
 
 /**
  * \brief       Operation mode for lzma_index_iter_next()
  */
 typedef enum {
 	LZMA_INDEX_ITER_ANY             = 0,
 		/**<
 		 * \brief       Get the next Block or Stream
 		 *
 		 * Go to the next Block if the current Stream has at least
 		 * one Block left. Otherwise go to the next Stream even if
 		 * it has no Blocks. If the Stream has no Blocks
 		 * (lzma_index_iter.stream.block_count == 0),
 		 * lzma_index_iter.block will have undefined values.
 		 */
 
 	LZMA_INDEX_ITER_STREAM          = 1,
 		/**<
 		 * \brief       Get the next Stream
 		 *
 		 * Go to the next Stream even if the current Stream has
 		 * unread Blocks left. If the next Stream has at least one
 		 * Block, the iterator will point to the first Block.
 		 * If there are no Blocks, lzma_index_iter.block will have
 		 * undefined values.
 		 */
 
 	LZMA_INDEX_ITER_BLOCK           = 2,
 		/**<
 		 * \brief       Get the next Block
 		 *
 		 * Go to the next Block if the current Stream has at least
 		 * one Block left. If the current Stream has no Blocks left,
 		 * the next Stream with at least one Block is located and
 		 * the iterator will be made to point to the first Block of
 		 * that Stream.
 		 */
 
 	LZMA_INDEX_ITER_NONEMPTY_BLOCK  = 3
 		/**<
 		 * \brief       Get the next non-empty Block
 		 *
 		 * This is like LZMA_INDEX_ITER_BLOCK except that it will
 		 * skip Blocks whose Uncompressed Size is zero.
 		 */
 
 } lzma_index_iter_mode;
 
 
 /**
  * \brief       Mask for return value from lzma_index_checks() for check none
  *
  * \note        This and the other CHECK_MASK macros were added in 5.5.1alpha.
  */
 #define LZMA_INDEX_CHECK_MASK_NONE (UINT32_C(1) << LZMA_CHECK_NONE)
 
 /**
  * \brief       Mask for return value from lzma_index_checks() for check CRC32
  */
 #define LZMA_INDEX_CHECK_MASK_CRC32 (UINT32_C(1) << LZMA_CHECK_CRC32)
 
 /**
  * \brief       Mask for return value from lzma_index_checks() for check CRC64
  */
 #define LZMA_INDEX_CHECK_MASK_CRC64 (UINT32_C(1) << LZMA_CHECK_CRC64)
 
 /**
  * \brief       Mask for return value from lzma_index_checks() for check SHA256
  */
 #define LZMA_INDEX_CHECK_MASK_SHA256 (UINT32_C(1) << LZMA_CHECK_SHA256)
 
 /**
  * \brief       Calculate memory usage of lzma_index
  *
  * On disk, the size of the Index field depends on both the number of Records
  * stored and the size of the Records (due to variable-length integer
  * encoding). When the Index is kept in lzma_index structure, the memory usage
  * depends only on the number of Records/Blocks stored in the Index(es), and
  * in case of concatenated lzma_indexes, the number of Streams. The size in
  * RAM is almost always significantly bigger than in the encoded form on disk.
  *
  * This function calculates an approximate amount of memory needed to hold
  * the given number of Streams and Blocks in lzma_index structure. This
  * value may vary between CPU architectures and also between liblzma versions
  * if the internal implementation is modified.
  *
  * \param       streams Number of Streams
  * \param       blocks  Number of Blocks
  *
  * \return      Approximate memory in bytes needed in a lzma_index structure.
  */
 extern LZMA_API(uint64_t) lzma_index_memusage(
 		lzma_vli streams, lzma_vli blocks) lzma_nothrow;
 
 
 /**
  * \brief       Calculate the memory usage of an existing lzma_index
  *
  * This is a shorthand for lzma_index_memusage(lzma_index_stream_count(i),
  * lzma_index_block_count(i)).
  *
  * \param       i   Pointer to lzma_index structure
  *
  * \return      Approximate memory in bytes used by the lzma_index structure.
  */
 extern LZMA_API(uint64_t) lzma_index_memused(const lzma_index *i)
 		lzma_nothrow;
 
 
 /**
  * \brief       Allocate and initialize a new lzma_index structure
  *
  * \param       allocator   lzma_allocator for custom allocator functions.
  *                          Set to NULL to use malloc() and free().
  *
  * \return      On success, a pointer to an empty initialized lzma_index is
  *              returned. If allocation fails, NULL is returned.
  */
 extern LZMA_API(lzma_index *) lzma_index_init(const lzma_allocator *allocator)
 		lzma_nothrow;
 
 
 /**
  * \brief       Deallocate lzma_index
  *
  * If i is NULL, this does nothing.
  *
  * \param       i           Pointer to lzma_index structure to deallocate
  * \param       allocator   lzma_allocator for custom allocator functions.
  *                          Set to NULL to use malloc() and free().
  */
 extern LZMA_API(void) lzma_index_end(
 		lzma_index *i, const lzma_allocator *allocator) lzma_nothrow;
 
 
 /**
  * \brief       Add a new Block to lzma_index
  *
  * \param       i                 Pointer to a lzma_index structure
  * \param       allocator         lzma_allocator for custom allocator
  *                                functions. Set to NULL to use malloc()
  *                                and free().
  * \param       unpadded_size     Unpadded Size of a Block. This can be
  *                                calculated with lzma_block_unpadded_size()
  *                                after encoding or decoding the Block.
  * \param       uncompressed_size Uncompressed Size of a Block. This can be
  *                                taken directly from lzma_block structure
  *                                after encoding or decoding the Block.
  *
  * Appending a new Block does not invalidate iterators. For example,
  * if an iterator was pointing to the end of the lzma_index, after
  * lzma_index_append() it is possible to read the next Block with
  * an existing iterator.
  *
  * \return      Possible lzma_ret values:
  *              - LZMA_OK
  *              - LZMA_MEM_ERROR
  *              - LZMA_DATA_ERROR: Compressed or uncompressed size of the
  *                Stream or size of the Index field would grow too big.
  *              - LZMA_PROG_ERROR
  */
 extern LZMA_API(lzma_ret) lzma_index_append(
 		lzma_index *i, const lzma_allocator *allocator,
 		lzma_vli unpadded_size, lzma_vli uncompressed_size)
 		lzma_nothrow lzma_attr_warn_unused_result;
 
 
 /**
  * \brief       Set the Stream Flags
  *
  * Set the Stream Flags of the last (and typically the only) Stream
  * in lzma_index. This can be useful when reading information from the
  * lzma_index, because to decode Blocks, knowing the integrity check type
  * is needed.
  *
  * \param       i              Pointer to lzma_index structure
  * \param       stream_flags   Pointer to lzma_stream_flags structure. This
  *                             is copied into the internal preallocated
  *                             structure, so the caller doesn't need to keep
  *                             the flags' data available after calling this
  *                             function.
  *
  * \return      Possible lzma_ret values:
  *              - LZMA_OK
  *              - LZMA_OPTIONS_ERROR: Unsupported stream_flags->version.
  *              - LZMA_PROG_ERROR
  */
 extern LZMA_API(lzma_ret) lzma_index_stream_flags(
 		lzma_index *i, const lzma_stream_flags *stream_flags)
 		lzma_nothrow lzma_attr_warn_unused_result;
 
 
 /**
  * \brief       Get the types of integrity Checks
  *
  * If lzma_index_stream_flags() is used to set the Stream Flags for
  * every Stream, lzma_index_checks() can be used to get a bitmask to
  * indicate which Check types have been used. It can be useful e.g. if
  * showing the Check types to the user.
  *
  * The bitmask is 1 << check_id, e.g. CRC32 is 1 << 1 and SHA-256 is 1 << 10.
  * These masks are defined for convenience as LZMA_INDEX_CHECK_MASK_XXX
  *
  * \param       i   Pointer to lzma_index structure
  *
  * \return      Bitmask indicating which Check types are used in the lzma_index
  */
 extern LZMA_API(uint32_t) lzma_index_checks(const lzma_index *i)
 		lzma_nothrow lzma_attr_pure;
 
 
 /**
  * \brief       Set the amount of Stream Padding
  *
  * Set the amount of Stream Padding of the last (and typically the only)
  * Stream in the lzma_index. This is needed when planning to do random-access
  * reading within multiple concatenated Streams.
  *
  * By default, the amount of Stream Padding is assumed to be zero bytes.
  *
  * \return      Possible lzma_ret values:
  *              - LZMA_OK
  *              - LZMA_DATA_ERROR: The file size would grow too big.
  *              - LZMA_PROG_ERROR
  */
 extern LZMA_API(lzma_ret) lzma_index_stream_padding(
 		lzma_index *i, lzma_vli stream_padding)
 		lzma_nothrow lzma_attr_warn_unused_result;
 
 
 /**
  * \brief       Get the number of Streams
  *
  * \param       i   Pointer to lzma_index structure
  *
  * \return      Number of Streams in the lzma_index
  */
 extern LZMA_API(lzma_vli) lzma_index_stream_count(const lzma_index *i)
 		lzma_nothrow lzma_attr_pure;
 
 
 /**
  * \brief       Get the number of Blocks
  *
  * This returns the total number of Blocks in lzma_index. To get number
  * of Blocks in individual Streams, use lzma_index_iter.
  *
  * \param       i   Pointer to lzma_index structure
  *
  * \return      Number of blocks in the lzma_index
  */
 extern LZMA_API(lzma_vli) lzma_index_block_count(const lzma_index *i)
 		lzma_nothrow lzma_attr_pure;
 
 
 /**
  * \brief       Get the size of the Index field as bytes
  *
  * This is needed to verify the Backward Size field in the Stream Footer.
  *
  * \param       i   Pointer to lzma_index structure
  *
  * \return      Size in bytes of the Index
  */
 extern LZMA_API(lzma_vli) lzma_index_size(const lzma_index *i)
 		lzma_nothrow lzma_attr_pure;
 
 
 /**
  * \brief       Get the total size of the Stream
  *
  * If multiple lzma_indexes have been combined, this works as if the Blocks
  * were in a single Stream. This is useful if you are going to combine
  * Blocks from multiple Streams into a single new Stream.
  *
  * \param       i   Pointer to lzma_index structure
  *
  * \return      Size in bytes of the Stream (if all Blocks are combined
  *              into one Stream).
  */
 extern LZMA_API(lzma_vli) lzma_index_stream_size(const lzma_index *i)
 		lzma_nothrow lzma_attr_pure;
 
 
 /**
  * \brief       Get the total size of the Blocks
  *
  * This doesn't include the Stream Header, Stream Footer, Stream Padding,
  * or Index fields.
  *
  * \param       i   Pointer to lzma_index structure
  *
  * \return      Size in bytes of all Blocks in the Stream(s)
  */
 extern LZMA_API(lzma_vli) lzma_index_total_size(const lzma_index *i)
 		lzma_nothrow lzma_attr_pure;
 
 
 /**
  * \brief       Get the total size of the file
  *
  * When no lzma_indexes have been combined with lzma_index_cat() and there is
  * no Stream Padding, this function is identical to lzma_index_stream_size().
  * If multiple lzma_indexes have been combined, this includes also the headers
  * of each separate Stream and the possible Stream Padding fields.
  *
  * \param       i   Pointer to lzma_index structure
  *
  * \return      Total size of the .xz file in bytes
  */
 extern LZMA_API(lzma_vli) lzma_index_file_size(const lzma_index *i)
 		lzma_nothrow lzma_attr_pure;
 
 
 /**
  * \brief       Get the uncompressed size of the file
  *
  * \param       i   Pointer to lzma_index structure
  *
  * \return      Size in bytes of the uncompressed data in the file
  */
 extern LZMA_API(lzma_vli) lzma_index_uncompressed_size(const lzma_index *i)
 		lzma_nothrow lzma_attr_pure;
 
 
 /**
  * \brief       Initialize an iterator
  *
  * This function associates the iterator with the given lzma_index, and calls
  * lzma_index_iter_rewind() on the iterator.
  *
  * This function doesn't allocate any memory, thus there is no
  * lzma_index_iter_end(). The iterator is valid as long as the
  * associated lzma_index is valid, that is, until lzma_index_end() or
  * using it as source in lzma_index_cat(). Specifically, lzma_index doesn't
  * become invalid if new Blocks are added to it with lzma_index_append() or
  * if it is used as the destination in lzma_index_cat().
  *
  * It is safe to make copies of an initialized lzma_index_iter, for example,
  * to easily restart reading at some particular position.
  *
  * \param       iter    Pointer to a lzma_index_iter structure
  * \param       i       lzma_index to which the iterator will be associated
  */
 extern LZMA_API(void) lzma_index_iter_init(
 		lzma_index_iter *iter, const lzma_index *i) lzma_nothrow;
 
 
 /**
  * \brief       Rewind the iterator
  *
  * Rewind the iterator so that next call to lzma_index_iter_next() will
  * return the first Block or Stream.
  *
  * \param       iter    Pointer to a lzma_index_iter structure
  */
 extern LZMA_API(void) lzma_index_iter_rewind(lzma_index_iter *iter)
 		lzma_nothrow;
 
 
 /**
  * \brief       Get the next Block or Stream
  *
  * \param       iter    Iterator initialized with lzma_index_iter_init()
  * \param       mode    Specify what kind of information the caller wants
  *                      to get. See lzma_index_iter_mode for details.
  *
  * \return      lzma_bool:
  *              - true if no Block or Stream matching the mode is found.
  *                *iter is not updated (failure).
  *              - false if the next Block or Stream matching the mode was
  *                found. *iter is updated (success).
  */
 extern LZMA_API(lzma_bool) lzma_index_iter_next(
 		lzma_index_iter *iter, lzma_index_iter_mode mode)
 		lzma_nothrow lzma_attr_warn_unused_result;
 
 
 /**
  * \brief       Locate a Block
  *
  * If it is possible to seek in the .xz file, it is possible to parse
  * the Index field(s) and use lzma_index_iter_locate() to do random-access
  * reading with granularity of Block size.
  *
  * If the target is smaller than the uncompressed size of the Stream (can be
  * checked with lzma_index_uncompressed_size()):
  *  - Information about the Stream and Block containing the requested
  *    uncompressed offset is stored into *iter.
  *  - Internal state of the iterator is adjusted so that
  *    lzma_index_iter_next() can be used to read subsequent Blocks or Streams.
  *
  * If the target is greater than the uncompressed size of the Stream, *iter
  * is not modified.
  *
  * \param       iter    Iterator that was earlier initialized with
  *                      lzma_index_iter_init().
  * \param       target  Uncompressed target offset which the caller would
  *                      like to locate from the Stream
  *
  * \return      lzma_bool:
  *              - true if the target is greater than or equal to the
  *                uncompressed size of the Stream (failure)
  *              - false if the target is smaller than the uncompressed size
  *                of the Stream (success)
  */
 extern LZMA_API(lzma_bool) lzma_index_iter_locate(
 		lzma_index_iter *iter, lzma_vli target) lzma_nothrow;
 
 
 /**
  * \brief       Concatenate lzma_indexes
  *
  * Concatenating lzma_indexes is useful when doing random-access reading in
  * multi-Stream .xz file, or when combining multiple Streams into single
  * Stream.
  *
  * \param[out]  dest      lzma_index after which src is appended
  * \param       src       lzma_index to be appended after dest. If this
  *                        function succeeds, the memory allocated for src
  *                        is freed or moved to be part of dest, and all
  *                        iterators pointing to src will become invalid.
 * \param       allocator  lzma_allocator for custom allocator functions.
  *                        Set to NULL to use malloc() and free().
  *
  * \return      Possible lzma_ret values:
  *              - LZMA_OK: lzma_indexes were concatenated successfully.
  *                src is now a dangling pointer.
  *              - LZMA_DATA_ERROR: *dest would grow too big.
  *              - LZMA_MEM_ERROR
  *              - LZMA_PROG_ERROR
  */
 extern LZMA_API(lzma_ret) lzma_index_cat(lzma_index *dest, lzma_index *src,
 		const lzma_allocator *allocator)
 		lzma_nothrow lzma_attr_warn_unused_result;
 
 
 /**
  * \brief       Duplicate lzma_index
  *
  * \param       i         Pointer to lzma_index structure to be duplicated
  * \param       allocator lzma_allocator for custom allocator functions.
  *                        Set to NULL to use malloc() and free().
  *
  * \return      A copy of the lzma_index, or NULL if memory allocation failed.
  */
 extern LZMA_API(lzma_index *) lzma_index_dup(
 		const lzma_index *i, const lzma_allocator *allocator)
 		lzma_nothrow lzma_attr_warn_unused_result;
 
 
 /**
  * \brief       Initialize .xz Index encoder
  *
  * \param       strm        Pointer to properly prepared lzma_stream
  * \param       i           Pointer to lzma_index which should be encoded.
  *
- * The valid `action' values for lzma_code() are LZMA_RUN and LZMA_FINISH.
+ * The valid 'action' values for lzma_code() are LZMA_RUN and LZMA_FINISH.
  * It is enough to use only one of them (you can choose freely).
  *
  * \return      Possible lzma_ret values:
  *              - LZMA_OK: Initialization succeeded, continue with lzma_code().
  *              - LZMA_MEM_ERROR
  *              - LZMA_PROG_ERROR
  */
 extern LZMA_API(lzma_ret) lzma_index_encoder(
 		lzma_stream *strm, const lzma_index *i)
 		lzma_nothrow lzma_attr_warn_unused_result;
 
 
 /**
  * \brief       Initialize .xz Index decoder
  *
  * \param       strm        Pointer to properly prepared lzma_stream
  * \param[out]  i           The decoded Index will be made available via
  *                          this pointer. Initially this function will
  *                          set *i to NULL (the old value is ignored). If
  *                          decoding succeeds (lzma_code() returns
  *                          LZMA_STREAM_END), *i will be set to point
  *                          to a new lzma_index, which the application
  *                          has to later free with lzma_index_end().
  * \param       memlimit    How much memory the resulting lzma_index is
  *                          allowed to require. liblzma 5.2.3 and earlier
  *                          don't allow 0 here and return LZMA_PROG_ERROR;
  *                          later versions treat 0 as if 1 had been specified.
  *
- * Valid `action' arguments to lzma_code() are LZMA_RUN and LZMA_FINISH.
+ * Valid 'action' arguments to lzma_code() are LZMA_RUN and LZMA_FINISH.
  * There is no need to use LZMA_FINISH, but it's allowed because it may
  * simplify certain types of applications.
  *
  * \return      Possible lzma_ret values:
  *              - LZMA_OK: Initialization succeeded, continue with lzma_code().
  *              - LZMA_MEM_ERROR
  *              - LZMA_PROG_ERROR
  *
  * \note        liblzma 5.2.3 and older list also LZMA_MEMLIMIT_ERROR here
  *              but that error code has never been possible from this
  *              initialization function.
  */
 extern LZMA_API(lzma_ret) lzma_index_decoder(
 		lzma_stream *strm, lzma_index **i, uint64_t memlimit)
 		lzma_nothrow lzma_attr_warn_unused_result;
 
 
 /**
  * \brief       Single-call .xz Index encoder
  *
  * \note        This function doesn't take allocator argument since all
  *              the internal data is allocated on stack.
  *
  * \param       i         lzma_index to be encoded
  * \param[out]  out       Beginning of the output buffer
  * \param[out]  out_pos   The next byte will be written to out[*out_pos].
  *                        *out_pos is updated only if encoding succeeds.
  * \param       out_size  Size of the out buffer; the first byte into
  *                        which no data is written to is out[out_size].
  *
  * \return      Possible lzma_ret values:
  *              - LZMA_OK: Encoding was successful.
  *              - LZMA_BUF_ERROR: Output buffer is too small. Use
  *                lzma_index_size() to find out how much output
  *                space is needed.
  *              - LZMA_PROG_ERROR
  *
  */
 extern LZMA_API(lzma_ret) lzma_index_buffer_encode(const lzma_index *i,
 		uint8_t *out, size_t *out_pos, size_t out_size) lzma_nothrow;
 
 
 /**
  * \brief       Single-call .xz Index decoder
  *
  * \param[out]  i           If decoding succeeds, *i will point to a new
  *                          lzma_index, which the application has to
  *                          later free with lzma_index_end(). If an error
  *                          occurs, *i will be NULL. The old value of *i
  *                          is always ignored and thus doesn't need to be
  *                          initialized by the caller.
  * \param[out]  memlimit    Pointer to how much memory the resulting
  *                          lzma_index is allowed to require. The value
  *                          pointed by this pointer is modified if and only
  *                          if LZMA_MEMLIMIT_ERROR is returned.
   * \param      allocator   lzma_allocator for custom allocator functions.
  *                          Set to NULL to use malloc() and free().
  * \param       in          Beginning of the input buffer
  * \param       in_pos      The next byte will be read from in[*in_pos].
  *                          *in_pos is updated only if decoding succeeds.
  * \param       in_size     Size of the input buffer; the first byte that
  *                          won't be read is in[in_size].
  *
  * \return      Possible lzma_ret values:
  *              - LZMA_OK: Decoding was successful.
  *              - LZMA_MEM_ERROR
  *              - LZMA_MEMLIMIT_ERROR: Memory usage limit was reached.
  *                The minimum required memlimit value was stored to *memlimit.
  *              - LZMA_DATA_ERROR
  *              - LZMA_PROG_ERROR
  */
 extern LZMA_API(lzma_ret) lzma_index_buffer_decode(lzma_index **i,
 		uint64_t *memlimit, const lzma_allocator *allocator,
 		const uint8_t *in, size_t *in_pos, size_t in_size)
 		lzma_nothrow;
 
 
 /**
  * \brief       Initialize a .xz file information decoder
  *
  * This decoder decodes the Stream Header, Stream Footer, Index, and
  * Stream Padding field(s) from the input .xz file and stores the resulting
  * combined index in *dest_index. This information can be used to get the
  * uncompressed file size with lzma_index_uncompressed_size(*dest_index) or,
  * for example, to implement random access reading by locating the Blocks
  * in the Streams.
  *
  * To get the required information from the .xz file, lzma_code() may ask
  * the application to seek in the input file by returning LZMA_SEEK_NEEDED
  * and having the target file position specified in lzma_stream.seek_pos.
  * The number of seeks required depends on the input file and how big buffers
  * the application provides. When possible, the decoder will seek backward
  * and forward in the given buffer to avoid useless seek requests. Thus, if
  * the application provides the whole file at once, no external seeking will
  * be required (that is, lzma_code() won't return LZMA_SEEK_NEEDED).
  *
  * The value in lzma_stream.total_in can be used to estimate how much data
  * liblzma had to read to get the file information. However, due to seeking
  * and the way total_in is updated, the value of total_in will be somewhat
  * inaccurate (a little too big). Thus, total_in is a good estimate but don't
  * expect to see the same exact value for the same file if you change the
  * input buffer size or switch to a different liblzma version.
  *
- * Valid `action' arguments to lzma_code() are LZMA_RUN and LZMA_FINISH.
+ * Valid 'action' arguments to lzma_code() are LZMA_RUN and LZMA_FINISH.
  * You only need to use LZMA_RUN; LZMA_FINISH is only supported because it
  * might be convenient for some applications. If you use LZMA_FINISH and if
- * lzma_code() asks the application to seek, remember to reset `action' back
+ * lzma_code() asks the application to seek, remember to reset 'action' back
  * to LZMA_RUN unless you hit the end of the file again.
  *
  * Possible return values from lzma_code():
  *   - LZMA_OK: All OK so far, more input needed
  *   - LZMA_SEEK_NEEDED: Provide more input starting from the absolute
  *     file position strm->seek_pos
  *   - LZMA_STREAM_END: Decoding was successful, *dest_index has been set
  *   - LZMA_FORMAT_ERROR: The input file is not in the .xz format (the
  *     expected magic bytes were not found from the beginning of the file)
  *   - LZMA_OPTIONS_ERROR: File looks valid but contains headers that aren't
  *     supported by this version of liblzma
  *   - LZMA_DATA_ERROR: File is corrupt
  *   - LZMA_BUF_ERROR
  *   - LZMA_MEM_ERROR
  *   - LZMA_MEMLIMIT_ERROR
  *   - LZMA_PROG_ERROR
  *
  * \param       strm        Pointer to a properly prepared lzma_stream
  * \param[out]  dest_index  Pointer to a pointer where the decoder will put
  *                          the decoded lzma_index. The old value
  *                          of *dest_index is ignored (not freed).
  * \param       memlimit    How much memory the resulting lzma_index is
  *                          allowed to require. Use UINT64_MAX to
  *                          effectively disable the limiter.
  * \param       file_size   Size of the input .xz file
  *
  * \return      Possible lzma_ret values:
  *              - LZMA_OK
  *              - LZMA_MEM_ERROR
  *              - LZMA_PROG_ERROR
  */
 extern LZMA_API(lzma_ret) lzma_file_info_decoder(
 		lzma_stream *strm, lzma_index **dest_index,
 		uint64_t memlimit, uint64_t file_size)
 		lzma_nothrow;
diff --git a/src/liblzma/api/lzma/lzma12.h b/src/liblzma/api/lzma/lzma12.h
index 8ef6ea5b..772c3e29 100644
--- a/src/liblzma/api/lzma/lzma12.h
+++ b/src/liblzma/api/lzma/lzma12.h
@@ -1,569 +1,569 @@
 /**
  * \file        lzma/lzma12.h
  * \brief       LZMA1 and LZMA2 filters
  * \note        Never include this file directly. Use <lzma.h> instead.
  */
 
 /*
  * Author: Lasse Collin
  *
  * This file has been put into the public domain.
  * You can do whatever you want with this file.
  */
 
 #ifndef LZMA_H_INTERNAL
 #	error Never include this file directly. Use <lzma.h> instead.
 #endif
 
 
 /**
  * \brief       LZMA1 Filter ID (for raw encoder/decoder only, not in .xz)
  *
  * LZMA1 is the very same thing as what was called just LZMA in LZMA Utils,
  * 7-Zip, and LZMA SDK. It's called LZMA1 here to prevent developers from
  * accidentally using LZMA when they actually want LZMA2.
  */
 #define LZMA_FILTER_LZMA1       LZMA_VLI_C(0x4000000000000001)
 
 /**
  * \brief       LZMA1 Filter ID with extended options (for raw encoder/decoder)
  *
  * This is like LZMA_FILTER_LZMA1 but with this ID a few extra options
  * are supported in the lzma_options_lzma structure:
  *
  *   - A flag to tell the encoder if the end of payload marker (EOPM) alias
  *     end of stream (EOS) marker must be written at the end of the stream.
  *     In contrast, LZMA_FILTER_LZMA1 always writes the end marker.
  *
  *   - Decoder needs to be told the uncompressed size of the stream
  *     or that it is unknown (using the special value UINT64_MAX).
  *     If the size is known, a flag can be set to allow the presence of
  *     the end marker anyway. In contrast, LZMA_FILTER_LZMA1 always
  *     behaves as if the uncompressed size was unknown.
  *
  * This allows handling file formats where LZMA1 streams are used but where
  * the end marker isn't allowed or where it might not (always) be present.
  * This extended LZMA1 functionality is provided as a Filter ID for raw
  * encoder and decoder instead of adding new encoder and decoder initialization
  * functions because this way it is possible to also use extra filters,
  * for example, LZMA_FILTER_X86 in a filter chain with LZMA_FILTER_LZMA1EXT,
  * which might be needed to handle some file formats.
  */
 #define LZMA_FILTER_LZMA1EXT    LZMA_VLI_C(0x4000000000000002)
 
 /**
  * \brief       LZMA2 Filter ID
  *
  * Usually you want this instead of LZMA1. Compared to LZMA1, LZMA2 adds
  * support for LZMA_SYNC_FLUSH, uncompressed chunks (smaller expansion
  * when trying to compress incompressible data), possibility to change
  * lc/lp/pb in the middle of encoding, and some other internal improvements.
  */
 #define LZMA_FILTER_LZMA2       LZMA_VLI_C(0x21)
 
 
 /**
  * \brief       Match finders
  *
  * Match finder has major effect on both speed and compression ratio.
  * Usually hash chains are faster than binary trees.
  *
  * If you will use LZMA_SYNC_FLUSH often, the hash chains may be a better
  * choice, because binary trees get much higher compression ratio penalty
  * with LZMA_SYNC_FLUSH.
  *
  * The memory usage formulas are only rough estimates, which are closest to
  * reality when dict_size is a power of two. The formulas are  more complex
  * in reality, and can also change a little between liblzma versions. Use
  * lzma_raw_encoder_memusage() to get more accurate estimate of memory usage.
  */
 typedef enum {
 	LZMA_MF_HC3     = 0x03,
 		/**<
 		 * \brief       Hash Chain with 2- and 3-byte hashing
 		 *
 		 * Minimum nice_len: 3
 		 *
 		 * Memory usage:
 		 *  - dict_size <= 16 MiB: dict_size * 7.5
 		 *  - dict_size > 16 MiB: dict_size * 5.5 + 64 MiB
 		 */
 
 	LZMA_MF_HC4     = 0x04,
 		/**<
 		 * \brief       Hash Chain with 2-, 3-, and 4-byte hashing
 		 *
 		 * Minimum nice_len: 4
 		 *
 		 * Memory usage:
 		 *  - dict_size <= 32 MiB: dict_size * 7.5
 		 *  - dict_size > 32 MiB: dict_size * 6.5
 		 */
 
 	LZMA_MF_BT2     = 0x12,
 		/**<
 		 * \brief       Binary Tree with 2-byte hashing
 		 *
 		 * Minimum nice_len: 2
 		 *
 		 * Memory usage: dict_size * 9.5
 		 */
 
 	LZMA_MF_BT3     = 0x13,
 		/**<
 		 * \brief       Binary Tree with 2- and 3-byte hashing
 		 *
 		 * Minimum nice_len: 3
 		 *
 		 * Memory usage:
 		 *  - dict_size <= 16 MiB: dict_size * 11.5
 		 *  - dict_size > 16 MiB: dict_size * 9.5 + 64 MiB
 		 */
 
 	LZMA_MF_BT4     = 0x14
 		/**<
 		 * \brief       Binary Tree with 2-, 3-, and 4-byte hashing
 		 *
 		 * Minimum nice_len: 4
 		 *
 		 * Memory usage:
 		 *  - dict_size <= 32 MiB: dict_size * 11.5
 		 *  - dict_size > 32 MiB: dict_size * 10.5
 		 */
 } lzma_match_finder;
 
 
 /**
  * \brief       Test if given match finder is supported
  *
  * It is safe to call this with a value that isn't listed in
  * lzma_match_finder enumeration; the return value will be false.
  *
  * There is no way to list which match finders are available in this
  * particular liblzma version and build. It would be useless, because
  * a new match finder, which the application developer wasn't aware,
  * could require giving additional options to the encoder that the older
  * match finders don't need.
  *
  * \param       match_finder    Match finder ID
  *
  * \return      lzma_bool:
  *              - true if the match finder is supported by this liblzma build.
  *              - false otherwise.
  */
 extern LZMA_API(lzma_bool) lzma_mf_is_supported(lzma_match_finder match_finder)
 		lzma_nothrow lzma_attr_const;
 
 
 /**
  * \brief       Compression modes
  *
  * This selects the function used to analyze the data produced by the match
  * finder.
  */
 typedef enum {
 	LZMA_MODE_FAST = 1,
 		/**<
 		 * \brief       Fast compression
 		 *
 		 * Fast mode is usually at its best when combined with
 		 * a hash chain match finder.
 		 */
 
 	LZMA_MODE_NORMAL = 2
 		/**<
 		 * \brief       Normal compression
 		 *
 		 * This is usually notably slower than fast mode. Use this
 		 * together with binary tree match finders to expose the
 		 * full potential of the LZMA1 or LZMA2 encoder.
 		 */
 } lzma_mode;
 
 
 /**
  * \brief       Test if given compression mode is supported
  *
  * It is safe to call this with a value that isn't listed in lzma_mode
  * enumeration; the return value will be false.
  *
  * There is no way to list which modes are available in this particular
  * liblzma version and build. It would be useless, because a new compression
  * mode, which the application developer wasn't aware, could require giving
  * additional options to the encoder that the older modes don't need.
  *
  * \param       mode    Mode ID.
  *
  * \return      lzma_bool:
  *              - true if the compression mode is supported by this liblzma
  *                build.
  *              - false otherwise.
  */
 extern LZMA_API(lzma_bool) lzma_mode_is_supported(lzma_mode mode)
 		lzma_nothrow lzma_attr_const;
 
 
 /**
  * \brief       Options specific to the LZMA1 and LZMA2 filters
  *
  * Since LZMA1 and LZMA2 share most of the code, it's simplest to share
  * the options structure too. For encoding, all but the reserved variables
  * need to be initialized unless specifically mentioned otherwise.
  * lzma_lzma_preset() can be used to get a good starting point.
  *
  * For raw decoding, both LZMA1 and LZMA2 need dict_size, preset_dict, and
  * preset_dict_size (if preset_dict != NULL). LZMA1 needs also lc, lp, and pb.
  */
 typedef struct {
 	/**
 	 * \brief       Dictionary size in bytes
 	 *
 	 * Dictionary size indicates how many bytes of the recently processed
 	 * uncompressed data is kept in memory. One method to reduce size of
 	 * the uncompressed data is to store distance-length pairs, which
 	 * indicate what data to repeat from the dictionary buffer. Thus,
 	 * the bigger the dictionary, the better the compression ratio
 	 * usually is.
 	 *
 	 * Maximum size of the dictionary depends on multiple things:
 	 *  - Memory usage limit
 	 *  - Available address space (not a problem on 64-bit systems)
 	 *  - Selected match finder (encoder only)
 	 *
 	 * Currently the maximum dictionary size for encoding is 1.5 GiB
 	 * (i.e. (UINT32_C(1) << 30) + (UINT32_C(1) << 29)) even on 64-bit
 	 * systems for certain match finder implementation reasons. In the
 	 * future, there may be match finders that support bigger
 	 * dictionaries.
 	 *
 	 * Decoder already supports dictionaries up to 4 GiB - 1 B (i.e.
 	 * UINT32_MAX), so increasing the maximum dictionary size of the
 	 * encoder won't cause problems for old decoders.
 	 *
 	 * Because extremely small dictionaries sizes would have unneeded
 	 * overhead in the decoder, the minimum dictionary size is 4096 bytes.
 	 *
 	 * \note        When decoding, too big dictionary does no other harm
 	 *              than wasting memory.
 	 */
 	uint32_t dict_size;
 #	define LZMA_DICT_SIZE_MIN       UINT32_C(4096)
 #	define LZMA_DICT_SIZE_DEFAULT   (UINT32_C(1) << 23)
 
 	/**
 	 * \brief       Pointer to an initial dictionary
 	 *
 	 * It is possible to initialize the LZ77 history window using
 	 * a preset dictionary. It is useful when compressing many
 	 * similar, relatively small chunks of data independently from
 	 * each other. The preset dictionary should contain typical
 	 * strings that occur in the files being compressed. The most
 	 * probable strings should be near the end of the preset dictionary.
 	 *
 	 * This feature should be used only in special situations. For
 	 * now, it works correctly only with raw encoding and decoding.
 	 * Currently none of the container formats supported by
 	 * liblzma allow preset dictionary when decoding, thus if
 	 * you create a .xz or .lzma file with preset dictionary, it
 	 * cannot be decoded with the regular decoder functions. In the
 	 * future, the .xz format will likely get support for preset
 	 * dictionary though.
 	 */
 	const uint8_t *preset_dict;
 
 	/**
 	 * \brief       Size of the preset dictionary
 	 *
 	 * Specifies the size of the preset dictionary. If the size is
 	 * bigger than dict_size, only the last dict_size bytes are
 	 * processed.
 	 *
 	 * This variable is read only when preset_dict is not NULL.
 	 * If preset_dict is not NULL but preset_dict_size is zero,
 	 * no preset dictionary is used (identical to only setting
 	 * preset_dict to NULL).
 	 */
 	uint32_t preset_dict_size;
 
 	/**
 	 * \brief       Number of literal context bits
 	 *
 	 * How many of the highest bits of the previous uncompressed
-	 * eight-bit byte (also known as `literal') are taken into
+	 * eight-bit byte (also known as 'literal') are taken into
 	 * account when predicting the bits of the next literal.
 	 *
 	 * E.g. in typical English text, an upper-case letter is
 	 * often followed by a lower-case letter, and a lower-case
 	 * letter is usually followed by another lower-case letter.
 	 * In the US-ASCII character set, the highest three bits are 010
 	 * for upper-case letters and 011 for lower-case letters.
 	 * When lc is at least 3, the literal coding can take advantage of
 	 * this property in the uncompressed data.
 	 *
 	 * There is a limit that applies to literal context bits and literal
 	 * position bits together: lc + lp <= 4. Without this limit the
 	 * decoding could become very slow, which could have security related
 	 * results in some cases like email servers doing virus scanning.
 	 * This limit also simplifies the internal implementation in liblzma.
 	 *
 	 * There may be LZMA1 streams that have lc + lp > 4 (maximum possible
 	 * lc would be 8). It is not possible to decode such streams with
 	 * liblzma.
 	 */
 	uint32_t lc;
 #	define LZMA_LCLP_MIN    0
 #	define LZMA_LCLP_MAX    4
 #	define LZMA_LC_DEFAULT  3
 
 	/**
 	 * \brief       Number of literal position bits
 	 *
 	 * lp affects what kind of alignment in the uncompressed data is
 	 * assumed when encoding literals. A literal is a single 8-bit byte.
 	 * See pb below for more information about alignment.
 	 */
 	uint32_t lp;
 #	define LZMA_LP_DEFAULT  0
 
 	/**
 	 * \brief       Number of position bits
 	 *
 	 * pb affects what kind of alignment in the uncompressed data is
 	 * assumed in general. The default means four-byte alignment
 	 * (2^ pb =2^2=4), which is often a good choice when there's
 	 * no better guess.
 	 *
 	 * When the alignment is known, setting pb accordingly may reduce
 	 * the file size a little. E.g. with text files having one-byte
 	 * alignment (US-ASCII, ISO-8859-*, UTF-8), setting pb=0 can
 	 * improve compression slightly. For UTF-16 text, pb=1 is a good
 	 * choice. If the alignment is an odd number like 3 bytes, pb=0
 	 * might be the best choice.
 	 *
 	 * Even though the assumed alignment can be adjusted with pb and
 	 * lp, LZMA1 and LZMA2 still slightly favor 16-byte alignment.
 	 * It might be worth taking into account when designing file formats
 	 * that are likely to be often compressed with LZMA1 or LZMA2.
 	 */
 	uint32_t pb;
 #	define LZMA_PB_MIN      0
 #	define LZMA_PB_MAX      4
 #	define LZMA_PB_DEFAULT  2
 
 	/** Compression mode */
 	lzma_mode mode;
 
 	/**
 	 * \brief       Nice length of a match
 	 *
 	 * This determines how many bytes the encoder compares from the match
 	 * candidates when looking for the best match. Once a match of at
 	 * least nice_len bytes long is found, the encoder stops looking for
 	 * better candidates and encodes the match. (Naturally, if the found
 	 * match is actually longer than nice_len, the actual length is
 	 * encoded; it's not truncated to nice_len.)
 	 *
 	 * Bigger values usually increase the compression ratio and
 	 * compression time. For most files, 32 to 128 is a good value,
 	 * which gives very good compression ratio at good speed.
 	 *
 	 * The exact minimum value depends on the match finder. The maximum
 	 * is 273, which is the maximum length of a match that LZMA1 and
 	 * LZMA2 can encode.
 	 */
 	uint32_t nice_len;
 
 	/** Match finder ID */
 	lzma_match_finder mf;
 
 	/**
 	 * \brief       Maximum search depth in the match finder
 	 *
 	 * For every input byte, match finder searches through the hash chain
 	 * or binary tree in a loop, each iteration going one step deeper in
 	 * the chain or tree. The searching stops if
 	 *  - a match of at least nice_len bytes long is found;
 	 *  - all match candidates from the hash chain or binary tree have
 	 *    been checked; or
 	 *  - maximum search depth is reached.
 	 *
 	 * Maximum search depth is needed to prevent the match finder from
 	 * wasting too much time in case there are lots of short match
 	 * candidates. On the other hand, stopping the search before all
 	 * candidates have been checked can reduce compression ratio.
 	 *
 	 * Setting depth to zero tells liblzma to use an automatic default
 	 * value, that depends on the selected match finder and nice_len.
 	 * The default is in the range [4, 200] or so (it may vary between
 	 * liblzma versions).
 	 *
 	 * Using a bigger depth value than the default can increase
 	 * compression ratio in some cases. There is no strict maximum value,
 	 * but high values (thousands or millions) should be used with care:
 	 * the encoder could remain fast enough with typical input, but
 	 * malicious input could cause the match finder to slow down
 	 * dramatically, possibly creating a denial of service attack.
 	 */
 	uint32_t depth;
 
 	/**
 	 * \brief       For LZMA_FILTER_LZMA1EXT: Extended flags
 	 *
 	 * This is used only with LZMA_FILTER_LZMA1EXT.
 	 *
 	 * Currently only one flag is supported, LZMA_LZMA1EXT_ALLOW_EOPM:
 	 *
 	 *   - Encoder: If the flag is set, then end marker is written just
 	 *     like it is with LZMA_FILTER_LZMA1. Without this flag the
 	 *     end marker isn't written and the application has to store
 	 *     the uncompressed size somewhere outside the compressed stream.
 	 *     To decompress streams without the end marker, the application
 	 *     has to set the correct uncompressed size in ext_size_low and
 	 *     ext_size_high.
 	 *
 	 *   - Decoder: If the uncompressed size in ext_size_low and
 	 *     ext_size_high is set to the special value UINT64_MAX
 	 *     (indicating unknown uncompressed size) then this flag is
 	 *     ignored and the end marker must always be present, that is,
 	 *     the behavior is identical to LZMA_FILTER_LZMA1.
 	 *
 	 *     Otherwise, if this flag isn't set, then the input stream
 	 *     must not have the end marker; if the end marker is detected
 	 *     then it will result in LZMA_DATA_ERROR. This is useful when
 	 *     it is known that the stream must not have the end marker and
 	 *     strict validation is wanted.
 	 *
 	 *     If this flag is set, then it is autodetected if the end marker
 	 *     is present after the specified number of uncompressed bytes
 	 *     has been decompressed (ext_size_low and ext_size_high). The
 	 *     end marker isn't allowed in any other position. This behavior
 	 *     is useful when uncompressed size is known but the end marker
 	 *     may or may not be present. This is the case, for example,
 	 *     in .7z files (valid .7z files that have the end marker in
 	 *     LZMA1 streams are rare but they do exist).
 	 */
 	uint32_t ext_flags;
 #	define LZMA_LZMA1EXT_ALLOW_EOPM   UINT32_C(0x01)
 
 	/**
 	 * \brief       For LZMA_FILTER_LZMA1EXT: Uncompressed size (low bits)
 	 *
 	 * The 64-bit uncompressed size is needed for decompression with
 	 * LZMA_FILTER_LZMA1EXT. The size is ignored by the encoder.
 	 *
 	 * The special value UINT64_MAX indicates that the uncompressed size
 	 * is unknown and that the end of payload marker (also known as
 	 * end of stream marker) must be present to indicate the end of
 	 * the LZMA1 stream. Any other value indicates the expected
 	 * uncompressed size of the LZMA1 stream. (If LZMA1 was used together
 	 * with filters that change the size of the data then the uncompressed
 	 * size of the LZMA1 stream could be different than the final
 	 * uncompressed size of the filtered stream.)
 	 *
 	 * ext_size_low holds the least significant 32 bits of the
 	 * uncompressed size. The most significant 32 bits must be set
 	 * in ext_size_high. The macro lzma_ext_size_set(opt_lzma, u64size)
 	 * can be used to set these members.
 	 *
 	 * The 64-bit uncompressed size is split into two uint32_t variables
 	 * because there were no reserved uint64_t members and using the
 	 * same options structure for LZMA_FILTER_LZMA1, LZMA_FILTER_LZMA1EXT,
 	 * and LZMA_FILTER_LZMA2 was otherwise more convenient than having
 	 * a new options structure for LZMA_FILTER_LZMA1EXT. (Replacing two
 	 * uint32_t members with one uint64_t changes the ABI on some systems
 	 * as the alignment of this struct can increase from 4 bytes to 8.)
 	 */
 	uint32_t ext_size_low;
 
 	/**
 	 * \brief       For LZMA_FILTER_LZMA1EXT: Uncompressed size (high bits)
 	 *
 	 * This holds the most significant 32 bits of the uncompressed size.
 	 */
 	uint32_t ext_size_high;
 
 	/*
 	 * Reserved space to allow possible future extensions without
 	 * breaking the ABI. You should not touch these, because the names
 	 * of these variables may change. These are and will never be used
 	 * with the currently supported options, so it is safe to leave these
 	 * uninitialized.
 	 */
 
 	/** \private     Reserved member. */
 	uint32_t reserved_int4;
 
 	/** \private     Reserved member. */
 	uint32_t reserved_int5;
 
 	/** \private     Reserved member. */
 	uint32_t reserved_int6;
 
 	/** \private     Reserved member. */
 	uint32_t reserved_int7;
 
 	/** \private     Reserved member. */
 	uint32_t reserved_int8;
 
 	/** \private     Reserved member. */
 	lzma_reserved_enum reserved_enum1;
 
 	/** \private     Reserved member. */
 	lzma_reserved_enum reserved_enum2;
 
 	/** \private     Reserved member. */
 	lzma_reserved_enum reserved_enum3;
 
 	/** \private     Reserved member. */
 	lzma_reserved_enum reserved_enum4;
 
 	/** \private     Reserved member. */
 	void *reserved_ptr1;
 
 	/** \private     Reserved member. */
 	void *reserved_ptr2;
 
 } lzma_options_lzma;
 
 
 /**
  * \brief       Macro to set the 64-bit uncompressed size in ext_size_*
  *
  * This might be convenient when decoding using LZMA_FILTER_LZMA1EXT.
  * This isn't used with LZMA_FILTER_LZMA1 or LZMA_FILTER_LZMA2.
  */
 #define lzma_set_ext_size(opt_lzma2, u64size) \
 do { \
 	(opt_lzma2).ext_size_low = (uint32_t)(u64size); \
 	(opt_lzma2).ext_size_high = (uint32_t)((uint64_t)(u64size) >> 32); \
 } while (0)
 
 
 /**
  * \brief       Set a compression preset to lzma_options_lzma structure
  *
  * 0 is the fastest and 9 is the slowest. These match the switches -0 .. -9
  * of the xz command line tool. In addition, it is possible to bitwise-or
  * flags to the preset. Currently only LZMA_PRESET_EXTREME is supported.
  * The flags are defined in container.h, because the flags are used also
  * with lzma_easy_encoder().
  *
  * The preset levels are subject to changes between liblzma versions.
  *
  * This function is available only if LZMA1 or LZMA2 encoder has been enabled
  * when building liblzma.
  *
  * If features (like certain match finders) have been disabled at build time,
  * then the function may return success (false) even though the resulting
  * LZMA1/LZMA2 options may not be usable for encoder initialization
  * (LZMA_OPTIONS_ERROR).
  *
  * \param[out]  options Pointer to LZMA1 or LZMA2 options to be filled
  * \param       preset  Preset level bitwse-ORed with preset flags
  *
  * \return      lzma_bool:
  *              - true if the preset is not supported (failure).
  *              - false otherwise (success).
  */
 extern LZMA_API(lzma_bool) lzma_lzma_preset(
 		lzma_options_lzma *options, uint32_t preset) lzma_nothrow;
diff --git a/src/liblzma/lz/lz_encoder.h b/src/liblzma/lz/lz_encoder.h
index b71f1180..80cdcf63 100644
--- a/src/liblzma/lz/lz_encoder.h
+++ b/src/liblzma/lz/lz_encoder.h
@@ -1,349 +1,349 @@
 ///////////////////////////////////////////////////////////////////////////////
 //
 /// \file       lz_encoder.h
 /// \brief      LZ in window and match finder API
 ///
 //  Authors:    Igor Pavlov
 //              Lasse Collin
 //
 //  This file has been put into the public domain.
 //  You can do whatever you want with this file.
 //
 ///////////////////////////////////////////////////////////////////////////////
 
 #ifndef LZMA_LZ_ENCODER_H
 #define LZMA_LZ_ENCODER_H
 
 #include "common.h"
 
 
 // For now, the dictionary size is limited to 1.5 GiB. This may grow
 // in the future if needed, but it needs a little more work than just
 // changing this check.
 #define IS_ENC_DICT_SIZE_VALID(size) \
 	((size) >= LZMA_DICT_SIZE_MIN \
 			&&  (size) <= (UINT32_C(1) << 30) + (UINT32_C(1) << 29))
 
 
 /// A table of these is used by the LZ-based encoder to hold
 /// the length-distance pairs found by the match finder.
 typedef struct {
 	uint32_t len;
 	uint32_t dist;
 } lzma_match;
 
 
 typedef struct lzma_mf_s lzma_mf;
 struct lzma_mf_s {
 	///////////////
 	// In Window //
 	///////////////
 
 	/// Pointer to buffer with data to be compressed
 	uint8_t *buffer;
 
 	/// Total size of the allocated buffer (that is, including all
 	/// the extra space)
 	uint32_t size;
 
 	/// Number of bytes that must be kept available in our input history.
 	/// That is, once keep_size_before bytes have been processed,
 	/// buffer[read_pos - keep_size_before] is the oldest byte that
 	/// must be available for reading.
 	uint32_t keep_size_before;
 
 	/// Number of bytes that must be kept in buffer after read_pos.
 	/// That is, read_pos <= write_pos - keep_size_after as long as
 	/// action is LZMA_RUN; when action != LZMA_RUN, read_pos is allowed
 	/// to reach write_pos so that the last bytes get encoded too.
 	uint32_t keep_size_after;
 
 	/// Match finders store locations of matches using 32-bit integers.
 	/// To avoid adjusting several megabytes of integers every time the
 	/// input window is moved with move_window, we only adjust the
 	/// offset of the buffer. Thus, buffer[value_in_hash_table - offset]
 	/// is the byte pointed by value_in_hash_table.
 	uint32_t offset;
 
 	/// buffer[read_pos] is the next byte to run through the match
 	/// finder. This is incremented in the match finder once the byte
 	/// has been processed.
 	uint32_t read_pos;
 
 	/// Number of bytes that have been ran through the match finder, but
 	/// which haven't been encoded by the LZ-based encoder yet.
 	uint32_t read_ahead;
 
 	/// As long as read_pos is less than read_limit, there is enough
 	/// input available in buffer for at least one encoding loop.
 	///
 	/// Because of the stateful API, read_limit may and will get greater
 	/// than read_pos quite often. This is taken into account when
 	/// calculating the value for keep_size_after.
 	uint32_t read_limit;
 
 	/// buffer[write_pos] is the first byte that doesn't contain valid
 	/// uncompressed data; that is, the next input byte will be copied
 	/// to buffer[write_pos].
 	uint32_t write_pos;
 
 	/// Number of bytes not hashed before read_pos. This is needed to
 	/// restart the match finder after LZMA_SYNC_FLUSH.
 	uint32_t pending;
 
 	//////////////////
 	// Match Finder //
 	//////////////////
 
 	/// Find matches. Returns the number of distance-length pairs written
 	/// to the matches array. This is called only via lzma_mf_find().
 	uint32_t (*find)(lzma_mf *mf, lzma_match *matches);
 
 	/// Skips num bytes. This is like find() but doesn't make the
 	/// distance-length pairs available, thus being a little faster.
 	/// This is called only via mf_skip().
 	void (*skip)(lzma_mf *mf, uint32_t num);
 
 	uint32_t *hash;
 	uint32_t *son;
 	uint32_t cyclic_pos;
 	uint32_t cyclic_size; // Must be dictionary size + 1.
 	uint32_t hash_mask;
 
 	/// Maximum number of loops in the match finder
 	uint32_t depth;
 
 	/// Maximum length of a match that the match finder will try to find.
 	uint32_t nice_len;
 
 	/// Maximum length of a match supported by the LZ-based encoder.
 	/// If the longest match found by the match finder is nice_len,
 	/// mf_find() tries to expand it up to match_len_max bytes.
 	uint32_t match_len_max;
 
 	/// When running out of input, binary tree match finders need to know
 	/// if it is due to flushing or finishing. The action is used also
 	/// by the LZ-based encoders themselves.
 	lzma_action action;
 
 	/// Number of elements in hash[]
 	uint32_t hash_count;
 
 	/// Number of elements in son[]
 	uint32_t sons_count;
 };
 
 
 typedef struct {
 	/// Extra amount of data to keep available before the "actual"
 	/// dictionary.
 	size_t before_size;
 
 	/// Size of the history buffer
 	size_t dict_size;
 
 	/// Extra amount of data to keep available after the "actual"
 	/// dictionary.
 	size_t after_size;
 
 	/// Maximum length of a match that the LZ-based encoder can accept.
 	/// This is used to extend matches of length nice_len to the
 	/// maximum possible length.
 	size_t match_len_max;
 
 	/// Match finder will search matches up to this length.
 	/// This must be less than or equal to match_len_max.
 	size_t nice_len;
 
 	/// Type of the match finder to use
 	lzma_match_finder match_finder;
 
 	/// Maximum search depth
 	uint32_t depth;
 
 	/// TODO: Comment
 	const uint8_t *preset_dict;
 
 	uint32_t preset_dict_size;
 
 } lzma_lz_options;
 
 
 // The total usable buffer space at any moment outside the match finder:
 // before_size + dict_size + after_size + match_len_max
 //
 // In reality, there's some extra space allocated to prevent the number of
 // memmove() calls reasonable. The bigger the dict_size is, the bigger
 // this extra buffer will be since with bigger dictionaries memmove() would
 // also take longer.
 //
 // A single encoder loop in the LZ-based encoder may call the match finder
 // (mf_find() or mf_skip()) at most after_size times. In other words,
 // a single encoder loop may increment lzma_mf.read_pos at most after_size
 // times. Since matches are looked up to
 // lzma_mf.buffer[lzma_mf.read_pos + match_len_max - 1], the total
 // amount of extra buffer needed after dict_size becomes
 // after_size + match_len_max.
 //
 // before_size has two uses. The first one is to keep literals available
 // in cases when the LZ-based encoder has made some read ahead.
 // TODO: Maybe this could be changed by making the LZ-based encoders to
 // store the actual literals as they do with length-distance pairs.
 //
 // Algorithms such as LZMA2 first try to compress a chunk, and then check
 // if the encoded result is smaller than the uncompressed one. If the chunk
 // was incompressible, it is better to store it in uncompressed form in
 // the output stream. To do this, the whole uncompressed chunk has to be
 // still available in the history buffer. before_size achieves that.
 
 
 typedef struct {
 	/// Data specific to the LZ-based encoder
 	void *coder;
 
 	/// Function to encode from *dict to out[]
 	lzma_ret (*code)(void *coder,
 			lzma_mf *restrict mf, uint8_t *restrict out,
 			size_t *restrict out_pos, size_t out_size);
 
 	/// Free allocated resources
 	void (*end)(void *coder, const lzma_allocator *allocator);
 
 	/// Update the options in the middle of the encoding.
 	lzma_ret (*options_update)(void *coder, const lzma_filter *filter);
 
 	/// Set maximum allowed output size
 	lzma_ret (*set_out_limit)(void *coder, uint64_t *uncomp_size,
 			uint64_t out_limit);
 
 } lzma_lz_encoder;
 
 
 // Basic steps:
 //  1. Input gets copied into the dictionary.
 //  2. Data in dictionary gets run through the match finder byte by byte.
 //  3. The literals and matches are encoded using e.g. LZMA.
 //
 // The bytes that have been ran through the match finder, but not encoded yet,
-// are called `read ahead'.
+// are called 'read ahead'.
 
 
 /// Get how many bytes the match finder hashes in its initial step.
 /// This is also the minimum nice_len value with the match finder.
 static inline uint32_t
 mf_get_hash_bytes(lzma_match_finder match_finder)
 {
 	return (uint32_t)match_finder & 0x0F;
 }
 
 
 /// Get pointer to the first byte not ran through the match finder
 static inline const uint8_t *
 mf_ptr(const lzma_mf *mf)
 {
 	return mf->buffer + mf->read_pos;
 }
 
 
 /// Get the number of bytes that haven't been ran through the match finder yet.
 static inline uint32_t
 mf_avail(const lzma_mf *mf)
 {
 	return mf->write_pos - mf->read_pos;
 }
 
 
 /// Get the number of bytes that haven't been encoded yet (some of these
 /// bytes may have been ran through the match finder though).
 static inline uint32_t
 mf_unencoded(const lzma_mf *mf)
 {
 	return mf->write_pos - mf->read_pos + mf->read_ahead;
 }
 
 
 /// Calculate the absolute offset from the beginning of the most recent
 /// dictionary reset. Only the lowest four bits are important, so there's no
 /// problem that we don't know the 64-bit size of the data encoded so far.
 ///
 /// NOTE: When moving the input window, we need to do it so that the lowest
 /// bits of dict->read_pos are not modified to keep this macro working
 /// as intended.
 static inline uint32_t
 mf_position(const lzma_mf *mf)
 {
 	return mf->read_pos - mf->read_ahead;
 }
 
 
 /// Since everything else begins with mf_, use it also for lzma_mf_find().
 #define mf_find lzma_mf_find
 
 
 /// Skip the given number of bytes. This is used when a good match was found.
 /// For example, if mf_find() finds a match of 200 bytes long, the first byte
 /// of that match was already consumed by mf_find(), and the rest 199 bytes
 /// have to be skipped with mf_skip(mf, 199).
 static inline void
 mf_skip(lzma_mf *mf, uint32_t amount)
 {
 	if (amount != 0) {
 		mf->skip(mf, amount);
 		mf->read_ahead += amount;
 	}
 }
 
 
 /// Copies at most *left number of bytes from the history buffer
 /// to out[]. This is needed by LZMA2 to encode uncompressed chunks.
 static inline void
 mf_read(lzma_mf *mf, uint8_t *out, size_t *out_pos, size_t out_size,
 		size_t *left)
 {
 	const size_t out_avail = out_size - *out_pos;
 	const size_t copy_size = my_min(out_avail, *left);
 
 	assert(mf->read_ahead == 0);
 	assert(mf->read_pos >= *left);
 
 	memcpy(out + *out_pos, mf->buffer + mf->read_pos - *left,
 			copy_size);
 
 	*out_pos += copy_size;
 	*left -= copy_size;
 	return;
 }
 
 
 extern lzma_ret lzma_lz_encoder_init(
 		lzma_next_coder *next, const lzma_allocator *allocator,
 		const lzma_filter_info *filters,
 		lzma_ret (*lz_init)(lzma_lz_encoder *lz,
 			const lzma_allocator *allocator,
 			lzma_vli id, const void *options,
 			lzma_lz_options *lz_options));
 
 
 extern uint64_t lzma_lz_encoder_memusage(const lzma_lz_options *lz_options);
 
 
 // These are only for LZ encoder's internal use.
 extern uint32_t lzma_mf_find(
 		lzma_mf *mf, uint32_t *count, lzma_match *matches);
 
 extern uint32_t lzma_mf_hc3_find(lzma_mf *dict, lzma_match *matches);
 extern void lzma_mf_hc3_skip(lzma_mf *dict, uint32_t amount);
 
 extern uint32_t lzma_mf_hc4_find(lzma_mf *dict, lzma_match *matches);
 extern void lzma_mf_hc4_skip(lzma_mf *dict, uint32_t amount);
 
 extern uint32_t lzma_mf_bt2_find(lzma_mf *dict, lzma_match *matches);
 extern void lzma_mf_bt2_skip(lzma_mf *dict, uint32_t amount);
 
 extern uint32_t lzma_mf_bt3_find(lzma_mf *dict, lzma_match *matches);
 extern void lzma_mf_bt3_skip(lzma_mf *dict, uint32_t amount);
 
 extern uint32_t lzma_mf_bt4_find(lzma_mf *dict, lzma_match *matches);
 extern void lzma_mf_bt4_skip(lzma_mf *dict, uint32_t amount);
 
 #endif
diff --git a/src/liblzma/rangecoder/range_decoder.h b/src/liblzma/rangecoder/range_decoder.h
index e0b051fa..7d0fd81a 100644
--- a/src/liblzma/rangecoder/range_decoder.h
+++ b/src/liblzma/rangecoder/range_decoder.h
@@ -1,185 +1,185 @@
 ///////////////////////////////////////////////////////////////////////////////
 //
 /// \file       range_decoder.h
 /// \brief      Range Decoder
 ///
 //  Authors:    Igor Pavlov
 //              Lasse Collin
 //
 //  This file has been put into the public domain.
 //  You can do whatever you want with this file.
 //
 ///////////////////////////////////////////////////////////////////////////////
 
 #ifndef LZMA_RANGE_DECODER_H
 #define LZMA_RANGE_DECODER_H
 
 #include "range_common.h"
 
 
 typedef struct {
 	uint32_t range;
 	uint32_t code;
 	uint32_t init_bytes_left;
 } lzma_range_decoder;
 
 
 /// Reads the first five bytes to initialize the range decoder.
 static inline lzma_ret
 rc_read_init(lzma_range_decoder *rc, const uint8_t *restrict in,
 		size_t *restrict in_pos, size_t in_size)
 {
 	while (rc->init_bytes_left > 0) {
 		if (*in_pos == in_size)
 			return LZMA_OK;
 
 		// The first byte is always 0x00. It could have been omitted
 		// in LZMA2 but it wasn't, so one byte is wasted in every
 		// LZMA2 chunk.
 		if (rc->init_bytes_left == 5 && in[*in_pos] != 0x00)
 			return LZMA_DATA_ERROR;
 
 		rc->code = (rc->code << 8) | in[*in_pos];
 		++*in_pos;
 		--rc->init_bytes_left;
 	}
 
 	return LZMA_STREAM_END;
 }
 
 
 /// Makes local copies of range decoder and *in_pos variables. Doing this
 /// improves speed significantly. The range decoder macros expect also
-/// variables `in' and `in_size' to be defined.
+/// variables 'in' and 'in_size' to be defined.
 #define rc_to_local(range_decoder, in_pos) \
 	lzma_range_decoder rc = range_decoder; \
 	size_t rc_in_pos = (in_pos); \
 	uint32_t rc_bound
 
 
 /// Stores the local copes back to the range decoder structure.
 #define rc_from_local(range_decoder, in_pos) \
 do { \
 	range_decoder = rc; \
 	in_pos = rc_in_pos; \
 } while (0)
 
 
 /// Resets the range decoder structure.
 #define rc_reset(range_decoder) \
 do { \
 	(range_decoder).range = UINT32_MAX; \
 	(range_decoder).code = 0; \
 	(range_decoder).init_bytes_left = 5; \
 } while (0)
 
 
 /// When decoding has been properly finished, rc.code is always zero unless
 /// the input stream is corrupt. So checking this can catch some corrupt
 /// files especially if they don't have any other integrity check.
 #define rc_is_finished(range_decoder) \
 	((range_decoder).code == 0)
 
 
 /// Read the next input byte if needed. If more input is needed but there is
 /// no more input available, "goto out" is used to jump out of the main
 /// decoder loop.
 #define rc_normalize(seq) \
 do { \
 	if (rc.range < RC_TOP_VALUE) { \
 		if (unlikely(rc_in_pos == in_size)) { \
 			coder->sequence = seq; \
 			goto out; \
 		} \
 		rc.range <<= RC_SHIFT_BITS; \
 		rc.code = (rc.code << RC_SHIFT_BITS) | in[rc_in_pos++]; \
 	} \
 } while (0)
 
 
 /// Start decoding a bit. This must be used together with rc_update_0()
 /// and rc_update_1():
 ///
 ///     rc_if_0(prob, seq) {
 ///         rc_update_0(prob);
 ///         // Do something
 ///     } else {
 ///         rc_update_1(prob);
 ///         // Do something else
 ///     }
 ///
 #define rc_if_0(prob, seq) \
 	rc_normalize(seq); \
 	rc_bound = (rc.range >> RC_BIT_MODEL_TOTAL_BITS) * (prob); \
 	if (rc.code < rc_bound)
 
 
 /// Update the range decoder state and the used probability variable to
 /// match a decoded bit of 0.
 #define rc_update_0(prob) \
 do { \
 	rc.range = rc_bound; \
 	prob += (RC_BIT_MODEL_TOTAL - (prob)) >> RC_MOVE_BITS; \
 } while (0)
 
 
 /// Update the range decoder state and the used probability variable to
 /// match a decoded bit of 1.
 #define rc_update_1(prob) \
 do { \
 	rc.range -= rc_bound; \
 	rc.code -= rc_bound; \
 	prob -= (prob) >> RC_MOVE_BITS; \
 } while (0)
 
 
 /// Decodes one bit and runs action0 or action1 depending on the decoded bit.
 /// This macro is used as the last step in bittree reverse decoders since
 /// those don't use "symbol" for anything else than indexing the probability
 /// arrays.
 #define rc_bit_last(prob, action0, action1, seq) \
 do { \
 	rc_if_0(prob, seq) { \
 		rc_update_0(prob); \
 		action0; \
 	} else { \
 		rc_update_1(prob); \
 		action1; \
 	} \
 } while (0)
 
 
 /// Decodes one bit, updates "symbol", and runs action0 or action1 depending
 /// on the decoded bit.
 #define rc_bit(prob, action0, action1, seq) \
 	rc_bit_last(prob, \
 		symbol <<= 1; action0, \
 		symbol = (symbol << 1) + 1; action1, \
 		seq);
 
 
 /// Like rc_bit() but add "case seq:" as a prefix. This makes the unrolled
 /// loops more readable because the code isn't littered with "case"
 /// statements. On the other hand this also makes it less readable, since
 /// spotting the places where the decoder loop may be restarted is less
 /// obvious.
 #define rc_bit_case(prob, action0, action1, seq) \
 	case seq: rc_bit(prob, action0, action1, seq)
 
 
 /// Decode a bit without using a probability.
 #define rc_direct(dest, seq) \
 do { \
 	rc_normalize(seq); \
 	rc.range >>= 1; \
 	rc.code -= rc.range; \
 	rc_bound = UINT32_C(0) - (rc.code >> 31); \
 	rc.code += rc.range & rc_bound; \
 	dest = (dest << 1) + (rc_bound + 1); \
 } while (0)
 
 
 // NOTE: No macros are provided for bittree decoding. It seems to be simpler
 // to just write them open in the code.
 
 #endif