commit a165d7df1964121eb9df715e6f836a31c865beef
Author: Jia Tan <jiat0218@gmail.com>
Date:   Sat May 13 00:44:41 2023 +0800

    xz: Add a new --filters-help option.
    
    The --filters-help can be used to help create filter chains with the
    --filters and --filtersX options. The message in --long-help is too
    short to fully explain the syntax to construct complex filter chains.
    
    In --robot mode, xz will only print the output from liblzma function
    lzma_str_list_filters.

diff --git a/src/xz/args.c b/src/xz/args.c
index 6ae3c96f..7af3e850 100644
--- a/src/xz/args.c
+++ b/src/xz/args.c
@@ -1,844 +1,852 @@
 ///////////////////////////////////////////////////////////////////////////////
 //
 /// \file       args.c
 /// \brief      Argument parsing
 ///
 /// \note       Filter-specific options parsing is in options.c.
 //
 //  Author:     Lasse Collin
 //
 //  This file has been put into the public domain.
 //  You can do whatever you want with this file.
 //
 ///////////////////////////////////////////////////////////////////////////////
 
 #include "private.h"
 
 #include "getopt.h"
 #include <ctype.h>
 
 
 bool opt_stdout = false;
 bool opt_force = false;
 bool opt_keep_original = false;
 bool opt_robot = false;
 bool opt_ignore_check = false;
 
 // We don't modify or free() this, but we need to assign it in some
 // non-const pointers.
 const char stdin_filename[] = "(stdin)";
 
 
 /// Parse and set the memory usage limit for compression, decompression,
 /// and/or multithreaded decompression.
 static void
 parse_memlimit(const char *name, const char *name_percentage, const char *str,
 		bool set_compress, bool set_decompress, bool set_mtdec)
 {
 	bool is_percentage = false;
 	uint64_t value;
 
 	const size_t len = strlen(str);
 	if (len > 0 && str[len - 1] == '%') {
 		// Make a copy so that we can get rid of %.
 		//
 		// In the past str wasn't const and we modified it directly
 		// but that modified argv[] and thus affected what was visible
 		// in "ps auxf" or similar tools which was confusing. For
 		// example, --memlimit=50% would show up as --memlimit=50
 		// since the percent sign was overwritten here.
 		char *s = xstrdup(str);
 		s[len - 1] = '\0';
 		is_percentage = true;
 		value = str_to_uint64(name_percentage, s, 1, 100);
 		free(s);
 	} else {
 		// On 32-bit systems, SIZE_MAX would make more sense than
 		// UINT64_MAX. But use UINT64_MAX still so that scripts
 		// that assume > 4 GiB values don't break.
 		value = str_to_uint64(name, str, 0, UINT64_MAX);
 	}
 
 	hardware_memlimit_set(value, set_compress, set_decompress, set_mtdec,
 			is_percentage);
 	return;
 }
 
 
 static void
 parse_block_list(const char *str_const)
 {
 	// We need a modifiable string in the for-loop.
 	char *str_start = xstrdup(str_const);
 	char *str = str_start;
 
 	// It must be non-empty and not begin with a comma.
 	if (str[0] == '\0' || str[0] == ',')
 		message_fatal(_("%s: Invalid argument to --block-list"), str);
 
 	// Count the number of comma-separated strings.
 	size_t count = 1;
 	for (size_t i = 0; str[i] != '\0'; ++i)
 		if (str[i] == ',')
 			++count;
 
 	// Prevent an unlikely integer overflow.
 	if (count > SIZE_MAX / sizeof(block_list_entry) - 1)
 		message_fatal(_("%s: Too many arguments to --block-list"),
 				str);
 
 	// Allocate memory to hold all the sizes specified.
 	// If --block-list was specified already, its value is forgotten.
 	free(opt_block_list);
 	opt_block_list = xmalloc((count + 1) * sizeof(block_list_entry));
 
 	for (size_t i = 0; i < count; ++i) {
 		// Locate the next comma and replace it with \0.
 		char *p = strchr(str, ',');
 		if (p != NULL)
 			*p = '\0';
 
 		// Use the default filter chain unless overridden.
 		opt_block_list[i].filters_index = 0;
 
 		// To specify a filter chain, the block list entry may be
 		// prepended with "[filter-chain-number]:". The size is
 		// still required for every block.
 		// For instance:
 		// --block-list=2:10MiB,1:5MiB,,8MiB,0:0
 		//
 		// Translates to:
 		// 1. Block of 10 MiB using filter chain 2
 		// 2. Block of 5 MiB using filter chain 1
 		// 3. Block of 5 MiB using filter chain 1
 		// 4. Block of 8 MiB using the default filter chain
 		// 5. The last block uses the default filter chain
 		//
 		// The block list:
 		// --block-list=2:MiB,1:,0
 		//
 		// Is not allowed because the second block does not specify
 		// the block size, only the filter chain.
 		if (str[0] >= '0' && str[0] <= '9' && str[1] == ':') {
 			if (str[2] == '\0')
 				message_fatal(_("In --block-list, block "
 						"size is missing after "
 						"filter chain number `%c:'"),
 						str[0]);
 
 			int filter_num = str[0] - '0';
 			opt_block_list[i].filters_index =
 					(uint32_t)filter_num;
 			str += 2;
 		}
 
 		if (str[0] == '\0') {
 			// There is no string, that is, a comma follows
 			// another comma. Use the previous value.
 			//
 			// NOTE: We checked earlier that the first char
 			// of the whole list cannot be a comma.
 			assert(i > 0);
 			opt_block_list[i] = opt_block_list[i - 1];
 		} else {
 			opt_block_list[i].size = str_to_uint64("block-list",
 					str, 0, UINT64_MAX);
 
 			// Zero indicates no more new Blocks.
 			if (opt_block_list[i].size == 0) {
 				if (i + 1 != count)
 					message_fatal(_("0 can only be used "
 							"as the last element "
 							"in --block-list"));
 
 				opt_block_list[i].size = UINT64_MAX;
 			}
 		}
 
 		str = p + 1;
 	}
 
 	// Terminate the array.
 	opt_block_list[count].size = 0;
 
 	free(str_start);
 	return;
 }
 
 
 static void
 parse_real(args_info *args, int argc, char **argv)
 {
 	enum {
 		OPT_FILTERS = INT_MIN,
 		OPT_FILTERS1,
 		OPT_FILTERS2,
 		OPT_FILTERS3,
 		OPT_FILTERS4,
 		OPT_FILTERS5,
 		OPT_FILTERS6,
 		OPT_FILTERS7,
 		OPT_FILTERS8,
 		OPT_FILTERS9,
+		OPT_FILTERS_HELP,
 
 		OPT_X86,
 		OPT_POWERPC,
 		OPT_IA64,
 		OPT_ARM,
 		OPT_ARMTHUMB,
 		OPT_ARM64,
 		OPT_SPARC,
 		OPT_DELTA,
 		OPT_LZMA1,
 		OPT_LZMA2,
 
 		OPT_SINGLE_STREAM,
 		OPT_NO_SPARSE,
 		OPT_FILES,
 		OPT_FILES0,
 		OPT_BLOCK_SIZE,
 		OPT_BLOCK_LIST,
 		OPT_MEM_COMPRESS,
 		OPT_MEM_DECOMPRESS,
 		OPT_MEM_MT_DECOMPRESS,
 		OPT_NO_ADJUST,
 		OPT_INFO_MEMORY,
 		OPT_ROBOT,
 		OPT_FLUSH_TIMEOUT,
 		OPT_IGNORE_CHECK,
 	};
 
 	static const char short_opts[]
 			= "cC:defF:hHlkM:qQrS:tT:vVz0123456789";
 
 	static const struct option long_opts[] = {
 		// Operation mode
 		{ "compress",     no_argument,       NULL,  'z' },
 		{ "decompress",   no_argument,       NULL,  'd' },
 		{ "uncompress",   no_argument,       NULL,  'd' },
 		{ "test",         no_argument,       NULL,  't' },
 		{ "list",         no_argument,       NULL,  'l' },
 
 		// Operation modifiers
 		{ "keep",         no_argument,       NULL,  'k' },
 		{ "force",        no_argument,       NULL,  'f' },
 		{ "stdout",       no_argument,       NULL,  'c' },
 		{ "to-stdout",    no_argument,       NULL,  'c' },
 		{ "single-stream", no_argument,      NULL,  OPT_SINGLE_STREAM },
 		{ "no-sparse",    no_argument,       NULL,  OPT_NO_SPARSE },
 		{ "suffix",       required_argument, NULL,  'S' },
 		// { "recursive",      no_argument,       NULL,  'r' }, // TODO
 		{ "files",        optional_argument, NULL,  OPT_FILES },
 		{ "files0",       optional_argument, NULL,  OPT_FILES0 },
 
 		// Basic compression settings
 		{ "format",       required_argument, NULL,  'F' },
 		{ "check",        required_argument, NULL,  'C' },
 		{ "ignore-check", no_argument,       NULL,  OPT_IGNORE_CHECK },
 		{ "block-size",   required_argument, NULL,  OPT_BLOCK_SIZE },
 		{ "block-list",  required_argument, NULL,  OPT_BLOCK_LIST },
 		{ "memlimit-compress",   required_argument, NULL, OPT_MEM_COMPRESS },
 		{ "memlimit-decompress", required_argument, NULL, OPT_MEM_DECOMPRESS },
 		{ "memlimit-mt-decompress", required_argument, NULL, OPT_MEM_MT_DECOMPRESS },
 		{ "memlimit",     required_argument, NULL,  'M' },
 		{ "memory",       required_argument, NULL,  'M' }, // Old alias
 		{ "no-adjust",    no_argument,       NULL,  OPT_NO_ADJUST },
 		{ "threads",      required_argument, NULL,  'T' },
 		{ "flush-timeout", required_argument, NULL, OPT_FLUSH_TIMEOUT },
 
 		{ "extreme",      no_argument,       NULL,  'e' },
 		{ "fast",         no_argument,       NULL,  '0' },
 		{ "best",         no_argument,       NULL,  '9' },
 
 		// Filters
 		{ "filters",      optional_argument, NULL,  OPT_FILTERS},
 		{ "filters1",     optional_argument, NULL,  OPT_FILTERS1},
 		{ "filters2",     optional_argument, NULL,  OPT_FILTERS2},
 		{ "filters3",     optional_argument, NULL,  OPT_FILTERS3},
 		{ "filters4",     optional_argument, NULL,  OPT_FILTERS4},
 		{ "filters5",     optional_argument, NULL,  OPT_FILTERS5},
 		{ "filters6",     optional_argument, NULL,  OPT_FILTERS6},
 		{ "filters7",     optional_argument, NULL,  OPT_FILTERS7},
 		{ "filters8",     optional_argument, NULL,  OPT_FILTERS8},
 		{ "filters9",     optional_argument, NULL,  OPT_FILTERS9},
+		{ "filters-help", optional_argument, NULL,  OPT_FILTERS_HELP},
 
 		{ "lzma1",        optional_argument, NULL,  OPT_LZMA1 },
 		{ "lzma2",        optional_argument, NULL,  OPT_LZMA2 },
 		{ "x86",          optional_argument, NULL,  OPT_X86 },
 		{ "powerpc",      optional_argument, NULL,  OPT_POWERPC },
 		{ "ia64",         optional_argument, NULL,  OPT_IA64 },
 		{ "arm",          optional_argument, NULL,  OPT_ARM },
 		{ "armthumb",     optional_argument, NULL,  OPT_ARMTHUMB },
 		{ "arm64",        optional_argument, NULL,  OPT_ARM64 },
 		{ "sparc",        optional_argument, NULL,  OPT_SPARC },
 		{ "delta",        optional_argument, NULL,  OPT_DELTA },
 
 		// Other options
 		{ "quiet",        no_argument,       NULL,  'q' },
 		{ "verbose",      no_argument,       NULL,  'v' },
 		{ "no-warn",      no_argument,       NULL,  'Q' },
 		{ "robot",        no_argument,       NULL,  OPT_ROBOT },
 		{ "info-memory",  no_argument,       NULL,  OPT_INFO_MEMORY },
 		{ "help",         no_argument,       NULL,  'h' },
 		{ "long-help",    no_argument,       NULL,  'H' },
 		{ "version",      no_argument,       NULL,  'V' },
 
 		{ NULL,           0,                 NULL,   0 }
 	};
 
 	int c;
 
 	while ((c = getopt_long(argc, argv, short_opts, long_opts, NULL))
 			!= -1) {
 		switch (c) {
 		// Compression preset (also for decompression if --format=raw)
 		case '0': case '1': case '2': case '3': case '4':
 		case '5': case '6': case '7': case '8': case '9':
 			coder_set_preset((uint32_t)(c - '0'));
 			break;
 
 		// --memlimit-compress
 		case OPT_MEM_COMPRESS:
 			parse_memlimit("memlimit-compress",
 					"memlimit-compress%", optarg,
 					true, false, false);
 			break;
 
 		// --memlimit-decompress
 		case OPT_MEM_DECOMPRESS:
 			parse_memlimit("memlimit-decompress",
 					"memlimit-decompress%", optarg,
 					false, true, false);
 			break;
 
 		// --memlimit-mt-decompress
 		case OPT_MEM_MT_DECOMPRESS:
 			parse_memlimit("memlimit-mt-decompress",
 					"memlimit-mt-decompress%", optarg,
 					false, false, true);
 			break;
 
 		// --memlimit
 		case 'M':
 			parse_memlimit("memlimit", "memlimit%", optarg,
 					true, true, true);
 			break;
 
 		// --suffix
 		case 'S':
 			suffix_set(optarg);
 			break;
 
 		case 'T': {
 			// Since xz 5.4.0: Ignore leading '+' first.
 			const char *s = optarg;
 			if (optarg[0] == '+')
 				++s;
 
 			// The max is from src/liblzma/common/common.h.
 			uint32_t t = str_to_uint64("threads", s, 0, 16384);
 
 			// If leading '+' was used then use multi-threaded
 			// mode even if exactly one thread was specified.
 			if (t == 1 && optarg[0] == '+')
 				t = UINT32_MAX;
 
 			hardware_threads_set(t);
 			break;
 		}
 
 		// --version
 		case 'V':
 			// This doesn't return.
 			message_version();
 
 		// --stdout
 		case 'c':
 			opt_stdout = true;
 			break;
 
 		// --decompress
 		case 'd':
 			opt_mode = MODE_DECOMPRESS;
 			break;
 
 		// --extreme
 		case 'e':
 			coder_set_extreme();
 			break;
 
 		// --force
 		case 'f':
 			opt_force = true;
 			break;
 
 		// --info-memory
 		case OPT_INFO_MEMORY:
 			// This doesn't return.
 			hardware_memlimit_show();
 
 		// --help
 		case 'h':
 			// This doesn't return.
 			message_help(false);
 
 		// --long-help
 		case 'H':
 			// This doesn't return.
 			message_help(true);
 
 		// --list
 		case 'l':
 			opt_mode = MODE_LIST;
 			break;
 
 		// --keep
 		case 'k':
 			opt_keep_original = true;
 			break;
 
 		// --quiet
 		case 'q':
 			message_verbosity_decrease();
 			break;
 
 		case 'Q':
 			set_exit_no_warn();
 			break;
 
 		case 't':
 			opt_mode = MODE_TEST;
 			break;
 
 		// --verbose
 		case 'v':
 			message_verbosity_increase();
 			break;
 
 		// --robot
 		case OPT_ROBOT:
 			opt_robot = true;
 
 			// This is to make sure that floating point numbers
 			// always have a dot as decimal separator.
 			setlocale(LC_NUMERIC, "C");
 			break;
 
 		case 'z':
 			opt_mode = MODE_COMPRESS;
 			break;
 
 		// --filters
 		case OPT_FILTERS:
 			coder_add_filters_from_str(optarg);
 			break;
 
 		// --filters1...--filters9
 		case OPT_FILTERS1:
 		case OPT_FILTERS2:
 		case OPT_FILTERS3:
 		case OPT_FILTERS4:
 		case OPT_FILTERS5:
 		case OPT_FILTERS6:
 		case OPT_FILTERS7:
 		case OPT_FILTERS8:
 		case OPT_FILTERS9:
 			coder_add_block_filters(optarg,
 					(size_t)(c - OPT_FILTERS));
 			break;
 
+		// --filters-help
+		case OPT_FILTERS_HELP:
+			// This doesn't return.
+			message_filters_help();
+			break;
+
 		case OPT_X86:
 			coder_add_filter(LZMA_FILTER_X86,
 					options_bcj(optarg));
 			break;
 
 		case OPT_POWERPC:
 			coder_add_filter(LZMA_FILTER_POWERPC,
 					options_bcj(optarg));
 			break;
 
 		case OPT_IA64:
 			coder_add_filter(LZMA_FILTER_IA64,
 					options_bcj(optarg));
 			break;
 
 		case OPT_ARM:
 			coder_add_filter(LZMA_FILTER_ARM,
 					options_bcj(optarg));
 			break;
 
 		case OPT_ARMTHUMB:
 			coder_add_filter(LZMA_FILTER_ARMTHUMB,
 					options_bcj(optarg));
 			break;
 
 		case OPT_ARM64:
 			coder_add_filter(LZMA_FILTER_ARM64,
 					options_bcj(optarg));
 			break;
 
 		case OPT_SPARC:
 			coder_add_filter(LZMA_FILTER_SPARC,
 					options_bcj(optarg));
 			break;
 
 		case OPT_DELTA:
 			coder_add_filter(LZMA_FILTER_DELTA,
 					options_delta(optarg));
 			break;
 
 		case OPT_LZMA1:
 			coder_add_filter(LZMA_FILTER_LZMA1,
 					options_lzma(optarg));
 			break;
 
 		case OPT_LZMA2:
 			coder_add_filter(LZMA_FILTER_LZMA2,
 					options_lzma(optarg));
 			break;
 
 		// Other
 
 		// --format
 		case 'F': {
 			// Just in case, support both "lzma" and "alone" since
 			// the latter was used for forward compatibility in
 			// LZMA Utils 4.32.x.
 			static const struct {
 				char str[8];
 				enum format_type format;
 			} types[] = {
 				{ "auto",   FORMAT_AUTO },
 				{ "xz",     FORMAT_XZ },
 				{ "lzma",   FORMAT_LZMA },
 				{ "alone",  FORMAT_LZMA },
 #ifdef HAVE_LZIP_DECODER
 				{ "lzip",   FORMAT_LZIP },
 #endif
 				{ "raw",    FORMAT_RAW },
 			};
 
 			size_t i = 0;
 			while (strcmp(types[i].str, optarg) != 0)
 				if (++i == ARRAY_SIZE(types))
 					message_fatal(_("%s: Unknown file "
 							"format type"),
 							optarg);
 
 			opt_format = types[i].format;
 			break;
 		}
 
 		// --check
 		case 'C': {
 			static const struct {
 				char str[8];
 				lzma_check check;
 			} types[] = {
 				{ "none",   LZMA_CHECK_NONE },
 				{ "crc32",  LZMA_CHECK_CRC32 },
 				{ "crc64",  LZMA_CHECK_CRC64 },
 				{ "sha256", LZMA_CHECK_SHA256 },
 			};
 
 			size_t i = 0;
 			while (strcmp(types[i].str, optarg) != 0) {
 				if (++i == ARRAY_SIZE(types))
 					message_fatal(_("%s: Unsupported "
 							"integrity "
 							"check type"), optarg);
 			}
 
 			// Use a separate check in case we are using different
 			// liblzma than what was used to compile us.
 			if (!lzma_check_is_supported(types[i].check))
 				message_fatal(_("%s: Unsupported integrity "
 						"check type"), optarg);
 
 			coder_set_check(types[i].check);
 			break;
 		}
 
 		case OPT_IGNORE_CHECK:
 			opt_ignore_check = true;
 			break;
 
 		case OPT_BLOCK_SIZE:
 			opt_block_size = str_to_uint64("block-size", optarg,
 					0, LZMA_VLI_MAX);
 			break;
 
 		case OPT_BLOCK_LIST: {
 			parse_block_list(optarg);
 			break;
 		}
 
 		case OPT_SINGLE_STREAM:
 			opt_single_stream = true;
 			break;
 
 		case OPT_NO_SPARSE:
 			io_no_sparse();
 			break;
 
 		case OPT_FILES:
 			args->files_delim = '\n';
 
 		// Fall through
 
 		case OPT_FILES0:
 			if (args->files_name != NULL)
 				message_fatal(_("Only one file can be "
 						"specified with `--files' "
 						"or `--files0'."));
 
 			if (optarg == NULL) {
 				args->files_name = stdin_filename;
 				args->files_file = stdin;
 			} else {
 				args->files_name = optarg;
 				args->files_file = fopen(optarg,
 						c == OPT_FILES ? "r" : "rb");
 				if (args->files_file == NULL)
 					message_fatal("%s: %s", optarg,
 							strerror(errno));
 			}
 
 			break;
 
 		case OPT_NO_ADJUST:
 			opt_auto_adjust = false;
 			break;
 
 		case OPT_FLUSH_TIMEOUT:
 			opt_flush_timeout = str_to_uint64("flush-timeout",
 					optarg, 0, UINT64_MAX);
 			break;
 
 		default:
 			message_try_help();
 			tuklib_exit(E_ERROR, E_ERROR, false);
 		}
 	}
 
 	return;
 }
 
 
 static void
 parse_environment(args_info *args, char *argv0, const char *varname)
 {
 	char *env = getenv(varname);
 	if (env == NULL)
 		return;
 
 	// We modify the string, so make a copy of it.
 	env = xstrdup(env);
 
 	// Calculate the number of arguments in env. argc stats at one
 	// to include space for the program name.
 	int argc = 1;
 	bool prev_was_space = true;
 	for (size_t i = 0; env[i] != '\0'; ++i) {
 		// NOTE: Cast to unsigned char is needed so that correct
 		// value gets passed to isspace(), which expects
 		// unsigned char cast to int. Casting to int is done
 		// automatically due to integer promotion, but we need to
 		// force char to unsigned char manually. Otherwise 8-bit
 		// characters would get promoted to wrong value if
 		// char is signed.
 		if (isspace((unsigned char)env[i])) {
 			prev_was_space = true;
 		} else if (prev_was_space) {
 			prev_was_space = false;
 
 			// Keep argc small enough to fit into a signed int
 			// and to keep it usable for memory allocation.
 			if (++argc == my_min(
 					INT_MAX, SIZE_MAX / sizeof(char *)))
 				message_fatal(_("The environment variable "
 						"%s contains too many "
 						"arguments"), varname);
 		}
 	}
 
 	// Allocate memory to hold pointers to the arguments. Add one to get
 	// space for the terminating NULL (if some systems happen to need it).
 	char **argv = xmalloc(((size_t)(argc) + 1) * sizeof(char *));
 	argv[0] = argv0;
 	argv[argc] = NULL;
 
 	// Go through the string again. Split the arguments using '\0'
 	// characters and add pointers to the resulting strings to argv.
 	argc = 1;
 	prev_was_space = true;
 	for (size_t i = 0; env[i] != '\0'; ++i) {
 		if (isspace((unsigned char)env[i])) {
 			prev_was_space = true;
 			env[i] = '\0';
 		} else if (prev_was_space) {
 			prev_was_space = false;
 			argv[argc++] = env + i;
 		}
 	}
 
 	// Parse the argument list we got from the environment. All non-option
 	// arguments i.e. filenames are ignored.
 	parse_real(args, argc, argv);
 
 	// Reset the state of the getopt_long() so that we can parse the
 	// command line options too. There are two incompatible ways to
 	// do it.
 #ifdef HAVE_OPTRESET
 	// BSD
 	optind = 1;
 	optreset = 1;
 #else
 	// GNU, Solaris
 	optind = 0;
 #endif
 
 	// We don't need the argument list from environment anymore.
 	free(argv);
 	free(env);
 
 	return;
 }
 
 
 extern void
 args_parse(args_info *args, int argc, char **argv)
 {
 	// Initialize those parts of *args that we need later.
 	args->files_name = NULL;
 	args->files_file = NULL;
 	args->files_delim = '\0';
 
 	// Check how we were called.
 	{
 		// Remove the leading path name, if any.
 		const char *name = strrchr(argv[0], '/');
 		if (name == NULL)
 			name = argv[0];
 		else
 			++name;
 
 		// NOTE: It's possible that name[0] is now '\0' if argv[0]
 		// is weird, but it doesn't matter here.
 
 		// Look for full command names instead of substrings like
 		// "un", "cat", and "lz" to reduce possibility of false
 		// positives when the programs have been renamed.
 		if (strstr(name, "xzcat") != NULL) {
 			opt_mode = MODE_DECOMPRESS;
 			opt_stdout = true;
 		} else if (strstr(name, "unxz") != NULL) {
 			opt_mode = MODE_DECOMPRESS;
 		} else if (strstr(name, "lzcat") != NULL) {
 			opt_format = FORMAT_LZMA;
 			opt_mode = MODE_DECOMPRESS;
 			opt_stdout = true;
 		} else if (strstr(name, "unlzma") != NULL) {
 			opt_format = FORMAT_LZMA;
 			opt_mode = MODE_DECOMPRESS;
 		} else if (strstr(name, "lzma") != NULL) {
 			opt_format = FORMAT_LZMA;
 		}
 	}
 
 	// First the flags from the environment
 	parse_environment(args, argv[0], "XZ_DEFAULTS");
 	parse_environment(args, argv[0], "XZ_OPT");
 
 	// Then from the command line
 	parse_real(args, argc, argv);
 
 	// If encoder or decoder support was omitted at build time,
 	// show an error now so that the rest of the code can rely on
 	// that whatever is in opt_mode is also supported.
 #ifndef HAVE_ENCODERS
 	if (opt_mode == MODE_COMPRESS)
 		message_fatal(_("Compression support was disabled "
 				"at build time"));
 #endif
 #ifndef HAVE_DECODERS
 	// Even MODE_LIST cannot work without decoder support so MODE_COMPRESS
 	// is the only valid choice.
 	if (opt_mode != MODE_COMPRESS)
 		message_fatal(_("Decompression support was disabled "
 				"at build time"));
 #endif
 
 #ifdef HAVE_LZIP_DECODER
 	if (opt_mode == MODE_COMPRESS && opt_format == FORMAT_LZIP)
 		message_fatal(_("Compression of lzip files (.lz) "
 				"is not supported"));
 #endif
 
 	// Never remove the source file when the destination is not on disk.
 	// In test mode the data is written nowhere, but setting opt_stdout
 	// will make the rest of the code behave well.
 	if (opt_stdout || opt_mode == MODE_TEST) {
 		opt_keep_original = true;
 		opt_stdout = true;
 	}
 
 	// When compressing, if no --format flag was used, or it
 	// was --format=auto, we compress to the .xz format.
 	if (opt_mode == MODE_COMPRESS && opt_format == FORMAT_AUTO)
 		opt_format = FORMAT_XZ;
 
 	// Set opt_block_list to NULL if we are not compressing to the .xz
 	// format. This option cannot be used outside of this case, and
 	// simplifies the implementation later.
 	if ((opt_mode != MODE_COMPRESS || opt_format != FORMAT_XZ)
 			&& opt_block_list != NULL) {
 		message(V_WARNING, _("--block-list is ignored unless "
 				"compressing to the .xz format"));
 		free(opt_block_list);
 		opt_block_list = NULL;
 	}
 
 	// Compression settings need to be validated (options themselves and
 	// their memory usage) when compressing to any file format. It has to
 	// be done also when uncompressing raw data, since for raw decoding
 	// the options given on the command line are used to know what kind
 	// of raw data we are supposed to decode.
 	if (opt_mode == MODE_COMPRESS || (opt_format == FORMAT_RAW
 			&& opt_mode != MODE_LIST))
 		coder_set_compression_settings();
 
 	// If raw format is used and a custom suffix is not provided,
 	// then only stdout mode can be used when compressing or decompressing.
 	if (opt_format == FORMAT_RAW && !suffix_is_set() && !opt_stdout
 			&& (opt_mode == MODE_COMPRESS
 				|| opt_mode == MODE_DECOMPRESS))
 		message_fatal(_("With --format=raw, --suffix=.SUF is "
 				"required unless writing to stdout"));
 
 	// If no filenames are given, use stdin.
 	if (argv[optind] == NULL && args->files_name == NULL) {
 		// We don't modify or free() the "-" constant. The caller
 		// modifies this so don't make the struct itself const.
 		static char *names_stdin[2] = { (char *)"-", NULL };
 		args->arg_names = names_stdin;
 		args->arg_count = 1;
 	} else {
 		// We got at least one filename from the command line, or
 		// --files or --files0 was specified.
 		args->arg_names = argv + optind;
 		args->arg_count = (unsigned int)(argc - optind);
 	}
 
 	return;
 }
 
 
 #ifndef NDEBUG
 extern void
 args_free(void)
 {
 	free(opt_block_list);
 	return;
 }
 #endif
diff --git a/src/xz/message.c b/src/xz/message.c
index b28bb63c..a888d29e 100644
--- a/src/xz/message.c
+++ b/src/xz/message.c
@@ -1,1160 +1,1190 @@
 ///////////////////////////////////////////////////////////////////////////////
 //
 /// \file       message.c
 /// \brief      Printing messages
 //
 //  Author:     Lasse Collin
 //
 //  This file has been put into the public domain.
 //  You can do whatever you want with this file.
 //
 ///////////////////////////////////////////////////////////////////////////////
 
 #include "private.h"
 
 #include <stdarg.h>
 
 
 /// Number of the current file
 static unsigned int files_pos = 0;
 
 /// Total number of input files; zero if unknown.
 static unsigned int files_total;
 
 /// Verbosity level
 static enum message_verbosity verbosity = V_WARNING;
 
 /// Filename which we will print with the verbose messages
 static const char *filename;
 
 /// True once the a filename has been printed to stderr as part of progress
 /// message. If automatic progress updating isn't enabled, this becomes true
 /// after the first progress message has been printed due to user sending
 /// SIGINFO, SIGUSR1, or SIGALRM. Once this variable is true, we will print
 /// an empty line before the next filename to make the output more readable.
 static bool first_filename_printed = false;
 
 /// This is set to true when we have printed the current filename to stderr
 /// as part of a progress message. This variable is useful only if not
 /// updating progress automatically: if user sends many SIGINFO, SIGUSR1, or
 /// SIGALRM signals, we won't print the name of the same file multiple times.
 static bool current_filename_printed = false;
 
 /// True if we should print progress indicator and update it automatically
 /// if also verbose >= V_VERBOSE.
 static bool progress_automatic;
 
 /// True if message_progress_start() has been called but
 /// message_progress_end() hasn't been called yet.
 static bool progress_started = false;
 
 /// This is true when a progress message was printed and the cursor is still
 /// on the same line with the progress message. In that case, a newline has
 /// to be printed before any error messages.
 static bool progress_active = false;
 
 /// Pointer to lzma_stream used to do the encoding or decoding.
 static lzma_stream *progress_strm;
 
 /// This is true if we are in passthru mode (not actually compressing or
 /// decompressing) and thus cannot use lzma_get_progress(progress_strm, ...).
 /// That is, we are using coder_passthru() in coder.c.
 static bool progress_is_from_passthru;
 
 /// Expected size of the input stream is needed to show completion percentage
 /// and estimate remaining time.
 static uint64_t expected_in_size;
 
 
 // Use alarm() and SIGALRM when they are supported. This has two minor
 // advantages over the alternative of polling gettimeofday():
 //  - It is possible for the user to send SIGINFO, SIGUSR1, or SIGALRM to
 //    get intermediate progress information even when --verbose wasn't used
 //    or stderr is not a terminal.
 //  - alarm() + SIGALRM seems to have slightly less overhead than polling
 //    gettimeofday().
 #ifdef SIGALRM
 
 const int message_progress_sigs[] = {
 	SIGALRM,
 #ifdef SIGINFO
 	SIGINFO,
 #endif
 #ifdef SIGUSR1
 	SIGUSR1,
 #endif
 	0
 };
 
 /// The signal handler for SIGALRM sets this to true. It is set back to false
 /// once the progress message has been updated.
 static volatile sig_atomic_t progress_needs_updating = false;
 
 /// Signal handler for SIGALRM
 static void
 progress_signal_handler(int sig lzma_attribute((__unused__)))
 {
 	progress_needs_updating = true;
 	return;
 }
 
 #else
 
 /// This is true when progress message printing is wanted. Using the same
 /// variable name as above to avoid some ifdefs.
 static bool progress_needs_updating = false;
 
 /// Elapsed time when the next progress message update should be done.
 static uint64_t progress_next_update;
 
 #endif
 
 
 extern void
 message_init(void)
 {
 	// If --verbose is used, we use a progress indicator if and only
 	// if stderr is a terminal. If stderr is not a terminal, we print
 	// verbose information only after finishing the file. As a special
 	// exception, even if --verbose was not used, user can send SIGALRM
 	// to make us print progress information once without automatic
 	// updating.
 	progress_automatic = isatty(STDERR_FILENO);
 
 	// Commented out because COLUMNS is rarely exported to environment.
 	// Most users have at least 80 columns anyway, let's think something
 	// fancy here if enough people complain.
 /*
 	if (progress_automatic) {
 		// stderr is a terminal. Check the COLUMNS environment
 		// variable to see if the terminal is wide enough. If COLUMNS
 		// doesn't exist or it has some unparsable value, we assume
 		// that the terminal is wide enough.
 		const char *columns_str = getenv("COLUMNS");
 		if (columns_str != NULL) {
 			char *endptr;
 			const long columns = strtol(columns_str, &endptr, 10);
 			if (*endptr != '\0' || columns < 80)
 				progress_automatic = false;
 		}
 	}
 */
 
 #ifdef SIGALRM
 	// Establish the signal handlers which set a flag to tell us that
 	// progress info should be updated.
 	struct sigaction sa;
 	sigemptyset(&sa.sa_mask);
 	sa.sa_flags = 0;
 	sa.sa_handler = &progress_signal_handler;
 
 	for (size_t i = 0; message_progress_sigs[i] != 0; ++i)
 		if (sigaction(message_progress_sigs[i], &sa, NULL))
 			message_signal_handler();
 #endif
 
 	return;
 }
 
 
 extern void
 message_verbosity_increase(void)
 {
 	if (verbosity < V_DEBUG)
 		++verbosity;
 
 	return;
 }
 
 
 extern void
 message_verbosity_decrease(void)
 {
 	if (verbosity > V_SILENT)
 		--verbosity;
 
 	return;
 }
 
 
 extern enum message_verbosity
 message_verbosity_get(void)
 {
 	return verbosity;
 }
 
 
 extern void
 message_set_files(unsigned int files)
 {
 	files_total = files;
 	return;
 }
 
 
 /// Prints the name of the current file if it hasn't been printed already,
 /// except if we are processing exactly one stream from stdin to stdout.
 /// I think it looks nicer to not print "(stdin)" when --verbose is used
 /// in a pipe and no other files are processed.
 static void
 print_filename(void)
 {
 	if (!opt_robot && (files_total != 1 || filename != stdin_filename)) {
 		signals_block();
 
 		FILE *file = opt_mode == MODE_LIST ? stdout : stderr;
 
 		// If a file was already processed, put an empty line
 		// before the next filename to improve readability.
 		if (first_filename_printed)
 			fputc('\n', file);
 
 		first_filename_printed = true;
 		current_filename_printed = true;
 
 		// If we don't know how many files there will be due
 		// to usage of --files or --files0.
 		if (files_total == 0)
 			fprintf(file, "%s (%u)\n", filename,
 					files_pos);
 		else
 			fprintf(file, "%s (%u/%u)\n", filename,
 					files_pos, files_total);
 
 		signals_unblock();
 	}
 
 	return;
 }
 
 
 extern void
 message_filename(const char *src_name)
 {
 	// Start numbering the files starting from one.
 	++files_pos;
 	filename = src_name;
 
 	if (verbosity >= V_VERBOSE
 			&& (progress_automatic || opt_mode == MODE_LIST))
 		print_filename();
 	else
 		current_filename_printed = false;
 
 	return;
 }
 
 
 extern void
 message_progress_start(lzma_stream *strm, bool is_passthru, uint64_t in_size)
 {
 	// Store the pointer to the lzma_stream used to do the coding.
 	// It is needed to find out the position in the stream.
 	progress_strm = strm;
 	progress_is_from_passthru = is_passthru;
 
 	// Store the expected size of the file. If we aren't printing any
 	// statistics, then is will be unused. But since it is possible
 	// that the user sends us a signal to show statistics, we need
 	// to have it available anyway.
 	expected_in_size = in_size;
 
 	// Indicate that progress info may need to be printed before
 	// printing error messages.
 	progress_started = true;
 
 	// If progress indicator is wanted, print the filename and possibly
 	// the file count now.
 	if (verbosity >= V_VERBOSE && progress_automatic) {
 		// Start the timer to display the first progress message
 		// after one second. An alternative would be to show the
 		// first message almost immediately, but delaying by one
 		// second looks better to me, since extremely early
 		// progress info is pretty much useless.
 #ifdef SIGALRM
 		// First disable a possibly existing alarm.
 		alarm(0);
 		progress_needs_updating = false;
 		alarm(1);
 #else
 		progress_needs_updating = true;
 		progress_next_update = 1000;
 #endif
 	}
 
 	return;
 }
 
 
 /// Make the string indicating completion percentage.
 static const char *
 progress_percentage(uint64_t in_pos)
 {
 	// If the size of the input file is unknown or the size told us is
 	// clearly wrong since we have processed more data than the alleged
 	// size of the file, show a static string indicating that we have
 	// no idea of the completion percentage.
 	if (expected_in_size == 0 || in_pos > expected_in_size)
 		return "--- %";
 
 	// Never show 100.0 % before we actually are finished.
 	double percentage = (double)(in_pos) / (double)(expected_in_size)
 			* 99.9;
 
 	// Use big enough buffer to hold e.g. a multibyte decimal point.
 	static char buf[16];
 	snprintf(buf, sizeof(buf), "%.1f %%", percentage);
 
 	return buf;
 }
 
 
 /// Make the string containing the amount of input processed, amount of
 /// output produced, and the compression ratio.
 static const char *
 progress_sizes(uint64_t compressed_pos, uint64_t uncompressed_pos, bool final)
 {
 	// Use big enough buffer to hold e.g. a multibyte thousand separators.
 	static char buf[128];
 	char *pos = buf;
 	size_t left = sizeof(buf);
 
 	// Print the sizes. If this the final message, use more reasonable
 	// units than MiB if the file was small.
 	const enum nicestr_unit unit_min = final ? NICESTR_B : NICESTR_MIB;
 	my_snprintf(&pos, &left, "%s / %s",
 			uint64_to_nicestr(compressed_pos,
 				unit_min, NICESTR_TIB, false, 0),
 			uint64_to_nicestr(uncompressed_pos,
 				unit_min, NICESTR_TIB, false, 1));
 
 	// Avoid division by zero. If we cannot calculate the ratio, set
 	// it to some nice number greater than 10.0 so that it gets caught
 	// in the next if-clause.
 	const double ratio = uncompressed_pos > 0
 			? (double)(compressed_pos) / (double)(uncompressed_pos)
 			: 16.0;
 
 	// If the ratio is very bad, just indicate that it is greater than
 	// 9.999. This way the length of the ratio field stays fixed.
 	if (ratio > 9.999)
 		snprintf(pos, left, " > %.3f", 9.999);
 	else
 		snprintf(pos, left, " = %.3f", ratio);
 
 	return buf;
 }
 
 
 /// Make the string containing the processing speed of uncompressed data.
 static const char *
 progress_speed(uint64_t uncompressed_pos, uint64_t elapsed)
 {
 	// Don't print the speed immediately, since the early values look
 	// somewhat random.
 	if (elapsed < 3000)
 		return "";
 
 	// The first character of KiB/s, MiB/s, or GiB/s:
 	static const char unit[] = { 'K', 'M', 'G' };
 
 	size_t unit_index = 0;
 
 	// Calculate the speed as KiB/s.
 	double speed = (double)(uncompressed_pos)
 			/ ((double)(elapsed) * (1024.0 / 1000.0));
 
 	// Adjust the unit of the speed if needed.
 	while (speed > 999.0) {
 		speed /= 1024.0;
 		if (++unit_index == ARRAY_SIZE(unit))
 			return ""; // Way too fast ;-)
 	}
 
 	// Use decimal point only if the number is small. Examples:
 	//  - 0.1 KiB/s
 	//  - 9.9 KiB/s
 	//  - 99 KiB/s
 	//  - 999 KiB/s
 	// Use big enough buffer to hold e.g. a multibyte decimal point.
 	static char buf[16];
 	snprintf(buf, sizeof(buf), "%.*f %ciB/s",
 			speed > 9.9 ? 0 : 1, speed, unit[unit_index]);
 	return buf;
 }
 
 
 /// Make a string indicating elapsed time. The format is either
 /// M:SS or H:MM:SS depending on if the time is an hour or more.
 static const char *
 progress_time(uint64_t mseconds)
 {
 	// 9999 hours = 416 days
 	static char buf[sizeof("9999:59:59")];
 
 	// 32-bit variable is enough for elapsed time (136 years).
 	uint32_t seconds = (uint32_t)(mseconds / 1000);
 
 	// Don't show anything if the time is zero or ridiculously big.
 	if (seconds == 0 || seconds > ((9999 * 60) + 59) * 60 + 59)
 		return "";
 
 	uint32_t minutes = seconds / 60;
 	seconds %= 60;
 
 	if (minutes >= 60) {
 		const uint32_t hours = minutes / 60;
 		minutes %= 60;
 		snprintf(buf, sizeof(buf),
 				"%" PRIu32 ":%02" PRIu32 ":%02" PRIu32,
 				hours, minutes, seconds);
 	} else {
 		snprintf(buf, sizeof(buf), "%" PRIu32 ":%02" PRIu32,
 				minutes, seconds);
 	}
 
 	return buf;
 }
 
 
 /// Return a string containing estimated remaining time when
 /// reasonably possible.
 static const char *
 progress_remaining(uint64_t in_pos, uint64_t elapsed)
 {
 	// Don't show the estimated remaining time when it wouldn't
 	// make sense:
 	//  - Input size is unknown.
 	//  - Input has grown bigger since we started (de)compressing.
 	//  - We haven't processed much data yet, so estimate would be
 	//    too inaccurate.
 	//  - Only a few seconds has passed since we started (de)compressing,
 	//    so estimate would be too inaccurate.
 	if (expected_in_size == 0 || in_pos > expected_in_size
 			|| in_pos < (UINT64_C(1) << 19) || elapsed < 8000)
 		return "";
 
 	// Calculate the estimate. Don't give an estimate of zero seconds,
 	// since it is possible that all the input has been already passed
 	// to the library, but there is still quite a bit of output pending.
 	uint32_t remaining = (uint32_t)((double)(expected_in_size - in_pos)
 			* ((double)(elapsed) / 1000.0) / (double)(in_pos));
 	if (remaining < 1)
 		remaining = 1;
 
 	static char buf[sizeof("9 h 55 min")];
 
 	// Select appropriate precision for the estimated remaining time.
 	if (remaining <= 10) {
 		// A maximum of 10 seconds remaining.
 		// Show the number of seconds as is.
 		snprintf(buf, sizeof(buf), "%" PRIu32 " s", remaining);
 
 	} else if (remaining <= 50) {
 		// A maximum of 50 seconds remaining.
 		// Round up to the next multiple of five seconds.
 		remaining = (remaining + 4) / 5 * 5;
 		snprintf(buf, sizeof(buf), "%" PRIu32 " s", remaining);
 
 	} else if (remaining <= 590) {
 		// A maximum of 9 minutes and 50 seconds remaining.
 		// Round up to the next multiple of ten seconds.
 		remaining = (remaining + 9) / 10 * 10;
 		snprintf(buf, sizeof(buf), "%" PRIu32 " min %" PRIu32 " s",
 				remaining / 60, remaining % 60);
 
 	} else if (remaining <= 59 * 60) {
 		// A maximum of 59 minutes remaining.
 		// Round up to the next multiple of a minute.
 		remaining = (remaining + 59) / 60;
 		snprintf(buf, sizeof(buf), "%" PRIu32 " min", remaining);
 
 	} else if (remaining <= 9 * 3600 + 50 * 60) {
 		// A maximum of 9 hours and 50 minutes left.
 		// Round up to the next multiple of ten minutes.
 		remaining = (remaining + 599) / 600 * 10;
 		snprintf(buf, sizeof(buf), "%" PRIu32 " h %" PRIu32 " min",
 				remaining / 60, remaining % 60);
 
 	} else if (remaining <= 23 * 3600) {
 		// A maximum of 23 hours remaining.
 		// Round up to the next multiple of an hour.
 		remaining = (remaining + 3599) / 3600;
 		snprintf(buf, sizeof(buf), "%" PRIu32 " h", remaining);
 
 	} else if (remaining <= 9 * 24 * 3600 + 23 * 3600) {
 		// A maximum of 9 days and 23 hours remaining.
 		// Round up to the next multiple of an hour.
 		remaining = (remaining + 3599) / 3600;
 		snprintf(buf, sizeof(buf), "%" PRIu32 " d %" PRIu32 " h",
 				remaining / 24, remaining % 24);
 
 	} else if (remaining <= 999 * 24 * 3600) {
 		// A maximum of 999 days remaining. ;-)
 		// Round up to the next multiple of a day.
 		remaining = (remaining + 24 * 3600 - 1) / (24 * 3600);
 		snprintf(buf, sizeof(buf), "%" PRIu32 " d", remaining);
 
 	} else {
 		// The estimated remaining time is too big. Don't show it.
 		return "";
 	}
 
 	return buf;
 }
 
 
 /// Get how much uncompressed and compressed data has been processed.
 static void
 progress_pos(uint64_t *in_pos,
 		uint64_t *compressed_pos, uint64_t *uncompressed_pos)
 {
 	uint64_t out_pos;
 	if (progress_is_from_passthru) {
 		// In passthru mode the progress info is in total_in/out but
 		// the *progress_strm itself isn't initialized and thus we
 		// cannot use lzma_get_progress().
 		*in_pos = progress_strm->total_in;
 		out_pos = progress_strm->total_out;
 	} else {
 		lzma_get_progress(progress_strm, in_pos, &out_pos);
 	}
 
 	// It cannot have processed more input than it has been given.
 	assert(*in_pos <= progress_strm->total_in);
 
 	// It cannot have produced more output than it claims to have ready.
 	assert(out_pos >= progress_strm->total_out);
 
 	if (opt_mode == MODE_COMPRESS) {
 		*compressed_pos = out_pos;
 		*uncompressed_pos = *in_pos;
 	} else {
 		*compressed_pos = *in_pos;
 		*uncompressed_pos = out_pos;
 	}
 
 	return;
 }
 
 
 extern void
 message_progress_update(void)
 {
 	if (!progress_needs_updating)
 		return;
 
 	// Calculate how long we have been processing this file.
 	const uint64_t elapsed = mytime_get_elapsed();
 
 #ifndef SIGALRM
 	if (progress_next_update > elapsed)
 		return;
 
 	progress_next_update = elapsed + 1000;
 #endif
 
 	// Get our current position in the stream.
 	uint64_t in_pos;
 	uint64_t compressed_pos;
 	uint64_t uncompressed_pos;
 	progress_pos(&in_pos, &compressed_pos, &uncompressed_pos);
 
 	// Block signals so that fprintf() doesn't get interrupted.
 	signals_block();
 
 	// Print the filename if it hasn't been printed yet.
 	if (!current_filename_printed)
 		print_filename();
 
 	// Print the actual progress message. The idea is that there is at
 	// least three spaces between the fields in typical situations, but
 	// even in rare situations there is at least one space.
 	const char *cols[5] = {
 		progress_percentage(in_pos),
 		progress_sizes(compressed_pos, uncompressed_pos, false),
 		progress_speed(uncompressed_pos, elapsed),
 		progress_time(elapsed),
 		progress_remaining(in_pos, elapsed),
 	};
 	fprintf(stderr, "\r %*s %*s   %*s %10s   %10s\r",
 			tuklib_mbstr_fw(cols[0], 6), cols[0],
 			tuklib_mbstr_fw(cols[1], 35), cols[1],
 			tuklib_mbstr_fw(cols[2], 9), cols[2],
 			cols[3],
 			cols[4]);
 
 #ifdef SIGALRM
 	// Updating the progress info was finished. Reset
 	// progress_needs_updating to wait for the next SIGALRM.
 	//
 	// NOTE: This has to be done before alarm(1) or with (very) bad
 	// luck we could be setting this to false after the alarm has already
 	// been triggered.
 	progress_needs_updating = false;
 
 	if (verbosity >= V_VERBOSE && progress_automatic) {
 		// Mark that the progress indicator is active, so if an error
 		// occurs, the error message gets printed cleanly.
 		progress_active = true;
 
 		// Restart the timer so that progress_needs_updating gets
 		// set to true after about one second.
 		alarm(1);
 	} else {
 		// The progress message was printed because user had sent us
 		// SIGALRM. In this case, each progress message is printed
 		// on its own line.
 		fputc('\n', stderr);
 	}
 #else
 	// When SIGALRM isn't supported and we get here, it's always due to
 	// automatic progress update. We set progress_active here too like
 	// described above.
 	assert(verbosity >= V_VERBOSE);
 	assert(progress_automatic);
 	progress_active = true;
 #endif
 
 	signals_unblock();
 
 	return;
 }
 
 
 static void
 progress_flush(bool finished)
 {
 	if (!progress_started || verbosity < V_VERBOSE)
 		return;
 
 	uint64_t in_pos;
 	uint64_t compressed_pos;
 	uint64_t uncompressed_pos;
 	progress_pos(&in_pos, &compressed_pos, &uncompressed_pos);
 
 	// Avoid printing intermediate progress info if some error occurs
 	// in the beginning of the stream. (If something goes wrong later in
 	// the stream, it is sometimes useful to tell the user where the
 	// error approximately occurred, especially if the error occurs
 	// after a time-consuming operation.)
 	if (!finished && !progress_active
 			&& (compressed_pos == 0 || uncompressed_pos == 0))
 		return;
 
 	progress_active = false;
 
 	const uint64_t elapsed = mytime_get_elapsed();
 
 	signals_block();
 
 	// When using the auto-updating progress indicator, the final
 	// statistics are printed in the same format as the progress
 	// indicator itself.
 	if (progress_automatic) {
 		const char *cols[5] = {
 			finished ? "100 %" : progress_percentage(in_pos),
 			progress_sizes(compressed_pos, uncompressed_pos, true),
 			progress_speed(uncompressed_pos, elapsed),
 			progress_time(elapsed),
 			finished ? "" : progress_remaining(in_pos, elapsed),
 		};
 		fprintf(stderr, "\r %*s %*s   %*s %10s   %10s\n",
 				tuklib_mbstr_fw(cols[0], 6), cols[0],
 				tuklib_mbstr_fw(cols[1], 35), cols[1],
 				tuklib_mbstr_fw(cols[2], 9), cols[2],
 				cols[3],
 				cols[4]);
 	} else {
 		// The filename is always printed.
 		fprintf(stderr, "%s: ", filename);
 
 		// Percentage is printed only if we didn't finish yet.
 		if (!finished) {
 			// Don't print the percentage when it isn't known
 			// (starts with a dash).
 			const char *percentage = progress_percentage(in_pos);
 			if (percentage[0] != '-')
 				fprintf(stderr, "%s, ", percentage);
 		}
 
 		// Size information is always printed.
 		fprintf(stderr, "%s", progress_sizes(
 				compressed_pos, uncompressed_pos, true));
 
 		// The speed and elapsed time aren't always shown.
 		const char *speed = progress_speed(uncompressed_pos, elapsed);
 		if (speed[0] != '\0')
 			fprintf(stderr, ", %s", speed);
 
 		const char *elapsed_str = progress_time(elapsed);
 		if (elapsed_str[0] != '\0')
 			fprintf(stderr, ", %s", elapsed_str);
 
 		fputc('\n', stderr);
 	}
 
 	signals_unblock();
 
 	return;
 }
 
 
 extern void
 message_progress_end(bool success)
 {
 	assert(progress_started);
 	progress_flush(success);
 	progress_started = false;
 	return;
 }
 
 
 static void
 vmessage(enum message_verbosity v, const char *fmt, va_list ap)
 {
 	if (v <= verbosity) {
 		signals_block();
 
 		progress_flush(false);
 
 		// TRANSLATORS: This is the program name in the beginning
 		// of the line in messages. Usually it becomes "xz: ".
 		// This is a translatable string because French needs
 		// a space before a colon.
 		fprintf(stderr, _("%s: "), progname);
 
 #ifdef __clang__
 #	pragma GCC diagnostic push
 #	pragma GCC diagnostic ignored "-Wformat-nonliteral"
 #endif
 		vfprintf(stderr, fmt, ap);
 #ifdef __clang__
 #	pragma GCC diagnostic pop
 #endif
 
 		fputc('\n', stderr);
 
 		signals_unblock();
 	}
 
 	return;
 }
 
 
 extern void
 message(enum message_verbosity v, const char *fmt, ...)
 {
 	va_list ap;
 	va_start(ap, fmt);
 	vmessage(v, fmt, ap);
 	va_end(ap);
 	return;
 }
 
 
 extern void
 message_warning(const char *fmt, ...)
 {
 	va_list ap;
 	va_start(ap, fmt);
 	vmessage(V_WARNING, fmt, ap);
 	va_end(ap);
 
 	set_exit_status(E_WARNING);
 	return;
 }
 
 
 extern void
 message_error(const char *fmt, ...)
 {
 	va_list ap;
 	va_start(ap, fmt);
 	vmessage(V_ERROR, fmt, ap);
 	va_end(ap);
 
 	set_exit_status(E_ERROR);
 	return;
 }
 
 
 extern void
 message_fatal(const char *fmt, ...)
 {
 	va_list ap;
 	va_start(ap, fmt);
 	vmessage(V_ERROR, fmt, ap);
 	va_end(ap);
 
 	tuklib_exit(E_ERROR, E_ERROR, false);
 }
 
 
 extern void
 message_bug(void)
 {
 	message_fatal(_("Internal error (bug)"));
 }
 
 
 extern void
 message_signal_handler(void)
 {
 	message_fatal(_("Cannot establish signal handlers"));
 }
 
 
 extern const char *
 message_strm(lzma_ret code)
 {
 	switch (code) {
 	case LZMA_NO_CHECK:
 		return _("No integrity check; not verifying file integrity");
 
 	case LZMA_UNSUPPORTED_CHECK:
 		return _("Unsupported type of integrity check; "
 				"not verifying file integrity");
 
 	case LZMA_MEM_ERROR:
 		return strerror(ENOMEM);
 
 	case LZMA_MEMLIMIT_ERROR:
 		return _("Memory usage limit reached");
 
 	case LZMA_FORMAT_ERROR:
 		return _("File format not recognized");
 
 	case LZMA_OPTIONS_ERROR:
 		return _("Unsupported options");
 
 	case LZMA_DATA_ERROR:
 		return _("Compressed data is corrupt");
 
 	case LZMA_BUF_ERROR:
 		return _("Unexpected end of input");
 
 	case LZMA_OK:
 	case LZMA_STREAM_END:
 	case LZMA_GET_CHECK:
 	case LZMA_PROG_ERROR:
 	case LZMA_SEEK_NEEDED:
 	case LZMA_RET_INTERNAL1:
 	case LZMA_RET_INTERNAL2:
 	case LZMA_RET_INTERNAL3:
 	case LZMA_RET_INTERNAL4:
 	case LZMA_RET_INTERNAL5:
 	case LZMA_RET_INTERNAL6:
 	case LZMA_RET_INTERNAL7:
 	case LZMA_RET_INTERNAL8:
 		// Without "default", compiler will warn if new constants
 		// are added to lzma_ret, it is not too easy to forget to
 		// add the new constants to this function.
 		break;
 	}
 
 	return _("Internal error (bug)");
 }
 
 
 extern void
 message_mem_needed(enum message_verbosity v, uint64_t memusage)
 {
 	if (v > verbosity)
 		return;
 
 	// Convert memusage to MiB, rounding up to the next full MiB.
 	// This way the user can always use the displayed usage as
 	// the new memory usage limit. (If we rounded to the nearest,
 	// the user might need to +1 MiB to get high enough limit.)
 	memusage = round_up_to_mib(memusage);
 
 	uint64_t memlimit = hardware_memlimit_get(opt_mode);
 
 	// Handle the case when there is no memory usage limit.
 	// This way we don't print a weird message with a huge number.
 	if (memlimit == UINT64_MAX) {
 		message(v, _("%s MiB of memory is required. "
 				"The limiter is disabled."),
 				uint64_to_str(memusage, 0));
 		return;
 	}
 
 	// With US-ASCII:
 	// 2^64 with thousand separators + " MiB" suffix + '\0' = 26 + 4 + 1
 	// But there may be multibyte chars so reserve enough space.
 	char memlimitstr[128];
 
 	// Show the memory usage limit as MiB unless it is less than 1 MiB.
 	// This way it's easy to notice errors where one has typed
 	// --memory=123 instead of --memory=123MiB.
 	if (memlimit < (UINT32_C(1) << 20)) {
 		snprintf(memlimitstr, sizeof(memlimitstr), "%s B",
 				uint64_to_str(memlimit, 1));
 	} else {
 		// Round up just like with memusage. If this function is
 		// called for informational purposes (to just show the
 		// current usage and limit), we should never show that
 		// the usage is higher than the limit, which would give
 		// a false impression that the memory usage limit isn't
 		// properly enforced.
 		snprintf(memlimitstr, sizeof(memlimitstr), "%s MiB",
 				uint64_to_str(round_up_to_mib(memlimit), 1));
 	}
 
 	message(v, _("%s MiB of memory is required. The limit is %s."),
 			uint64_to_str(memusage, 0), memlimitstr);
 
 	return;
 }
 
 
 extern void
 message_filters_show(enum message_verbosity v, const lzma_filter *filters)
 {
 	if (v > verbosity)
 		return;
 
 	char *buf;
 	const lzma_ret ret = lzma_str_from_filters(&buf, filters,
 			LZMA_STR_ENCODER | LZMA_STR_GETOPT_LONG, NULL);
 	if (ret != LZMA_OK)
 		message_fatal("%s", message_strm(ret));
 
 	fprintf(stderr, _("%s: Filter chain: %s\n"), progname, buf);
 	free(buf);
 	return;
 }
 
 
 extern void
 message_try_help(void)
 {
 	// Print this with V_WARNING instead of V_ERROR to prevent it from
 	// showing up when --quiet has been specified.
 	message(V_WARNING, _("Try `%s --help' for more information."),
 			progname);
 	return;
 }
 
 
 extern void
 message_version(void)
 {
 	// It is possible that liblzma version is different than the command
 	// line tool version, so print both.
 	if (opt_robot) {
 		printf("XZ_VERSION=%" PRIu32 "\nLIBLZMA_VERSION=%" PRIu32 "\n",
 				LZMA_VERSION, lzma_version_number());
 	} else {
 		printf("xz (" PACKAGE_NAME ") " LZMA_VERSION_STRING "\n");
 		printf("liblzma %s\n", lzma_version_string());
 	}
 
 	tuklib_exit(E_SUCCESS, E_ERROR, verbosity != V_SILENT);
 }
 
 
 extern void
 message_help(bool long_help)
 {
 	printf(_("Usage: %s [OPTION]... [FILE]...\n"
 			"Compress or decompress FILEs in the .xz format.\n\n"),
 			progname);
 
 	// NOTE: The short help doesn't currently have options that
 	// take arguments.
 	if (long_help)
 		puts(_("Mandatory arguments to long options are mandatory "
 				"for short options too.\n"));
 
 	if (long_help)
 		puts(_(" Operation mode:\n"));
 
 	puts(_(
 "  -z, --compress      force compression\n"
 "  -d, --decompress    force decompression\n"
 "  -t, --test          test compressed file integrity\n"
 "  -l, --list          list information about .xz files"));
 
 	if (long_help)
 		puts(_("\n Operation modifiers:\n"));
 
 	puts(_(
 "  -k, --keep          keep (don't delete) input files\n"
 "  -f, --force         force overwrite of output file and (de)compress links\n"
 "  -c, --stdout        write to standard output and don't delete input files"));
 	// NOTE: --to-stdout isn't included above because it's not
 	// the recommended spelling. It was copied from gzip but other
 	// compressors with gzip-like syntax don't support it.
 
 	if (long_help) {
 		puts(_(
 "      --single-stream decompress only the first stream, and silently\n"
 "                      ignore possible remaining input data"));
 		puts(_(
 "      --no-sparse     do not create sparse files when decompressing\n"
 "  -S, --suffix=.SUF   use the suffix `.SUF' on compressed files\n"
 "      --files[=FILE]  read filenames to process from FILE; if FILE is\n"
 "                      omitted, filenames are read from the standard input;\n"
 "                      filenames must be terminated with the newline character\n"
 "      --files0[=FILE] like --files but use the null character as terminator"));
 	}
 
 	if (long_help) {
 		puts(_("\n Basic file format and compression options:\n"));
 		puts(_(
 "  -F, --format=FMT    file format to encode or decode; possible values are\n"
 "                      `auto' (default), `xz', `lzma', `lzip', and `raw'\n"
 "  -C, --check=CHECK   integrity check type: `none' (use with caution),\n"
 "                      `crc32', `crc64' (default), or `sha256'"));
 		puts(_(
 "      --ignore-check  don't verify the integrity check when decompressing"));
 	}
 
 	puts(_(
 "  -0 ... -9           compression preset; default is 6; take compressor *and*\n"
 "                      decompressor memory usage into account before using 7-9!"));
 
 	puts(_(
 "  -e, --extreme       try to improve compression ratio by using more CPU time;\n"
 "                      does not affect decompressor memory requirements"));
 
 	puts(_(
 "  -T, --threads=NUM   use at most NUM threads; the default is 1; set to 0\n"
 "                      to use as many threads as there are processor cores"));
 
 	if (long_help) {
 		puts(_(
 "      --block-size=SIZE\n"
 "                      start a new .xz block after every SIZE bytes of input;\n"
 "                      use this to set the block size for threaded compression"));
 		puts(_(
 "      --block-list=BLOCKS\n"
 "                      start a new .xz block after the given comma-separated\n"
 "                      intervals of uncompressed data; optionally, specify a\n"
 "                      filter chain number (0-9) followed by a `:' before the\n"
 "                      uncompressed data size"));
 		puts(_(
 "      --flush-timeout=TIMEOUT\n"
 "                      when compressing, if more than TIMEOUT milliseconds has\n"
 "                      passed since the previous flush and reading more input\n"
 "                      would block, all pending data is flushed out"
 		));
 		puts(_( // xgettext:no-c-format
 "      --memlimit-compress=LIMIT\n"
 "      --memlimit-decompress=LIMIT\n"
 "      --memlimit-mt-decompress=LIMIT\n"
 "  -M, --memlimit=LIMIT\n"
 "                      set memory usage limit for compression, decompression,\n"
 "                      threaded decompression, or all of these; LIMIT is in\n"
 "                      bytes, % of RAM, or 0 for defaults"));
 
 		puts(_(
 "      --no-adjust     if compression settings exceed the memory usage limit,\n"
 "                      give an error instead of adjusting the settings downwards"));
 	}
 
 	if (long_help) {
 		puts(_(
 "\n Custom filter chain for compression (alternative for using presets):"));
 
 		puts(_(
 "\n"
 "  --filters=FILTERS   set the filter chain using the liblzma filter string\n"
 "                      syntax; use --filters-help for more information"
 		));
 
 		puts(_(
 "  --filters1=FILTERS ... --filters9=FILTERS\n"
 "                      set additional filter chains using the liblzma filter\n"
 "                      string syntax to use with --block-list"
 		));
 
+		puts(_(
+"  --filters-help      display more information about the liblzma filter string\n"
+"                      syntax and exit."
+		));
+
 #if defined(HAVE_ENCODER_LZMA1) || defined(HAVE_DECODER_LZMA1) \
 		|| defined(HAVE_ENCODER_LZMA2) || defined(HAVE_DECODER_LZMA2)
 		// TRANSLATORS: The word "literal" in "literal context bits"
 		// means how many "context bits" to use when encoding
 		// literals. A literal is a single 8-bit byte. It doesn't
 		// mean "literally" here.
 		puts(_(
 "\n"
 "  --lzma1[=OPTS]      LZMA1 or LZMA2; OPTS is a comma-separated list of zero or\n"
 "  --lzma2[=OPTS]      more of the following options (valid values; default):\n"
 "                        preset=PRE reset options to a preset (0-9[e])\n"
 "                        dict=NUM   dictionary size (4KiB - 1536MiB; 8MiB)\n"
 "                        lc=NUM     number of literal context bits (0-4; 3)\n"
 "                        lp=NUM     number of literal position bits (0-4; 0)\n"
 "                        pb=NUM     number of position bits (0-4; 2)\n"
 "                        mode=MODE  compression mode (fast, normal; normal)\n"
 "                        nice=NUM   nice length of a match (2-273; 64)\n"
 "                        mf=NAME    match finder (hc3, hc4, bt2, bt3, bt4; bt4)\n"
 "                        depth=NUM  maximum search depth; 0=automatic (default)"));
 #endif
 
 		puts(_(
 "\n"
 "  --x86[=OPTS]        x86 BCJ filter (32-bit and 64-bit)\n"
 "  --arm[=OPTS]        ARM BCJ filter\n"
 "  --armthumb[=OPTS]   ARM-Thumb BCJ filter\n"
 "  --arm64[=OPTS]      ARM64 BCJ filter\n"
 "  --powerpc[=OPTS]    PowerPC BCJ filter (big endian only)\n"
 "  --ia64[=OPTS]       IA-64 (Itanium) BCJ filter\n"
 "  --sparc[=OPTS]      SPARC BCJ filter\n"
 "                      Valid OPTS for all BCJ filters:\n"
 "                        start=NUM  start offset for conversions (default=0)"));
 
 #if defined(HAVE_ENCODER_DELTA) || defined(HAVE_DECODER_DELTA)
 		puts(_(
 "\n"
 "  --delta[=OPTS]      Delta filter; valid OPTS (valid values; default):\n"
 "                        dist=NUM   distance between bytes being subtracted\n"
 "                                   from each other (1-256; 1)"));
 #endif
 	}
 
 	if (long_help)
 		puts(_("\n Other options:\n"));
 
 	puts(_(
 "  -q, --quiet         suppress warnings; specify twice to suppress errors too\n"
 "  -v, --verbose       be verbose; specify twice for even more verbose"));
 
 	if (long_help) {
 		puts(_(
 "  -Q, --no-warn       make warnings not affect the exit status"));
 		puts(_(
 "      --robot         use machine-parsable messages (useful for scripts)"));
 		puts("");
 		puts(_(
 "      --info-memory   display the total amount of RAM and the currently active\n"
 "                      memory usage limits, and exit"));
 		puts(_(
 "  -h, --help          display the short help (lists only the basic options)\n"
 "  -H, --long-help     display this long help and exit"));
 	} else {
 		puts(_(
 "  -h, --help          display this short help and exit\n"
 "  -H, --long-help     display the long help (lists also the advanced options)"));
 	}
 
 	puts(_(
 "  -V, --version       display the version number and exit"));
 
 	puts(_("\nWith no FILE, or when FILE is -, read standard input.\n"));
 
 	// TRANSLATORS: This message indicates the bug reporting address
 	// for this package. Please add _another line_ saying
 	// "Report translation bugs to <...>\n" with the email or WWW
 	// address for translation bugs. Thanks.
 	printf(_("Report bugs to <%s> (in English or Finnish).\n"),
 			PACKAGE_BUGREPORT);
 	printf(_("%s home page: <%s>\n"), PACKAGE_NAME, PACKAGE_URL);
 
 #if LZMA_VERSION_STABILITY != LZMA_VERSION_STABILITY_STABLE
 	puts(_(
 "THIS IS A DEVELOPMENT VERSION NOT INTENDED FOR PRODUCTION USE."));
 #endif
 
 	tuklib_exit(E_SUCCESS, E_ERROR, verbosity != V_SILENT);
 }
+
+
+extern void
+message_filters_help(void)
+{
+	char *encoder_options;
+	if (lzma_str_list_filters(&encoder_options, LZMA_VLI_UNKNOWN,
+			LZMA_STR_ENCODER, NULL) != LZMA_OK)
+		message_bug();
+
+	if (!opt_robot) {
+		puts(_(
+"Filter chains are set using the --filters=FILTERS or\n"
+"--filters1=FILTERS ... --filters9=FILTERS options. Each filter in the chain\n"
+"can be separated by spaces or `--'. Alternatively a preset <0-9>[e] can be\n"
+"specified instead of a filter chain.\n"
+		));
+
+		puts(_("The supported filters and their options are:"));
+	}
+
+	puts(encoder_options);
+
+	tuklib_exit(E_SUCCESS, E_ERROR, verbosity != V_SILENT);
+}
diff --git a/src/xz/message.h b/src/xz/message.h
index b264f821..21771eb4 100644
--- a/src/xz/message.h
+++ b/src/xz/message.h
@@ -1,152 +1,157 @@
 ///////////////////////////////////////////////////////////////////////////////
 //
 /// \file       message.h
 /// \brief      Printing messages to stderr
 //
 //  Author:     Lasse Collin
 //
 //  This file has been put into the public domain.
 //  You can do whatever you want with this file.
 //
 ///////////////////////////////////////////////////////////////////////////////
 
 /// Verbosity levels
 enum message_verbosity {
 	V_SILENT,   ///< No messages
 	V_ERROR,    ///< Only error messages
 	V_WARNING,  ///< Errors and warnings
 	V_VERBOSE,  ///< Errors, warnings, and verbose statistics
 	V_DEBUG,    ///< Very verbose
 };
 
 
 /// \brief      Signals used for progress message handling
 extern const int message_progress_sigs[];
 
 
 /// \brief      Initializes the message functions
 ///
 /// If an error occurs, this function doesn't return.
 ///
 extern void message_init(void);
 
 
 /// Increase verbosity level by one step unless it was at maximum.
 extern void message_verbosity_increase(void);
 
 /// Decrease verbosity level by one step unless it was at minimum.
 extern void message_verbosity_decrease(void);
 
 /// Get the current verbosity level.
 extern enum message_verbosity message_verbosity_get(void);
 
 
 /// \brief      Print a message if verbosity level is at least "verbosity"
 ///
 /// This doesn't touch the exit status.
 extern void message(enum message_verbosity verbosity, const char *fmt, ...)
 		lzma_attribute((__format__(__printf__, 2, 3)));
 
 
 /// \brief      Prints a warning and possibly sets exit status
 ///
 /// The message is printed only if verbosity level is at least V_WARNING.
 /// The exit status is set to WARNING unless it was already at ERROR.
 extern void message_warning(const char *fmt, ...)
 		lzma_attribute((__format__(__printf__, 1, 2)));
 
 
 /// \brief      Prints an error message and sets exit status
 ///
 /// The message is printed only if verbosity level is at least V_ERROR.
 /// The exit status is set to ERROR.
 extern void message_error(const char *fmt, ...)
 		lzma_attribute((__format__(__printf__, 1, 2)));
 
 
 /// \brief      Prints an error message and exits with EXIT_ERROR
 ///
 /// The message is printed only if verbosity level is at least V_ERROR.
 extern void message_fatal(const char *fmt, ...)
 		lzma_attribute((__format__(__printf__, 1, 2)))
 		lzma_attribute((__noreturn__));
 
 
 /// Print an error message that an internal error occurred and exit with
 /// EXIT_ERROR.
 extern void message_bug(void) lzma_attribute((__noreturn__));
 
 
 /// Print a message that establishing signal handlers failed, and exit with
 /// exit status ERROR.
 extern void message_signal_handler(void) lzma_attribute((__noreturn__));
 
 
 /// Convert lzma_ret to a string.
 extern const char *message_strm(lzma_ret code);
 
 
 /// Display how much memory was needed and how much the limit was.
 extern void message_mem_needed(enum message_verbosity v, uint64_t memusage);
 
 
 /// Print the filter chain.
 extern void message_filters_show(
 		enum message_verbosity v, const lzma_filter *filters);
 
 
 /// Print a message that user should try --help.
 extern void message_try_help(void);
 
 
 /// Prints the version number to stdout and exits with exit status SUCCESS.
 extern void message_version(void) lzma_attribute((__noreturn__));
 
 
 /// Print the help message.
 extern void message_help(bool long_help) lzma_attribute((__noreturn__));
 
 
+/// Prints a help message specifically for using the --filters and
+/// --filtersX command line options.
+extern void message_filters_help(void);
+
+
 /// \brief      Set the total number of files to be processed
 ///
 /// Standard input is counted as a file here. This is used when printing
 /// the filename via message_filename().
 extern void message_set_files(unsigned int files);
 
 
 /// \brief      Set the name of the current file and possibly print it too
 ///
 /// The name is printed immediately if --list was used or if --verbose
 /// was used and stderr is a terminal. Even when the filename isn't printed,
 /// it is stored so that it can be printed later if needed for progress
 /// messages.
 extern void message_filename(const char *src_name);
 
 
 /// \brief      Start progress info handling
 ///
 /// message_filename() must be called before this function to set
 /// the filename.
 ///
 /// This must be paired with a call to message_progress_end() before the
 /// given *strm becomes invalid.
 ///
 /// \param      strm      Pointer to lzma_stream used for the coding.
 /// \param      in_size   Size of the input file, or zero if unknown.
 ///
 extern void message_progress_start(lzma_stream *strm,
 		bool is_passthru, uint64_t in_size);
 
 
 /// Update the progress info if in verbose mode and enough time has passed
 /// since the previous update. This can be called only when
 /// message_progress_start() has already been used.
 extern void message_progress_update(void);
 
 
 /// \brief      Finishes the progress message if we were in verbose mode
 ///
 /// \param      finished    True if the whole stream was successfully coded
 ///                         and output written to the output stream.
 ///
 extern void message_progress_end(bool finished);