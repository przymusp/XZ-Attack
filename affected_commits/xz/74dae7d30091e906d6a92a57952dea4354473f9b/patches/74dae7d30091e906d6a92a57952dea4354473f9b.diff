commit 74dae7d30091e906d6a92a57952dea4354473f9b
Author: Jia Tan <jiat0218@gmail.com>
Date:   Thu Dec 29 01:10:53 2022 +0800

    Build: No longer require HAVE_DECL_CLOCK_MONOTONIC to always be set.
    
    Previously, if threading was enabled HAVE_DECL_CLOCK_MONOTONIC would always
    be set to 0 or 1. However, this macro was needed in xz so if xz was not
    built with threading and HAVE_DECL_CLOCK_MONOTONIC was not defined but
    HAVE_CLOCK_GETTIME was, it caused a warning during build. Now,
    HAVE_DECL_CLOCK_MONOTONIC has been renamed to HAVE_CLOCK_MONOTONIC and
    will only be set if it is 1.

diff --git a/CMakeLists.txt b/CMakeLists.txt
index 01c73cd5..c4f10594 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -1,841 +1,839 @@
 #############################################################################
 #
 # Very limited CMake support for building some parts of XZ Utils
 #
 # For now, this is indented to be useful to build static or shared liblzma
 # on Windows with MSVC (to avoid the need to maintain Visual Studio project
 # files). Building liblzma on a few other platforms should work too but it
 # is somewhat experimental and not as portable as using ./configure.
 #
 # On some platforms this builds also xz and xzdec, but these are
 # highly experimental and meant for testing only:
 #   - No large file support on those 32-bit platforms that need it
 #   - No replacement getopt_long(), libc must have it
 #   - No sandboxing support
 #   - No translations
 #
 # Other missing things:
 #   - No xzgrep or other scripts or their symlinks
 #   - No xz tests (liblzma tests only)
 #
 # NOTE: Even if the code compiles without warnings, the end result may be
 # different than via ./configure. Specifically, the list of #defines
 # may be different (if so, probably this CMakeLists.txt got them wrong).
 #
 # This file provides the following installation components (if you only
 # need liblzma, install only its components!):
 #   - liblzma_Runtime
 #   - liblzma_Development
 #   - xz (on some platforms only)
 #   - xzdec (on some platforms only)
 #
 # To find the target liblzma::liblzma from other packages, use the CONFIG
 # option with find_package() to avoid a conflict with the FindLibLZMA module
 # with case-insensitive file systems. For example, to require liblzma 5.2.5
 # or a newer compatible version:
 #
 #     find_package(liblzma 5.2.5 REQUIRED CONFIG)
 #     target_link_libraries(my_application liblzma::liblzma)
 #
 #############################################################################
 #
 # Author: Lasse Collin
 #
 # This file has been put into the public domain.
 # You can do whatever you want with this file.
 #
 #############################################################################
 
 cmake_minimum_required(VERSION 3.13...3.16 FATAL_ERROR)
 
 include(CMakePushCheckState)
 include(CheckIncludeFile)
 include(CheckSymbolExists)
 include(CheckStructHasMember)
 include(CheckCSourceCompiles)
 include(cmake/tuklib_integer.cmake)
 include(cmake/tuklib_cpucores.cmake)
 include(cmake/tuklib_physmem.cmake)
 include(cmake/tuklib_progname.cmake)
 include(cmake/tuklib_mbstr.cmake)
 
 # Get the package version from version.h into XZ_VERSION variable.
 file(READ src/liblzma/api/lzma/version.h XZ_VERSION)
 string(REGEX REPLACE
 "^.*\n\
 #define LZMA_VERSION_MAJOR ([0-9]+)\n\
 #define LZMA_VERSION_MINOR ([0-9]+)\n\
 #define LZMA_VERSION_PATCH ([0-9]+)\n\
 .*$"
        "\\1.\\2.\\3" XZ_VERSION "${XZ_VERSION}")
 
 # Among other things, this gives us variables xz_VERSION and xz_VERSION_MAJOR.
 project(xz VERSION "${XZ_VERSION}" LANGUAGES C)
 
 # On Apple OSes, don't build executables as bundles:
 set(CMAKE_MACOSX_BUNDLE OFF)
 
 # Definitions common to all targets:
 add_compile_definitions(
     # Package info:
     PACKAGE_NAME="XZ Utils"
     PACKAGE_BUGREPORT="xz@tukaani.org"
     PACKAGE_URL="https://tukaani.org/xz/"
 
     # Features:
     HAVE_CHECK_CRC32
     HAVE_CHECK_CRC64
     HAVE_CHECK_SHA256
     HAVE_DECODERS
     HAVE_DECODER_ARM
     HAVE_DECODER_ARMTHUMB
     HAVE_DECODER_ARM64
     HAVE_DECODER_DELTA
     HAVE_DECODER_IA64
     HAVE_DECODER_LZMA1
     HAVE_DECODER_LZMA2
     HAVE_DECODER_POWERPC
     HAVE_DECODER_SPARC
     HAVE_DECODER_X86
     HAVE_ENCODERS
     HAVE_ENCODER_ARM
     HAVE_ENCODER_ARMTHUMB
     HAVE_ENCODER_ARM64
     HAVE_ENCODER_DELTA
     HAVE_ENCODER_IA64
     HAVE_ENCODER_LZMA1
     HAVE_ENCODER_LZMA2
     HAVE_ENCODER_POWERPC
     HAVE_ENCODER_SPARC
     HAVE_ENCODER_X86
     HAVE_MF_BT2
     HAVE_MF_BT3
     HAVE_MF_BT4
     HAVE_MF_HC3
     HAVE_MF_HC4
     HAVE_LZIP_DECODER
 
     # Standard headers and types are available:
     HAVE_STDBOOL_H
     HAVE__BOOL
     HAVE_STDINT_H
     HAVE_INTTYPES_H
 
     # Disable assert() checks when no build type has been specified. Non-empty
     # build types like "Release" and "Debug" handle this by default.
     $<$<CONFIG:>:NDEBUG>
 )
 
 # _GNU_SOURCE and such definitions. This specific macro is special since
 # it also adds the definitions to CMAKE_REQUIRED_DEFINITIONS.
 tuklib_use_system_extensions(ALL)
 
 # This is needed by liblzma and xz.
 tuklib_integer(ALL)
 
 # Check for clock_gettime(). Do this before checking for threading so
 # that we know there if CLOCK_MONOTONIC is available.
 if(NOT WIN32 AND NOT DEFINED HAVE_CLOCK_GETTIME)
     check_symbol_exists(clock_gettime time.h HAVE_CLOCK_GETTIME)
     if(NOT HAVE_CLOCK_GETTIME)
         # With glibc <= 2.17 or Solaris 10 this needs librt.
         unset(HAVE_CLOCK_GETTIME CACHE)
 
         list(INSERT CMAKE_REQUIRED_LIBRARIES 0 rt)
         check_symbol_exists(clock_gettime time.h HAVE_CLOCK_GETTIME)
 
         # If it was found now, add it to all targets and keep it
         # in CMAKE_REQUIRED_LIBRARIES for further tests too.
         if(HAVE_CLOCK_GETTIME)
             link_libraries(rt)
         else()
             list(REMOVE_AT CMAKE_REQUIRED_LIBRARIES 0)
         endif()
     endif()
     if(HAVE_CLOCK_GETTIME)
         # Check if CLOCK_MONOTONIC is available for clock_gettime().
-        check_symbol_exists(CLOCK_MONOTONIC time.h HAVE_DECL_CLOCK_MONOTONIC)
+        check_symbol_exists(CLOCK_MONOTONIC time.h HAVE_CLOCK_MONOTONIC)
 
-        # HAVE_DECL_CLOCK_MONOTONIC should always be defined to 0 or 1
-        # when clock_gettime is available.
         add_compile_definitions(
             HAVE_CLOCK_GETTIME
-            HAVE_DECL_CLOCK_MONOTONIC=$<BOOL:"${HAVE_DECL_CLOCK_MONOTONIC}">
+            HAVE_CLOCK_MONOTONIC
         )
     endif()
 endif()
 
 # Threading support:
 set(THREADS_PREFER_PTHREAD_FLAG TRUE)
 find_package(Threads REQUIRED)
 if(CMAKE_USE_WIN32_THREADS_INIT)
     if(CMAKE_SIZEOF_VOID_P EQUAL 4)
         # Define to 1 when using Windows 95 (and thus XP) compatible threads. This
         # avoids use of features that were added in Windows Vista.
         # This is used for 32-bit x86 builds for compatibility reasons since it
         # makes no measurable difference in performance compared to Vista threads.
         add_compile_definitions(MYTHREAD_WIN95)
     else()
         # Define to 1 when using Windows Vista compatible threads. This uses features
         # that are not available on Windows XP.
         add_compile_definitions(MYTHREAD_VISTA)
     endif()
 else()
     add_compile_definitions(MYTHREAD_POSIX)
 
     # Check if pthread_condattr_setclock() exists to use CLOCK_MONOTONIC.
-    if(HAVE_DECL_CLOCK_MONOTONIC)
+    if(HAVE_CLOCK_MONOTONIC)
         list(INSERT CMAKE_REQUIRED_LIBRARIES 0 "${CMAKE_THREAD_LIBS_INIT}")
         check_symbol_exists(pthread_condattr_setclock pthread.h
                             HAVE_PTHREAD_CONDATTR_SETCLOCK)
         tuklib_add_definition_if(ALL HAVE_PTHREAD_CONDATTR_SETCLOCK)
     endif()
 endif()
 
 # Options for new enough GCC or Clang on any arch or operating system:
 if(CMAKE_C_COMPILER_ID MATCHES GNU|Clang)
     # configure.ac has a long list but it won't be copied here:
     add_compile_options(-Wall -Wextra)
 endif()
 
 
 #############################################################################
 # liblzma
 #############################################################################
 
 option(BUILD_SHARED_LIBS "Build liblzma as a shared library instead of static")
 
 add_library(liblzma
     src/common/mythread.h
     src/common/sysdefs.h
     src/common/tuklib_common.h
     src/common/tuklib_config.h
     src/common/tuklib_cpucores.c
     src/common/tuklib_cpucores.h
     src/common/tuklib_integer.h
     src/common/tuklib_physmem.c
     src/common/tuklib_physmem.h
     src/liblzma/api/lzma.h
     src/liblzma/api/lzma/base.h
     src/liblzma/api/lzma/bcj.h
     src/liblzma/api/lzma/block.h
     src/liblzma/api/lzma/check.h
     src/liblzma/api/lzma/container.h
     src/liblzma/api/lzma/delta.h
     src/liblzma/api/lzma/filter.h
     src/liblzma/api/lzma/hardware.h
     src/liblzma/api/lzma/index.h
     src/liblzma/api/lzma/index_hash.h
     src/liblzma/api/lzma/lzma12.h
     src/liblzma/api/lzma/stream_flags.h
     src/liblzma/api/lzma/version.h
     src/liblzma/api/lzma/vli.h
     src/liblzma/check/check.c
     src/liblzma/check/check.h
     src/liblzma/check/crc32_fast.c
     src/liblzma/check/crc32_table.c
     src/liblzma/check/crc32_table_be.h
     src/liblzma/check/crc32_table_le.h
     src/liblzma/check/crc64_fast.c
     src/liblzma/check/crc64_table.c
     src/liblzma/check/crc64_table_be.h
     src/liblzma/check/crc64_table_le.h
     src/liblzma/check/crc_macros.h
     src/liblzma/check/sha256.c
     src/liblzma/common/alone_decoder.c
     src/liblzma/common/alone_decoder.h
     src/liblzma/common/alone_encoder.c
     src/liblzma/common/auto_decoder.c
     src/liblzma/common/block_buffer_decoder.c
     src/liblzma/common/block_buffer_encoder.c
     src/liblzma/common/block_buffer_encoder.h
     src/liblzma/common/block_decoder.c
     src/liblzma/common/block_decoder.h
     src/liblzma/common/block_encoder.c
     src/liblzma/common/block_encoder.h
     src/liblzma/common/block_header_decoder.c
     src/liblzma/common/block_header_encoder.c
     src/liblzma/common/block_util.c
     src/liblzma/common/common.c
     src/liblzma/common/common.h
     src/liblzma/common/easy_buffer_encoder.c
     src/liblzma/common/easy_decoder_memusage.c
     src/liblzma/common/easy_encoder.c
     src/liblzma/common/easy_encoder_memusage.c
     src/liblzma/common/easy_preset.c
     src/liblzma/common/easy_preset.h
     src/liblzma/common/file_info.c
     src/liblzma/common/filter_buffer_decoder.c
     src/liblzma/common/filter_buffer_encoder.c
     src/liblzma/common/filter_common.c
     src/liblzma/common/filter_common.h
     src/liblzma/common/filter_decoder.c
     src/liblzma/common/filter_decoder.h
     src/liblzma/common/filter_encoder.c
     src/liblzma/common/filter_encoder.h
     src/liblzma/common/filter_flags_decoder.c
     src/liblzma/common/filter_flags_encoder.c
     src/liblzma/common/hardware_cputhreads.c
     src/liblzma/common/hardware_physmem.c
     src/liblzma/common/index.c
     src/liblzma/common/index.h
     src/liblzma/common/index_decoder.c
     src/liblzma/common/index_decoder.h
     src/liblzma/common/index_encoder.c
     src/liblzma/common/index_encoder.h
     src/liblzma/common/index_hash.c
     src/liblzma/common/lzip_decoder.c
     src/liblzma/common/lzip_decoder.h
     src/liblzma/common/memcmplen.h
     src/liblzma/common/outqueue.c
     src/liblzma/common/outqueue.h
     src/liblzma/common/stream_buffer_decoder.c
     src/liblzma/common/stream_buffer_encoder.c
     src/liblzma/common/stream_decoder.c
     src/liblzma/common/stream_decoder_mt.c
     src/liblzma/common/stream_decoder.h
     src/liblzma/common/stream_encoder.c
     src/liblzma/common/stream_encoder_mt.c
     src/liblzma/common/stream_flags_common.c
     src/liblzma/common/stream_flags_common.h
     src/liblzma/common/stream_flags_decoder.c
     src/liblzma/common/stream_flags_encoder.c
     src/liblzma/common/string_conversion.c
     src/liblzma/common/vli_decoder.c
     src/liblzma/common/vli_encoder.c
     src/liblzma/common/vli_size.c
     src/liblzma/delta/delta_common.c
     src/liblzma/delta/delta_common.h
     src/liblzma/delta/delta_decoder.c
     src/liblzma/delta/delta_decoder.h
     src/liblzma/delta/delta_encoder.c
     src/liblzma/delta/delta_encoder.h
     src/liblzma/delta/delta_private.h
     src/liblzma/lz/lz_decoder.c
     src/liblzma/lz/lz_decoder.h
     src/liblzma/lz/lz_encoder.c
     src/liblzma/lz/lz_encoder.h
     src/liblzma/lz/lz_encoder_hash.h
     src/liblzma/lz/lz_encoder_hash_table.h
     src/liblzma/lz/lz_encoder_mf.c
     src/liblzma/lzma/fastpos.h
     src/liblzma/lzma/fastpos_table.c
     src/liblzma/lzma/lzma2_decoder.c
     src/liblzma/lzma/lzma2_decoder.h
     src/liblzma/lzma/lzma2_encoder.c
     src/liblzma/lzma/lzma2_encoder.h
     src/liblzma/lzma/lzma_common.h
     src/liblzma/lzma/lzma_decoder.c
     src/liblzma/lzma/lzma_decoder.h
     src/liblzma/lzma/lzma_encoder.c
     src/liblzma/lzma/lzma_encoder.h
     src/liblzma/lzma/lzma_encoder_optimum_fast.c
     src/liblzma/lzma/lzma_encoder_optimum_normal.c
     src/liblzma/lzma/lzma_encoder_presets.c
     src/liblzma/lzma/lzma_encoder_private.h
     src/liblzma/rangecoder/price.h
     src/liblzma/rangecoder/price_table.c
     src/liblzma/rangecoder/range_common.h
     src/liblzma/rangecoder/range_decoder.h
     src/liblzma/rangecoder/range_encoder.h
     src/liblzma/simple/arm.c
     src/liblzma/simple/armthumb.c
     src/liblzma/simple/arm64.c
     src/liblzma/simple/ia64.c
     src/liblzma/simple/powerpc.c
     src/liblzma/simple/simple_coder.c
     src/liblzma/simple/simple_coder.h
     src/liblzma/simple/simple_decoder.c
     src/liblzma/simple/simple_decoder.h
     src/liblzma/simple/simple_encoder.c
     src/liblzma/simple/simple_encoder.h
     src/liblzma/simple/simple_private.h
     src/liblzma/simple/sparc.c
     src/liblzma/simple/x86.c
 )
 
 target_include_directories(liblzma PRIVATE
     src/liblzma/api
     src/liblzma/common
     src/liblzma/check
     src/liblzma/lz
     src/liblzma/rangecoder
     src/liblzma/lzma
     src/liblzma/delta
     src/liblzma/simple
     src/common
 )
 
 target_link_libraries(liblzma Threads::Threads)
 
 # Put the tuklib functions under the lzma_ namespace.
 target_compile_definitions(liblzma PRIVATE TUKLIB_SYMBOL_PREFIX=lzma_)
 tuklib_cpucores(liblzma)
 tuklib_physmem(liblzma)
 
 # While liblzma can be built without tuklib_cpucores or tuklib_physmem
 # modules, the liblzma API functions lzma_cputhreads() and lzma_physmem()
 # will then be useless (which isn't too bad but still unfortunate). Since
 # I expect the CMake-based builds to be only used on systems that are
 # supported by these tuklib modules, problems with these tuklib modules
 # are considered a hard error for now. This hopefully helps to catch bugs
 # in the CMake versions of the tuklib checks.
 if(NOT TUKLIB_CPUCORES_FOUND OR NOT TUKLIB_PHYSMEM_FOUND)
     # Use SEND_ERROR instead of FATAL_ERROR. If someone reports a bug,
     # seeing the results of the remaining checks can be useful too.
     message(SEND_ERROR
             "tuklib_cpucores() or tuklib_physmem() failed. "
             "Unless you really are building for a system where these "
             "modules are not supported (unlikely), this is a bug in the "
             "included cmake/tuklib_*.cmake files that should be fixed. "
             "To build anyway, edit this CMakeLists.txt to ignore this error.")
 endif()
 
 # Check for __attribute__((__constructor__)) support.
 # This needs -Werror because some compilers just warn
 # about this being unsupported.
 cmake_push_check_state()
 set(CMAKE_REQUIRED_FLAGS "-Werror")
 check_c_source_compiles("
         __attribute__((__constructor__))
         static void my_constructor_func(void) { return; }
         int main(void) { return 0; }
     "
     HAVE_FUNC_ATTRIBUTE_CONSTRUCTOR)
 cmake_pop_check_state()
 tuklib_add_definition_if(liblzma HAVE_FUNC_ATTRIBUTE_CONSTRUCTOR)
 
 # cpuid.h
 check_include_file(cpuid.h HAVE_CPUID_H)
 tuklib_add_definition_if(liblzma HAVE_CPUID_H)
 
 # immintrin.h:
 check_include_file(immintrin.h HAVE_IMMINTRIN_H)
 if(HAVE_IMMINTRIN_H)
     target_compile_definitions(liblzma PRIVATE HAVE_IMMINTRIN_H)
 
     # SSE2 intrinsics:
     check_c_source_compiles("
             #include <immintrin.h>
             int main(void)
             {
                 __m128i x = { 0 };
                 _mm_movemask_epi8(x);
                 return 0;
             }
         "
         HAVE__MM_MOVEMASK_EPI8)
     tuklib_add_definition_if(liblzma HAVE__MM_MOVEMASK_EPI8)
 
     # CLMUL intrinsic:
     check_c_source_compiles("
             #include <immintrin.h>
             #if defined(__e2k__) && __iset__ < 6
             #   error
             #endif
             #if (defined(__GNUC__) || defined(__clang__)) && !defined(__EDG__)
             __attribute__((__target__(\"ssse3,sse4.1,pclmul\")))
             #endif
             __m128i my_clmul(__m128i a, __m128i b)
             {
                 return _mm_clmulepi64_si128(a, b, 0);
             }
             int main(void) { return 0; }
     "
     HAVE_USABLE_CLMUL)
     tuklib_add_definition_if(liblzma HAVE_USABLE_CLMUL)
 endif()
 
 # Support -fvisiblity=hidden when building shared liblzma.
 # These lines do nothing on Windows (even under Cygwin).
 # HAVE_VISIBILITY should always be defined to 0 or 1.
 if(BUILD_SHARED_LIBS)
     set_target_properties(liblzma PROPERTIES C_VISIBILITY_PRESET hidden)
     target_compile_definitions(liblzma PRIVATE HAVE_VISIBILITY=1)
 else()
     target_compile_definitions(liblzma PRIVATE HAVE_VISIBILITY=0)
 endif()
 
 if(WIN32)
     if(BUILD_SHARED_LIBS)
         # Add the Windows resource file for liblzma.dll.
         target_sources(liblzma PRIVATE src/liblzma/liblzma_w32res.rc)
 
         set_target_properties(liblzma PROPERTIES
             LINK_DEPENDS "${CMAKE_CURRENT_SOURCE_DIR}/src/common/common_w32res.rc"
         )
 
         # Export the public API symbols with __declspec(dllexport).
         target_compile_definitions(liblzma PRIVATE DLL_EXPORT)
     else()
         # Disable __declspec(dllimport) when linking against static liblzma.
         target_compile_definitions(liblzma INTERFACE LZMA_API_STATIC)
     endif()
 elseif(BUILD_SHARED_LIBS AND CMAKE_SYSTEM_NAME STREQUAL "Linux")
     # GNU/Linux-specific symbol versioning for shared liblzma.
     # Note that adding link options doesn't affect static builds
     # but HAVE_SYMBOL_VERSIONS_LINUX must not be used with static builds
     # because it would put symbol versions into the static library which
     # can cause problems. It's clearer if all symver related things are
     # omitted when not building a shared library.
     #
     # NOTE: Set it explicitly to 1 to make it clear that versioning is
     # done unconditionally in the C files.
     target_compile_definitions(liblzma PRIVATE HAVE_SYMBOL_VERSIONS_LINUX=1)
     target_link_options(liblzma PRIVATE
         "-Wl,--version-script=${CMAKE_CURRENT_SOURCE_DIR}/src/liblzma/liblzma_linux.map"
     )
     set_target_properties(liblzma PROPERTIES
         LINK_DEPENDS "${CMAKE_CURRENT_SOURCE_DIR}/src/liblzma/liblzma_linux.map"
     )
 elseif(BUILD_SHARED_LIBS AND CMAKE_SYSTEM_NAME STREQUAL "FreeBSD")
     # Symbol versioning for shared liblzma for non-GNU/Linux.
     # FIXME? What about Solaris?
     target_link_options(liblzma PRIVATE
         "-Wl,--version-script=${CMAKE_CURRENT_SOURCE_DIR}/src/liblzma/liblzma_generic.map"
     )
     set_target_properties(liblzma PROPERTIES
         LINK_DEPENDS "${CMAKE_CURRENT_SOURCE_DIR}/src/liblzma/liblzma_generic.map"
     )
 endif()
 
 set_target_properties(liblzma PROPERTIES
     # At least for now the package versioning matches the rules used for
     # shared library versioning (excluding development releases) so it is
     # fine to use the package version here.
     SOVERSION "${xz_VERSION_MAJOR}"
     VERSION "${xz_VERSION}"
 
     # It's liblzma.so or liblzma.dll, not libliblzma.so or lzma.dll.
     # Avoid the name lzma.dll because it would conflict with LZMA SDK.
     PREFIX ""
 )
 
 # Create liblzma-config-version.cmake. We use this spelling instead of
 # liblzmaConfig.cmake to make find_package work in case insensitive manner
 # even with case sensitive file systems. This gives more consistent behavior
 # between operating systems.
 #
 # FIXME: SameMajorVersion is correct for stable releases but it is wrong
 # for development releases where each release may have incompatible changes.
 include(CMakePackageConfigHelpers)
 write_basic_package_version_file(
     "${CMAKE_CURRENT_BINARY_DIR}/liblzma-config-version.cmake"
     VERSION "${liblzma_VERSION}"
     COMPATIBILITY SameMajorVersion)
 
 # Create liblzma-config.cmake.
 file(WRITE "${CMAKE_CURRENT_BINARY_DIR}/liblzma-config.cmake"
 "include(CMakeFindDependencyMacro)
 set(THREADS_PREFER_PTHREAD_FLAG TRUE)
 find_dependency(Threads)
 
 include(\"\${CMAKE_CURRENT_LIST_DIR}/liblzma-targets.cmake\")
 
 # Be compatible with the spelling used by the FindLibLZMA module. This
 # doesn't use ALIAS because it would make CMake resolve LibLZMA::LibLZMA
 # to liblzma::liblzma instead of keeping the original spelling. Keeping
 # the original spelling is important for good FindLibLZMA compatibility.
 add_library(LibLZMA::LibLZMA INTERFACE IMPORTED)
 set_target_properties(LibLZMA::LibLZMA PROPERTIES
                       INTERFACE_LINK_LIBRARIES liblzma::liblzma)
 ")
 
 # Set CMAKE_INSTALL_LIBDIR and friends.
 include(GNUInstallDirs)
 
 # Install the library binary. The INCLUDES specifies the include path that
 # is exported for other projects to use but it doesn't install any files.
 install(TARGETS liblzma EXPORT liblzmaTargets
         RUNTIME  DESTINATION "${CMAKE_INSTALL_BINDIR}"
                  COMPONENT liblzma_Runtime
         LIBRARY  DESTINATION "${CMAKE_INSTALL_LIBDIR}"
                  COMPONENT liblzma_Runtime
                  NAMELINK_COMPONENT liblzma_Development
         ARCHIVE  DESTINATION "${CMAKE_INSTALL_LIBDIR}"
                  COMPONENT liblzma_Development
         INCLUDES DESTINATION "${CMAKE_INSTALL_INCLUDEDIR}")
 
 # Install the liblzma API headers. These use a subdirectory so
 # this has to be done as a separate step.
 install(DIRECTORY src/liblzma/api/
         COMPONENT liblzma_Development
         DESTINATION "${CMAKE_INSTALL_INCLUDEDIR}"
         FILES_MATCHING PATTERN "*.h")
 
 # Install the CMake files that other packages can use to find liblzma.
 set(liblzma_INSTALL_CMAKEDIR
     "${CMAKE_INSTALL_LIBDIR}/cmake/liblzma"
     CACHE STRING "Path to liblzma's .cmake files")
 
 install(EXPORT liblzmaTargets
         NAMESPACE liblzma::
         FILE liblzma-targets.cmake
         DESTINATION "${liblzma_INSTALL_CMAKEDIR}"
         COMPONENT liblzma_Development)
 
 install(FILES "${CMAKE_CURRENT_BINARY_DIR}/liblzma-config.cmake"
               "${CMAKE_CURRENT_BINARY_DIR}/liblzma-config-version.cmake"
         DESTINATION "${liblzma_INSTALL_CMAKEDIR}"
         COMPONENT liblzma_Development)
 
 
 #############################################################################
 # getopt_long
 #############################################################################
 
 # The command line tools needs this.
 check_symbol_exists(getopt_long getopt.h HAVE_GETOPT_LONG)
 
 
 #############################################################################
 # xzdec
 #############################################################################
 
 if(HAVE_GETOPT_LONG)
     add_executable(xzdec
         src/common/sysdefs.h
         src/common/tuklib_common.h
         src/common/tuklib_config.h
         src/common/tuklib_exit.c
         src/common/tuklib_exit.h
         src/common/tuklib_gettext.h
         src/common/tuklib_progname.c
         src/common/tuklib_progname.h
         src/xzdec/xzdec.c
     )
 
     target_include_directories(xzdec PRIVATE
         src/common
         src/liblzma/api
     )
 
     target_link_libraries(xzdec PRIVATE liblzma)
 
     tuklib_progname(xzdec)
 
     install(TARGETS xzdec
             RUNTIME DESTINATION "${CMAKE_INSTALL_BINDIR}"
                     COMPONENT xzdec)
 
     if(UNIX)
         install(FILES src/xzdec/xzdec.1
                 DESTINATION "${CMAKE_INSTALL_MANDIR}/man1"
                 COMPONENT xzdec)
     endif()
 endif()
 
 
 #############################################################################
 # xz
 #############################################################################
 
 if(NOT MSVC AND HAVE_GETOPT_LONG)
     add_executable(xz
         src/common/mythread.h
         src/common/sysdefs.h
         src/common/tuklib_common.h
         src/common/tuklib_config.h
         src/common/tuklib_exit.c
         src/common/tuklib_exit.h
         src/common/tuklib_gettext.h
         src/common/tuklib_integer.h
         src/common/tuklib_mbstr.h
         src/common/tuklib_mbstr_fw.c
         src/common/tuklib_mbstr_width.c
         src/common/tuklib_open_stdxxx.c
         src/common/tuklib_open_stdxxx.h
         src/common/tuklib_progname.c
         src/common/tuklib_progname.h
         src/xz/args.c
         src/xz/args.h
         src/xz/coder.c
         src/xz/coder.h
         src/xz/file_io.c
         src/xz/file_io.h
         src/xz/hardware.c
         src/xz/hardware.h
         src/xz/list.c
         src/xz/list.h
         src/xz/main.c
         src/xz/main.h
         src/xz/message.c
         src/xz/message.h
         src/xz/mytime.c
         src/xz/mytime.h
         src/xz/options.c
         src/xz/options.h
         src/xz/private.h
         src/xz/signals.c
         src/xz/signals.h
         src/xz/suffix.c
         src/xz/suffix.h
         src/xz/util.c
         src/xz/util.h
     )
 
     target_include_directories(xz PRIVATE
         src/common
         src/liblzma/api
     )
 
     target_link_libraries(xz PRIVATE liblzma)
 
     target_compile_definitions(xz PRIVATE ASSUME_RAM=128)
 
     tuklib_progname(xz)
     tuklib_mbstr(xz)
 
     check_symbol_exists(optreset getopt.h HAVE_OPTRESET)
     tuklib_add_definition_if(xz HAVE_OPTRESET)
 
     check_symbol_exists(posix_fadvise fcntl.h HAVE_POSIX_FADVISE)
     tuklib_add_definition_if(xz HAVE_POSIX_FADVISE)
 
     # How to get file time:
     check_struct_has_member("struct stat" st_atim.tv_nsec
                             "sys/types.h;sys/stat.h"
                             HAVE_STRUCT_STAT_ST_ATIM_TV_NSEC)
     if(HAVE_STRUCT_STAT_ST_ATIM_TV_NSEC)
         tuklib_add_definitions(xz HAVE_STRUCT_STAT_ST_ATIM_TV_NSEC)
     else()
         check_struct_has_member("struct stat" st_atimespec.tv_nsec
                                 "sys/types.h;sys/stat.h"
                                 HAVE_STRUCT_STAT_ST_ATIMESPEC_TV_NSEC)
         if(HAVE_STRUCT_STAT_ST_ATIMESPEC_TV_NSEC)
             tuklib_add_definitions(xz HAVE_STRUCT_STAT_ST_ATIMESPEC_TV_NSEC)
         else()
             check_struct_has_member("struct stat" st_atimensec
                                     "sys/types.h;sys/stat.h"
                                     HAVE_STRUCT_STAT_ST_ATIMENSEC)
             tuklib_add_definition_if(xz HAVE_STRUCT_STAT_ST_ATIMENSEC)
         endif()
     endif()
 
     # How to set file time:
     check_symbol_exists(futimens "sys/types.h;sys/stat.h" HAVE_FUTIMENS)
     if(HAVE_FUTIMENS)
         tuklib_add_definitions(xz HAVE_FUTIMENS)
     else()
         check_symbol_exists(futimes "sys/time.h" HAVE_FUTIMES)
         if(HAVE_FUTIMES)
             tuklib_add_definitions(xz HAVE_FUTIMES)
         else()
             check_symbol_exists(futimesat "sys/time.h" HAVE_FUTIMESAT)
             if(HAVE_FUTIMESAT)
                 tuklib_add_definitions(xz HAVE_FUTIMESAT)
             else()
                 check_symbol_exists(utimes "sys/time.h" HAVE_UTIMES)
                 if(HAVE_UTIMES)
                     tuklib_add_definitions(xz HAVE_UTIMES)
                 else()
                     check_symbol_exists(_futime "sys/utime.h" HAVE__FUTIME)
                     if(HAVE__FUTIME)
                         tuklib_add_definitions(xz HAVE__FUTIME)
                     else()
                         check_symbol_exists(utime "utime.h" HAVE_UTIME)
                         tuklib_add_definition_if(xz HAVE_UTIME)
                     endif()
                 endif()
             endif()
         endif()
     endif()
 
     install(TARGETS xz
             RUNTIME DESTINATION "${CMAKE_INSTALL_BINDIR}"
                     COMPONENT xz)
 
     if(UNIX)
         install(FILES src/xz/xz.1
                 DESTINATION "${CMAKE_INSTALL_MANDIR}/man1"
                 COMPONENT xz)
 
         option(CREATE_XZ_SYMLINKS "Create unxz and xzcat symlinks" ON)
         option(CREATE_LZMA_SYMLINKS "Create lzma, unlzma, and lzcat symlinks"
                ON)
         set(XZ_LINKS)
 
         if(CREATE_XZ_SYMLINKS)
             list(APPEND XZ_LINKS "unxz" "xzcat")
         endif()
 
         if(CREATE_LZMA_SYMLINKS)
             list(APPEND XZ_LINKS "lzma" "unlzma" "lzcat")
         endif()
 
         # Create symlinks in the build directory and then install them.
         #
         # The symlinks do not likely need any special extension since
         # even on Windows the symlink can still be executed without
         # the .exe extension.
         foreach(LINK IN LISTS XZ_LINKS)
             add_custom_target("${LINK}" ALL
                 "${CMAKE_COMMAND}" -E create_symlink
                     "$<TARGET_FILE_NAME:xz>" "${LINK}"
                 BYPRODUCTS "${LINK}"
                 VERBATIM)
             install(FILES "${CMAKE_CURRENT_BINARY_DIR}/${LINK}"
                     DESTINATION "${CMAKE_INSTALL_BINDIR}"
                     COMPONENT xz)
             add_custom_target("${LINK}.1" ALL
                 "${CMAKE_COMMAND}" -E create_symlink "xz.1" "${LINK}.1"
                 BYPRODUCTS "${LINK}.1"
                 VERBATIM)
             install(FILES "${CMAKE_CURRENT_BINARY_DIR}/${LINK}.1"
                     DESTINATION "${CMAKE_INSTALL_MANDIR}/man1"
                     COMPONENT xz)
         endforeach()
     endif()
 endif()
 
 
 #############################################################################
 # Tests
 #############################################################################
 
 include(CTest)
 
 if(BUILD_TESTING)
     set(LIBLZMA_TESTS
         test_bcj_exact_size
         test_block_header
         test_check
         test_filter_flags
         test_hardware
         test_index
         test_memlimit
         test_stream_flags
         test_vli
     )
 
     foreach(TEST IN LISTS LIBLZMA_TESTS)
         add_executable("${TEST}" "tests/${TEST}.c")
 
         target_include_directories("${TEST}" PRIVATE
             src/common
             src/liblzma/api
             lib
         )
 
         target_link_libraries("${TEST}" PRIVATE liblzma)
 
         # Put the test programs into their own subdirectory so they don't
         # pollute the top-level dir which might contain xz and xzdec.
         set_target_properties("${TEST}" PROPERTIES
             RUNTIME_OUTPUT_DIRECTORY "${CMAKE_CURRENT_BINARY_DIR}/tests_bin"
         )
 
         add_test(NAME "${TEST}"
                  COMMAND "${CMAKE_CURRENT_BINARY_DIR}/tests_bin/${TEST}"
         )
 
         # Set srcdir environment variable so that the tests find their
         # input files from the source tree.
         #
         # Set the return code for skipped tests to match Automake convention.
         set_tests_properties("${TEST}" PROPERTIES
             ENVIRONMENT "srcdir=${CMAKE_CURRENT_LIST_DIR}/tests"
             SKIP_RETURN_CODE 77
         )
     endforeach()
 endif()
diff --git a/configure.ac b/configure.ac
index 7c77215b..a16031b5 100644
--- a/configure.ac
+++ b/configure.ac
@@ -1,1138 +1,1141 @@
 #                                               -*- Autoconf -*-
 # Process this file with autoconf to produce a configure script.
 
 ###############################################################################
 #
 # Author: Lasse Collin
 #
 # This file has been put into the public domain.
 # You can do whatever you want with this file.
 #
 ###############################################################################
 
 # NOTE: Don't add useless checks. autoscan detects this and that, but don't
 # let it confuse you. For example, we don't care about checking for behavior
 # of malloc(), stat(), or lstat(), since we don't use those functions in
 # a way that would cause the problems the autoconf macros check.
 
 AC_PREREQ([2.69])
 
 AC_INIT([XZ Utils], m4_esyscmd([/bin/sh build-aux/version.sh]),
 	[xz@tukaani.org], [xz], [https://tukaani.org/xz/])
 AC_CONFIG_SRCDIR([src/liblzma/common/common.h])
 AC_CONFIG_AUX_DIR([build-aux])
 AC_CONFIG_MACRO_DIR([m4])
 AC_CONFIG_HEADERS([config.h])
 
 echo
 echo "$PACKAGE_STRING"
 
 echo
 echo "System type:"
 # This is needed to know if assembler optimizations can be used.
 AC_CANONICAL_HOST
 
 # We do some special things on Windows (32-bit or 64-bit) builds.
 case $host_os in
 	mingw* | cygwin | msys) is_w32=yes ;;
 	*)                      is_w32=no ;;
 esac
 AM_CONDITIONAL([COND_W32], [test "$is_w32" = yes])
 
 # We need to use $EXEEXT with $(LN_S) when creating symlinks to
 # executables. Cygwin is an exception to this, since it is recommended
 # that symlinks don't have the .exe suffix. To make this work, we
 # define LN_EXEEXT.
 #
 # MSYS2 is treated the same way as Cygwin. It uses plain "msys" like
 # the original MSYS when building MSYS/MSYS2-binaries. Hopefully this
 # doesn't break things for the original MSYS developers. Note that this
 # doesn't affect normal MSYS/MSYS2 users building non-MSYS/MSYS2 binaries
 # since in that case the $host_os is usually mingw32.
 case $host_os in
 	cygwin | msys)  LN_EXEEXT= ;;
 	*)              LN_EXEEXT='$(EXEEXT)' ;;
 esac
 AC_SUBST([LN_EXEEXT])
 
 echo
 echo "Configure options:"
 AM_CFLAGS=
 
 
 #############
 # Debugging #
 #############
 
 AC_MSG_CHECKING([if debugging code should be compiled])
 AC_ARG_ENABLE([debug], AS_HELP_STRING([--enable-debug], [Enable debugging code.]),
 	[], enable_debug=no)
 if test "x$enable_debug" = xyes; then
 	AC_MSG_RESULT([yes])
 else
 	AC_DEFINE([NDEBUG], [1], [Define to 1 to disable debugging code.])
 	AC_MSG_RESULT([no])
 fi
 
 
 ###########
 # Filters #
 ###########
 
 m4_define([SUPPORTED_FILTERS], [lzma1,lzma2,delta,x86,powerpc,ia64,arm,armthumb,arm64,sparc])dnl
 m4_define([SIMPLE_FILTERS], [x86,powerpc,ia64,arm,armthumb,arm64,sparc])
 m4_define([LZ_FILTERS], [lzma1,lzma2])
 
 m4_foreach([NAME], [SUPPORTED_FILTERS],
 [enable_filter_[]NAME=no
 enable_encoder_[]NAME=no
 enable_decoder_[]NAME=no
 ])dnl
 
 AC_MSG_CHECKING([which encoders to build])
 AC_ARG_ENABLE([encoders], AS_HELP_STRING([--enable-encoders=LIST],
 		[Comma-separated list of encoders to build. Default=all.
 		Available encoders:]
 			m4_translit(m4_defn([SUPPORTED_FILTERS]), [,], [ ])),
 	[], [enable_encoders=SUPPORTED_FILTERS])
 enable_encoders=`echo "$enable_encoders" | sed 's/,/ /g'`
 if test "x$enable_encoders" = xno || test "x$enable_encoders" = x; then
 	enable_encoders=no
 	AC_MSG_RESULT([(none)])
 else
 	for arg in $enable_encoders
 	do
 		case $arg in m4_foreach([NAME], [SUPPORTED_FILTERS], [
 			NAME)
 				enable_filter_[]NAME=yes
 				enable_encoder_[]NAME=yes
 				AC_DEFINE(HAVE_ENCODER_[]m4_toupper(NAME), [1],
 				[Define to 1 if] NAME [encoder is enabled.])
 				;;])
 			*)
 				AC_MSG_RESULT([])
 				AC_MSG_ERROR([unknown filter: $arg])
 				;;
 		esac
 	done
 	AC_DEFINE([HAVE_ENCODERS], [1],
 		[Define to 1 if any of HAVE_ENCODER_foo have been defined.])
 	AC_MSG_RESULT([$enable_encoders])
 fi
 
 AC_MSG_CHECKING([which decoders to build])
 AC_ARG_ENABLE([decoders], AS_HELP_STRING([--enable-decoders=LIST],
 		[Comma-separated list of decoders to build. Default=all.
 		Available decoders are the same as available encoders.]),
 	[], [enable_decoders=SUPPORTED_FILTERS])
 enable_decoders=`echo "$enable_decoders" | sed 's/,/ /g'`
 if test "x$enable_decoders" = xno || test "x$enable_decoders" = x; then
 	enable_decoders=no
 	AC_MSG_RESULT([(none)])
 else
 	for arg in $enable_decoders
 	do
 		case $arg in m4_foreach([NAME], [SUPPORTED_FILTERS], [
 			NAME)
 				enable_filter_[]NAME=yes
 				enable_decoder_[]NAME=yes
 				AC_DEFINE(HAVE_DECODER_[]m4_toupper(NAME), [1],
 				[Define to 1 if] NAME [decoder is enabled.])
 				;;])
 			*)
 				AC_MSG_RESULT([])
 				AC_MSG_ERROR([unknown filter: $arg])
 				;;
 		esac
 	done
 	AC_DEFINE([HAVE_DECODERS], [1],
 		[Define to 1 if any of HAVE_DECODER_foo have been defined.])
 	AC_MSG_RESULT([$enable_decoders])
 fi
 
 if test "x$enable_encoder_lzma2$enable_encoder_lzma1" = xyesno \
 		|| test "x$enable_decoder_lzma2$enable_decoder_lzma1" = xyesno; then
 	AC_MSG_ERROR([LZMA2 requires that LZMA1 is also enabled.])
 fi
 
 AM_CONDITIONAL(COND_MAIN_ENCODER, test "x$enable_encoders" != xno)
 AM_CONDITIONAL(COND_MAIN_DECODER, test "x$enable_decoders" != xno)
 
 m4_foreach([NAME], [SUPPORTED_FILTERS],
 [AM_CONDITIONAL(COND_FILTER_[]m4_toupper(NAME), test "x$enable_filter_[]NAME" = xyes)
 AM_CONDITIONAL(COND_ENCODER_[]m4_toupper(NAME), test "x$enable_encoder_[]NAME" = xyes)
 AM_CONDITIONAL(COND_DECODER_[]m4_toupper(NAME), test "x$enable_decoder_[]NAME" = xyes)
 ])dnl
 
 # The so called "simple filters" share common code.
 enable_filter_simple=no
 enable_encoder_simple=no
 enable_decoder_simple=no
 m4_foreach([NAME], [SIMPLE_FILTERS],
 [test "x$enable_filter_[]NAME" = xyes && enable_filter_simple=yes
 test "x$enable_encoder_[]NAME" = xyes && enable_encoder_simple=yes
 test "x$enable_decoder_[]NAME" = xyes && enable_decoder_simple=yes
 ])dnl
 AM_CONDITIONAL(COND_FILTER_SIMPLE, test "x$enable_filter_simple" = xyes)
 AM_CONDITIONAL(COND_ENCODER_SIMPLE, test "x$enable_encoder_simple" = xyes)
 AM_CONDITIONAL(COND_DECODER_SIMPLE, test "x$enable_decoder_simple" = xyes)
 
 # LZ-based filters share common code.
 enable_filter_lz=no
 enable_encoder_lz=no
 enable_decoder_lz=no
 m4_foreach([NAME], [LZ_FILTERS],
 [test "x$enable_filter_[]NAME" = xyes && enable_filter_lz=yes
 test "x$enable_encoder_[]NAME" = xyes && enable_encoder_lz=yes
 test "x$enable_decoder_[]NAME" = xyes && enable_decoder_lz=yes
 ])dnl
 AM_CONDITIONAL(COND_FILTER_LZ, test "x$enable_filter_lz" = xyes)
 AM_CONDITIONAL(COND_ENCODER_LZ, test "x$enable_encoder_lz" = xyes)
 AM_CONDITIONAL(COND_DECODER_LZ, test "x$enable_decoder_lz" = xyes)
 
 
 #################
 # Match finders #
 #################
 
 m4_define([SUPPORTED_MATCH_FINDERS], [hc3,hc4,bt2,bt3,bt4])
 
 m4_foreach([NAME], [SUPPORTED_MATCH_FINDERS],
 [enable_match_finder_[]NAME=no
 ])
 
 AC_MSG_CHECKING([which match finders to build])
 AC_ARG_ENABLE([match-finders], AS_HELP_STRING([--enable-match-finders=LIST],
 		[Comma-separated list of match finders to build. Default=all.
 		At least one match finder is required for encoding with
 		the LZMA1 and LZMA2 filters. Available match finders:]
 		m4_translit(m4_defn([SUPPORTED_MATCH_FINDERS]), [,], [ ])), [],
 	[enable_match_finders=SUPPORTED_MATCH_FINDERS])
 enable_match_finders=`echo "$enable_match_finders" | sed 's/,/ /g'`
 if test "x$enable_encoder_lz" = xyes ; then
 	if test -z "$enable_match_finders"; then
 		AC_MSG_ERROR([At least one match finder is required for an LZ-based encoder.])
 	fi
 
 	for arg in $enable_match_finders
 		do
 		case $arg in m4_foreach([NAME], [SUPPORTED_MATCH_FINDERS], [
 			NAME)
 				enable_match_finder_[]NAME=yes
 				AC_DEFINE(HAVE_MF_[]m4_toupper(NAME), [1],
 				[Define to 1 to enable] NAME [match finder.])
 				;;])
 			*)
 				AC_MSG_RESULT([])
 				AC_MSG_ERROR([unknown match finder: $arg])
 				;;
 		esac
 	done
 	AC_MSG_RESULT([$enable_match_finders])
 else
 	AC_MSG_RESULT([(none because not building any LZ-based encoder)])
 fi
 
 
 ####################
 # Integrity checks #
 ####################
 
 m4_define([SUPPORTED_CHECKS], [crc32,crc64,sha256])
 
 m4_foreach([NAME], [SUPPORTED_CHECKS],
 [enable_check_[]NAME=no
 ])dnl
 
 AC_MSG_CHECKING([which integrity checks to build])
 AC_ARG_ENABLE([checks], AS_HELP_STRING([--enable-checks=LIST],
 		[Comma-separated list of integrity checks to build.
 		Default=all. Available integrity checks:]
 		m4_translit(m4_defn([SUPPORTED_CHECKS]), [,], [ ])),
 	[], [enable_checks=SUPPORTED_CHECKS])
 enable_checks=`echo "$enable_checks" | sed 's/,/ /g'`
 if test "x$enable_checks" = xno || test "x$enable_checks" = x; then
 	AC_MSG_RESULT([(none)])
 else
 	for arg in $enable_checks
 	do
 		case $arg in m4_foreach([NAME], [SUPPORTED_CHECKS], [
 			NAME)
 				enable_check_[]NAME=yes
 				AC_DEFINE(HAVE_CHECK_[]m4_toupper(NAME), [1],
 				[Define to 1 if] NAME
 				[integrity check is enabled.])
 				;;])
 			*)
 				AC_MSG_RESULT([])
 				AC_MSG_ERROR([unknown integrity check: $arg])
 				;;
 		esac
 	done
 	AC_MSG_RESULT([$enable_checks])
 fi
 if test "x$enable_check_crc32" = xno ; then
 	AC_MSG_ERROR([For now, the CRC32 check must always be enabled.])
 fi
 
 m4_foreach([NAME], [SUPPORTED_CHECKS],
 [AM_CONDITIONAL(COND_CHECK_[]m4_toupper(NAME), test "x$enable_check_[]NAME" = xyes)
 ])dnl
 
 AC_MSG_CHECKING([if external SHA-256 should be used])
 AC_ARG_ENABLE([external-sha256], AS_HELP_STRING([--enable-external-sha256],
 		[Use SHA-256 code from the operating system.
 		See INSTALL for possible subtle problems.]),
 		[], [enable_external_sha256=no])
 if test "x$enable_check_sha256" != "xyes"; then
 	enable_external_sha256=no
 fi
 if test "x$enable_external_sha256" = xyes; then
 	AC_MSG_RESULT([yes])
 else
 	AC_MSG_RESULT([no])
 fi
 
 
 #############
 # MicroLZMA #
 #############
 
 AC_MSG_CHECKING([if MicroLZMA support should be built])
 AC_ARG_ENABLE([microlzma], AS_HELP_STRING([--disable-microlzma],
 		[Do not build MicroLZMA encoder and decoder.
 		It is needed by specific applications only,
 		for example, erofs-utils.]),
 	[], [enable_microlzma=yes])
 case $enable_microlzma in
 	yes | no)
 		AC_MSG_RESULT([$enable_microlzma])
 		;;
 	*)
 		AC_MSG_RESULT([])
 		AC_MSG_ERROR([--enable-microlzma accepts only `yes' or `no'.])
 		;;
 esac
 AM_CONDITIONAL(COND_MICROLZMA, test "x$enable_microlzma" = xyes)
 
 
 #############################
 # .lz (lzip) format support #
 #############################
 
 AC_MSG_CHECKING([if .lz (lzip) decompression support should be built])
 AC_ARG_ENABLE([lzip-decoder], AS_HELP_STRING([--disable-lzip-decoder],
 		[Disable decompression support for .lz (lzip) files.]),
 	[], [enable_lzip_decoder=yes])
 if test "x$enable_decoder_lzma1" != xyes; then
 	enable_lzip_decoder=no
 	AC_MSG_RESULT([no because LZMA1 decoder is disabled])
 elif test "x$enable_lzip_decoder" = xyes; then
 	AC_DEFINE([HAVE_LZIP_DECODER], [1],
 		[Define to 1 if .lz (lzip) decompression support is enabled.])
 	AC_MSG_RESULT([yes])
 else
 	AC_MSG_RESULT([no])
 fi
 AM_CONDITIONAL(COND_LZIP_DECODER, test "x$enable_lzip_decoder" = xyes)
 
 
 ###########################
 # Assembler optimizations #
 ###########################
 
 AC_MSG_CHECKING([if assembler optimizations should be used])
 AC_ARG_ENABLE([assembler], AS_HELP_STRING([--disable-assembler],
 		[Do not use assembler optimizations even if such exist
 		for the architecture.]),
 	[], [enable_assembler=yes])
 if test "x$enable_assembler" = xyes; then
 	enable_assembler=no
 	case $host_os in
 		# Darwin should work too but only if not creating universal
 		# binaries. Solaris x86 could work too but I cannot test.
 		linux* | *bsd* | mingw* | cygwin | msys | *djgpp*)
 			case $host_cpu in
 				i?86)   enable_assembler=x86 ;;
 			esac
 			;;
 	esac
 fi
 case $enable_assembler in
 	x86 | no)
 		AC_MSG_RESULT([$enable_assembler])
 		;;
 	*)
 		AC_MSG_RESULT([])
 		AC_MSG_ERROR([--enable-assembler accepts only `yes', `no', or `x86' (32-bit).])
 		;;
 esac
 AM_CONDITIONAL(COND_ASM_X86, test "x$enable_assembler" = xx86)
 
 
 #############
 # CLMUL CRC #
 #############
 
 AC_ARG_ENABLE([clmul-crc], AS_HELP_STRING([--disable-clmul-crc],
 		[Do not use carryless multiplication for CRC calculation
 		even if support for it is detected.]),
 	[], [enable_clmul_crc=yes])
 
 
 #####################
 # Size optimization #
 #####################
 
 AC_MSG_CHECKING([if small size is preferred over speed])
 AC_ARG_ENABLE([small], AS_HELP_STRING([--enable-small],
 		[Make liblzma smaller and a little slower.
 		This is disabled by default to optimize for speed.]),
 	[], [enable_small=no])
 if test "x$enable_small" = xyes; then
 	AC_DEFINE([HAVE_SMALL], [1], [Define to 1 if optimizing for size.])
 elif test "x$enable_small" != xno; then
 	AC_MSG_RESULT([])
 	AC_MSG_ERROR([--enable-small accepts only `yes' or `no'])
 fi
 AC_MSG_RESULT([$enable_small])
 AM_CONDITIONAL(COND_SMALL, test "x$enable_small" = xyes)
 
 
 #############
 # Threading #
 #############
 
 AC_MSG_CHECKING([if threading support is wanted])
 AC_ARG_ENABLE([threads], AS_HELP_STRING([--enable-threads=METHOD],
 		[Supported METHODS are `yes', `no', `posix', `win95', and
 		`vista'. The default is `yes'. Using `no' together with
 		--enable-small makes liblzma thread unsafe.]),
 	[], [enable_threads=yes])
 
 if test "x$enable_threads" = xyes; then
 	case $host_os in
 		mingw*)
 			case $host_cpu in
 				i?86)   enable_threads=win95 ;;
 				*)      enable_threads=vista ;;
 			esac
 			;;
 		*)
 			enable_threads=posix
 			;;
 	esac
 fi
 
 case $enable_threads in
 	posix | win95 | vista)
 		AC_MSG_RESULT([yes, $enable_threads])
 		;;
 	no)
 		AC_MSG_RESULT([no])
 		;;
 	*)
 		AC_MSG_RESULT([])
 		AC_MSG_ERROR([--enable-threads only accepts `yes', `no', `posix', `win95', or `vista'])
 		;;
 esac
 
 # The Win95 threading lacks thread-safe one-time initialization function.
 # It's better to disallow it instead of allowing threaded but thread-unsafe
 # build.
 if test "x$enable_small$enable_threads" = xyeswin95; then
 	AC_MSG_ERROR([--enable-threads=win95 and --enable-small cannot be
 		used at the same time])
 fi
 
 # We use the actual result a little later.
 
 
 #########################
 # Assumed amount of RAM #
 #########################
 
 # We use 128 MiB as default, because it will allow decompressing files
 # created with "xz -9". It would be slightly safer to guess a lower value,
 # but most systems, on which we don't have any way to determine the amount
 # of RAM, will probably have at least 128 MiB of RAM.
 AC_MSG_CHECKING([how much RAM to assume if the real amount is unknown])
 AC_ARG_ENABLE([assume-ram], AS_HELP_STRING([--enable-assume-ram=SIZE],
 		[If and only if the real amount of RAM cannot be determined,
 		assume SIZE MiB. The default is 128 MiB. This affects the
 		default memory usage limit.]),
 	[], [enable_assume_ram=128])
 assume_ram_check=`echo "$enable_assume_ram" | tr -d 0123456789`
 if test -z "$enable_assume_ram" || test -n "$assume_ram_check"; then
 	AC_MSG_RESULT([])
 	AC_MSG_ERROR([--enable-assume-ram accepts only an integer argument])
 fi
 AC_MSG_RESULT([$enable_assume_ram MiB])
 AC_DEFINE_UNQUOTED([ASSUME_RAM], [$enable_assume_ram],
 		[How many MiB of RAM to assume if the real amount cannot
 		be determined.])
 
 
 #########################
 # Components to install #
 #########################
 
 AC_ARG_ENABLE([xz], [AS_HELP_STRING([--disable-xz],
 		[do not build the xz tool])],
 	[], [enable_xz=yes])
 AM_CONDITIONAL([COND_XZ], [test x$enable_xz != xno])
 
 AC_ARG_ENABLE([xzdec], [AS_HELP_STRING([--disable-xzdec],
 		[do not build xzdec])],
 	[], [enable_xzdec=yes])
 test "x$enable_decoders" = xno && enable_xzdec=no
 AM_CONDITIONAL([COND_XZDEC], [test x$enable_xzdec != xno])
 
 AC_ARG_ENABLE([lzmadec], [AS_HELP_STRING([--disable-lzmadec],
 		[do not build lzmadec
 		(it exists primarily for LZMA Utils compatibility)])],
 	[], [enable_lzmadec=yes])
 test "x$enable_decoder_lzma1" = xno && enable_lzmadec=no
 AM_CONDITIONAL([COND_LZMADEC], [test x$enable_lzmadec != xno])
 
 AC_ARG_ENABLE([lzmainfo], [AS_HELP_STRING([--disable-lzmainfo],
 		[do not build lzmainfo
 		(it exists primarily for LZMA Utils compatibility)])],
 	[], [enable_lzmainfo=yes])
 test "x$enable_decoder_lzma1" = xno && enable_lzmainfo=no
 AM_CONDITIONAL([COND_LZMAINFO], [test x$enable_lzmainfo != xno])
 
 AC_ARG_ENABLE([lzma-links], [AS_HELP_STRING([--disable-lzma-links],
 		[do not create symlinks for LZMA Utils compatibility])],
 	[], [enable_lzma_links=yes])
 AM_CONDITIONAL([COND_LZMALINKS], [test x$enable_lzma_links != xno])
 
 AC_ARG_ENABLE([scripts], [AS_HELP_STRING([--disable-scripts],
 		[do not install the scripts xzdiff, xzgrep, xzless, xzmore,
 		and their symlinks])],
 	[], [enable_scripts=yes])
 AM_CONDITIONAL([COND_SCRIPTS], [test x$enable_scripts != xno])
 
 AC_ARG_ENABLE([doc], [AS_HELP_STRING([--disable-doc],
 		[do not install documentation files to docdir
 		(man pages will still be installed)])],
 	[], [enable_doc=yes])
 AM_CONDITIONAL([COND_DOC], [test x$enable_doc != xno])
 
 
 ##############
 # Sandboxing #
 ##############
 
 AC_MSG_CHECKING([if sandboxing should be used])
 AC_ARG_ENABLE([sandbox], [AS_HELP_STRING([--enable-sandbox=METHOD],
 		[Sandboxing METHOD can be
 		`auto', `no', `capsicum', or `pledge'.
 		The default is `auto' which enables sandboxing if
 		a supported sandboxing method is found.])],
 	[], [enable_sandbox=auto])
 case $enable_sandbox in
 	auto)
 		AC_MSG_RESULT([maybe (autodetect)])
 		;;
 	no | capsicum | pledge)
 		AC_MSG_RESULT([$enable_sandbox])
 		;;
 	*)
 		AC_MSG_RESULT([])
 		AC_MSG_ERROR([--enable-sandbox only accepts `auto', `no', `capsicum', or `pledge'.])
 		;;
 esac
 
 
 ###########################
 # PATH prefix for scripts #
 ###########################
 
 # The scripts can add a prefix to the search PATH so that POSIX tools
 # or the xz binary is always in the PATH.
 AC_ARG_ENABLE([path-for-scripts],
 	[AS_HELP_STRING([--enable-path-for-scripts=PREFIX],
 		[If PREFIX isn't empty, PATH=PREFIX:$PATH will be set in
 		the beginning of the scripts (xzgrep and others).
 		The default is empty except on Solaris the default is
 		/usr/xpg4/bin.])],
 	[], [
 		case $host_os in
 			solaris*) enable_path_for_scripts=/usr/xpg4/bin ;;
 			*)        enable_path_for_scripts= ;;
 		esac
 	])
 if test -n "$enable_path_for_scripts" && test "x$enable_path_for_scripts" != xno ; then
 	enable_path_for_scripts="PATH=$enable_path_for_scripts:\$PATH"
 else
 	enable_path_for_scripts=
 fi
 AC_SUBST([enable_path_for_scripts])
 
 
 ###############################################################################
 # Checks for programs.
 ###############################################################################
 
 echo
 case $host_os in
 	solaris*)
 		# The gnulib POSIX shell macro below may pick a shell that
 		# doesn't work with xzgrep. Workaround by picking a shell
 		# that is known to work.
 		if test -z "$gl_cv_posix_shell" && test -x /usr/xpg4/bin/sh; then
 			gl_cv_posix_shell=/usr/xpg4/bin/sh
 		fi
 		;;
 esac
 gl_POSIX_SHELL
 if test -z "$POSIX_SHELL" && test "x$enable_scripts" = xyes ; then
 	AC_MSG_ERROR([No POSIX conforming shell (sh) was found.])
 fi
 
 echo
 echo "Initializing Automake:"
 
 # We don't use "subdir-objects" yet because it breaks "make distclean" when
 # dependencies are enabled (as of Automake 1.14.1) due to this bug:
 # http://debbugs.gnu.org/cgi/bugreport.cgi?bug=17354
 # The -Wno-unsupported is used to silence warnings about missing
 # "subdir-objects".
 AM_INIT_AUTOMAKE([1.12 foreign tar-v7 filename-length-max=99 -Wno-unsupported])
 AC_PROG_LN_S
 
 AC_PROG_CC_C99
 if test x$ac_cv_prog_cc_c99 = xno ; then
 	AC_MSG_ERROR([No C99 compiler was found.])
 fi
 
 AM_PROG_CC_C_O
 AM_PROG_AS
 AC_USE_SYSTEM_EXTENSIONS
 
 case $enable_threads in
 	posix)
 		echo
 		echo "POSIX threading support:"
 		AX_PTHREAD([:]) dnl We don't need the HAVE_PTHREAD macro.
 		LIBS="$LIBS $PTHREAD_LIBS"
 		AM_CFLAGS="$AM_CFLAGS $PTHREAD_CFLAGS"
 
 		dnl NOTE: PTHREAD_CC is ignored. It would be useful on AIX,
 		dnl but it's tricky to get it right together with
 		dnl AC_PROG_CC_C99. Thus, this is handled by telling the
 		dnl user in INSTALL to set the correct CC manually.
 
 		AC_DEFINE([MYTHREAD_POSIX], [1],
 			[Define to 1 when using POSIX threads (pthreads).])
 
 		# These are nice to have but not mandatory.
 		#
 		# FIXME: xz uses clock_gettime if it is available and can do
 		# it even when threading is disabled. Moving this outside
 		# of pthread detection may be undesirable because then
 		# liblzma may get linked against librt even when librt isn't
 		# needed by liblzma.
 		OLD_CFLAGS=$CFLAGS
 		CFLAGS="$CFLAGS $PTHREAD_CFLAGS"
 		AC_SEARCH_LIBS([clock_gettime], [rt])
 		AC_CHECK_FUNCS([clock_gettime pthread_condattr_setclock])
-		AC_CHECK_DECLS([CLOCK_MONOTONIC], [], [], [[#include <time.h>]])
+		AC_CHECK_DECL([CLOCK_MONOTONIC], [AC_DEFINE(
+			[HAVE_CLOCK_MONOTONIC], [1], [Define to 1 if
+			CLOCK_MONOTONIC is declared in <time.h>])], [],
+			[[#include <time.h>]])
 		CFLAGS=$OLD_CFLAGS
 		;;
 	win95)
 		AC_DEFINE([MYTHREAD_WIN95], [1], [Define to 1 when using
 			Windows 95 (and thus XP) compatible threads.
 			This avoids use of features that were added in
 			Windows Vista.])
 		;;
 	vista)
 		AC_DEFINE([MYTHREAD_VISTA], [1], [Define to 1 when using
 			Windows Vista compatible threads. This uses
 			features that are not available on Windows XP.])
 		;;
 esac
 AM_CONDITIONAL([COND_THREADS], [test "x$enable_threads" != xno])
 
 echo
 echo "Initializing Libtool:"
 LT_PREREQ([2.4])
 LT_INIT([win32-dll])
 LT_LANG([Windows Resource])
 
 # This is a bit wrong since it is possible to request that only some libs
 # are built as shared. Using that feature isn't so common though, and this
 # breaks only on Windows (at least for now) if the user enables only some
 # libs as shared.
 AM_CONDITIONAL([COND_SHARED], [test "x$enable_shared" != xno])
 
 #####################
 # Symbol versioning #
 #####################
 
 # NOTE: This checks if we are building shared or static library
 # and if --with-pic or --without-pic was used. Thus this check
 # must be after Libtool initialization.
 AC_MSG_CHECKING([if library symbol versioning should be used])
 AC_ARG_ENABLE([symbol-versions], [AS_HELP_STRING([--enable-symbol-versions],
 		[Use symbol versioning for liblzma. Enabled by default on
 		GNU/Linux, other GNU-based systems, and FreeBSD.])],
 	[], [enable_symbol_versions=auto])
 if test "x$enable_symbol_versions" = xauto; then
 	case $host_os in
 		# NOTE: Even if one omits -gnu on GNU/Linux (e.g.
 		# i486-slackware-linux), configure will (via config.sub)
 		# append -gnu (e.g. i486-slackware-linux-gnu), and this
 		# test will work correctly.
 		gnu* | *-gnu* | freebsd*)
 			enable_symbol_versions=yes
 			;;
 		*)
 			enable_symbol_versions=no
 			;;
 	esac
 fi
 
 # There are two variants for symbol versioning.
 # See src/liblzma/validate_map.sh for details.
 #
 # On GNU/Linux, extra symbols are added in the C code. These extra symbols
 # must not be put into a static library as they can cause problems (and
 # even if they didn't cause problems, they would be useless). On other
 # systems symbol versioning may be used too but there is no problem as only
 # a linker script is specified in src/liblzma/Makefile.am and that isn't
 # used when creating a static library.
 #
 # Libtool always uses -DPIC when building shared libraries by default and
 # doesn't use it for static libs by default. This can be overriden with
 # --with-pic and --without-pic though. As long as neither --with-pic nor
 # --without-pic is used then we can use #ifdef PIC to detect if the file is
 # being built for a shared library.
 if test "x$enable_symbol_versions" = xno ; then
 	enable_symbol_versions=no
 	AC_MSG_RESULT([no])
 elif test "x$enable_shared" = xno ; then
 	enable_symbol_versions=no
 	AC_MSG_RESULT([no (not building a shared library)])
 else
 	case $host_os in
 		linux*)
 			case "$pic_mode-$enable_static" in
 				default-*)
 					# Use symvers if PIC is defined.
 					have_symbol_versions_linux=2
 					;;
 				*-no)
 					# Not building static library.
 					# Use symvers unconditionally.
 					have_symbol_versions_linux=1
 					;;
 				*)
 					AC_MSG_RESULT([])
 					AC_MSG_ERROR([
     On GNU/Linux, building both shared and static library at the same time
     is not supported if --with-pic or --without-pic is used.
     Use either --disable-shared or --disable-static to build one type
     of library at a time. If both types are needed, build one at a time,
     possibly picking only src/liblzma/.libs/liblzma.a from the static build.])
 					;;
 			esac
 			enable_symbol_versions=linux
 			AC_DEFINE_UNQUOTED([HAVE_SYMBOL_VERSIONS_LINUX],
 				[$have_symbol_versions_linux],
 				[Define to 1 to if GNU/Linux-specific details
 				are unconditionally wanted for symbol
 				versioning. Define to 2 to if these are wanted
 				only if also PIC is defined (allows building
 				both shared and static liblzma at the same
 				time with Libtool if neither --with-pic nor
 				--without-pic is used). This define must be
 				used together with liblzma_linux.map.])
 			;;
 		*)
 			enable_symbol_versions=generic
 			;;
 	esac
 	AC_MSG_RESULT([yes ($enable_symbol_versions)])
 fi
 
 AM_CONDITIONAL([COND_SYMVERS_LINUX],
 	[test "x$enable_symbol_versions" = xlinux])
 AM_CONDITIONAL([COND_SYMVERS_GENERIC],
 	[test "x$enable_symbol_versions" = xgeneric])
 
 
 ###############################################################################
 # Checks for libraries.
 ###############################################################################
 
 dnl Support for _REQUIRE_VERSION was added in gettext 0.19.6. If both
 dnl _REQUIRE_VERSION and _VERSION are present, the _VERSION is ignored.
 dnl We use both for compatibility with other programs in the Autotools family.
 echo
 echo "Initializing gettext:"
 AM_GNU_GETTEXT_REQUIRE_VERSION([0.19.6])
 AM_GNU_GETTEXT_VERSION([0.19.6])
 AM_GNU_GETTEXT([external])
 
 
 ###############################################################################
 # Checks for header files.
 ###############################################################################
 
 echo
 echo "System headers and functions:"
 
 # There is currently no workarounds in this package if some of
 # these headers are missing.
 AC_CHECK_HEADERS([fcntl.h limits.h sys/time.h],
 	[],
 	[AC_MSG_ERROR([Required header file(s) are missing.])])
 
 # immintrin.h allows the use of the intrinsic functions if they are available.
 # cpuid.h may be used for detecting x86 processor features at runtime.
 AC_CHECK_HEADERS([immintrin.h cpuid.h])
 
 
 ###############################################################################
 # Checks for typedefs, structures, and compiler characteristics.
 ###############################################################################
 
 AC_HEADER_STDBOOL
 
 AC_TYPE_UINT8_T
 AC_TYPE_UINT16_T
 AC_TYPE_INT32_T
 AC_TYPE_UINT32_T
 AC_TYPE_INT64_T
 AC_TYPE_UINT64_T
 AC_TYPE_UINTPTR_T
 
 AC_CHECK_SIZEOF([size_t])
 
 # The command line tool can copy high resolution timestamps if such
 # information is available in struct stat. Otherwise one second accuracy
 # is used.
 AC_CHECK_MEMBERS([
 	struct stat.st_atim.tv_nsec,
 	struct stat.st_atimespec.tv_nsec,
 	struct stat.st_atimensec,
 	struct stat.st_uatime,
 	struct stat.st_atim.st__tim.tv_nsec])
 
 AC_SYS_LARGEFILE
 AC_C_BIGENDIAN
 
 # __attribute__((__constructor__)) can be used for one-time initializations.
 # Use -Werror because some compilers accept unknown attributes and just
 # give a warning. If it works this should give no warnings, even
 # clang -Weverything should be fine.
 # dnl This doesn't need AC_LANG_SOURCE, minimal code is enough.
 AC_MSG_CHECKING([if __attribute__((__constructor__)) can be used])
 have_func_attribute_constructor=no
 OLD_CFLAGS="$CFLAGS"
 CFLAGS="$CFLAGS -Werror"
 AC_COMPILE_IFELSE([
 	__attribute__((__constructor__))
 	static void my_constructor_func(void) { return; }
 ], [
 	AC_DEFINE([HAVE_FUNC_ATTRIBUTE_CONSTRUCTOR], [1],
 		[Define to 1 if __attribute__((__constructor__))
 		is supported for functions.])
 	have_func_attribute_constructor=yes
 	AC_MSG_RESULT([yes])
 ], [
 	AC_MSG_RESULT([no])
 ])
 CFLAGS="$OLD_CFLAGS"
 
 
 ###############################################################################
 # Checks for library functions.
 ###############################################################################
 
 # Gnulib replacements as needed
 gl_GETOPT
 
 # Find the best function to set timestamps.
 AC_CHECK_FUNCS([futimens futimes futimesat utimes _futime utime], [break])
 
 # This is nice to have but not mandatory.
 AC_CHECK_FUNCS([posix_fadvise])
 
 TUKLIB_PROGNAME
 TUKLIB_INTEGER
 TUKLIB_PHYSMEM
 TUKLIB_CPUCORES
 TUKLIB_MBSTR
 
 # If requested, check for system-provided SHA-256. At least the following
 # implementations are supported:
 #
 # OS       Headers                     Library  Type           Function
 # FreeBSD  sys/types.h + sha256.h      libmd    SHA256_CTX     SHA256_Init
 # NetBSD   sys/types.h + sha2.h                 SHA256_CTX     SHA256_Init
 # OpenBSD  sys/types.h + sha2.h                 SHA2_CTX       SHA256Init
 # Solaris  sys/types.h + sha2.h        libmd    SHA256_CTX     SHA256Init
 # MINIX 3  sys/types.h + sha2.h                 SHA256_CTX     SHA256_Init
 # Darwin   CommonCrypto/CommonDigest.h          CC_SHA256_CTX  CC_SHA256_Init
 #
 # Note that Darwin's CC_SHA256_Update takes buffer size as uint32_t instead
 # of size_t.
 #
 sha256_header_found=no
 sha256_type_found=no
 sha256_func_found=no
 if test "x$enable_external_sha256" = "xyes"; then
 	# Test for Common Crypto before others, because Darwin has sha256.h
 	# too and we don't want to use that, because on older versions it
 	# uses OpenSSL functions, whose SHA256_Init is not guaranteed to
 	# succeed.
 	AC_CHECK_HEADERS(
 		[CommonCrypto/CommonDigest.h sha256.h sha2.h],
 		[sha256_header_found=yes ; break])
 	if test "x$sha256_header_found" = xyes; then
 		AC_CHECK_TYPES([CC_SHA256_CTX, SHA256_CTX, SHA2_CTX],
 			[sha256_type_found=yes], [],
 			[[#ifdef HAVE_SYS_TYPES_H
 			  # include <sys/types.h>
 			  #endif
 			  #ifdef HAVE_COMMONCRYPTO_COMMONDIGEST_H
 			  # include <CommonCrypto/CommonDigest.h>
 			  #endif
 			  #ifdef HAVE_SHA256_H
 			  # include <sha256.h>
 			  #endif
 			  #ifdef HAVE_SHA2_H
 			  # include <sha2.h>
 			  #endif]])
 		if test "x$sha256_type_found" = xyes ; then
 			AC_SEARCH_LIBS([SHA256Init], [md])
 			AC_SEARCH_LIBS([SHA256_Init], [md])
 			AC_CHECK_FUNCS([CC_SHA256_Init SHA256Init SHA256_Init],
 				[sha256_func_found=yes ; break])
 		fi
 	fi
 fi
 AM_CONDITIONAL([COND_INTERNAL_SHA256], [test "x$sha256_func_found" = xno])
 if test "x$enable_external_sha256$sha256_func_found" = xyesno; then
 	AC_MSG_ERROR([--enable-external-sha256 was specified but no supported external SHA-256 implementation was found])
 fi
 
 # Check for SSE2 intrinsics. There is no run-time detection for SSE2 so if
 # compiler options enable SSE2 then SSE2 support is required by the binaries.
 # The compile-time check for SSE2 is done with #ifdefs because some compilers
 # (ICC, MSVC) allow SSE2 intrinsics even when SSE2 isn't enabled.
 AC_CHECK_DECL([_mm_movemask_epi8],
 	[AC_DEFINE([HAVE__MM_MOVEMASK_EPI8], [1],
 		[Define to 1 if _mm_movemask_epi8 is available.])],
 	[],
 [#ifdef HAVE_IMMINTRIN_H
 #include <immintrin.h>
 #endif])
 
 # For faster CRC on 32/64-bit x86 and E2K (see also crc64_fast.c):
 #
 #   - Check for the CLMUL intrinsic _mm_clmulepi64_si128 in <immintrin.h>.
 #
 #   - Check that __attribute__((__target__("ssse3,sse4.1,pclmul"))) works
 #     together with _mm_clmulepi64_si128 from <immintrin.h>. The attribute
 #     was added in GCC 4.4 but some GCC 4.x versions don't allow intrinsics
 #     with it. Exception: it must be not be used with EDG-based compilers
 #     like ICC and the compiler on E2K.
 #
 # If everything above is supported, runtime detection will be used to keep the
 # binaries working on systems that don't support the required extensions.
 AC_MSG_CHECKING([if _mm_clmulepi64_si128 is usable])
 if test "x$enable_clmul_crc" = xno ; then
 	AC_MSG_RESULT([no, --disable-clmul-crc was used])
 else
 	AC_COMPILE_IFELSE([AC_LANG_SOURCE([[
 #include <immintrin.h>
 
 // CLMUL works on older E2K instruction set but it is slow due to emulation.
 #if defined(__e2k__) && __iset__ < 6
 #	error
 #endif
 
 // Intel's old compiler (ICC) can define __GNUC__ but the attribute must not
 // be used with it. The new Clang-based ICX needs the attribute.
 // Checking for !defined(__EDG__) catches ICC and other EDG-based compilers.
 #if (defined(__GNUC__) || defined(__clang__)) && !defined(__EDG__)
 __attribute__((__target__("ssse3,sse4.1,pclmul")))
 #endif
 __m128i my_clmul(__m128i a, __m128i b)
 {
 	return _mm_clmulepi64_si128(a, b, 0);
 }
 	]])], [
 		AC_DEFINE([HAVE_USABLE_CLMUL], [1],
 			[Define to 1 if _mm_clmulepi64_si128 is usable.
 			See configure.ac for details.])
 		AC_MSG_RESULT([yes])
 	], [
 		AC_MSG_RESULT([no])
 	])
 fi
 
 # Check for sandbox support. If one is found, set enable_sandbox=found.
 case $enable_sandbox in
 	auto | capsicum)
 		AX_CHECK_CAPSICUM([enable_sandbox=found], [:])
 		;;
 esac
 case $enable_sandbox in
 	auto | pledge)
 		AC_CHECK_FUNCS([pledge], [enable_sandbox=found ; break])
 		;;
 esac
 
 # If a specific sandboxing method was explicitly requested and it wasn't
 # found, give an error.
 case $enable_sandbox in
 	auto | no | found)
 		;;
 	*)
 		AC_MSG_ERROR([$enable_sandbox support not found])
 		;;
 esac
 
 
 ###############################################################################
 # If using GCC, set some additional AM_CFLAGS:
 ###############################################################################
 
 if test "$GCC" = yes ; then
 	echo
 	echo "GCC extensions:"
 fi
 
 # Always do the visibility check but don't set AM_CFLAGS on Windows.
 # This way things get set properly even on Windows.
 gl_VISIBILITY
 if test -n "$CFLAG_VISIBILITY" && test "$is_w32" = no; then
 	AM_CFLAGS="$AM_CFLAGS $CFLAG_VISIBILITY"
 fi
 
 if test "$GCC" = yes ; then
 	# Enable as much warnings as possible. These commented warnings won't
 	# work for this package though:
 	#   * -Wunreachable-code breaks several assert(0) cases, which are
 	#     backed up with "return LZMA_PROG_ERROR".
 	#   * -Wcast-qual would break various things where we need a non-const
 	#     pointer although we don't modify anything through it.
 	#   * -Wcast-align breaks optimized CRC32 and CRC64 implementation
 	#     on some architectures (not on x86), where this warning is bogus,
 	#     because we take care of correct alignment.
 	#   * -Winline, -Wdisabled-optimization, -Wunsafe-loop-optimizations
 	#     don't seem so useful here; at least the last one gives some
 	#     warnings which are not bugs.
 	for NEW_FLAG in \
 			-Wall \
 			-Wextra \
 			-Wvla \
 			-Wformat=2 \
 			-Winit-self \
 			-Wmissing-include-dirs \
 			-Wstrict-aliasing \
 			-Wfloat-equal \
 			-Wundef \
 			-Wshadow \
 			-Wpointer-arith \
 			-Wbad-function-cast \
 			-Wwrite-strings \
 			-Wlogical-op \
 			-Waggregate-return \
 			-Wstrict-prototypes \
 			-Wold-style-definition \
 			-Wmissing-prototypes \
 			-Wmissing-declarations \
 			-Wmissing-noreturn \
 			-Wredundant-decls
 	do
 		AC_MSG_CHECKING([if $CC accepts $NEW_FLAG])
 		OLD_CFLAGS="$CFLAGS"
 		CFLAGS="$CFLAGS $NEW_FLAG -Werror"
 		AC_COMPILE_IFELSE([AC_LANG_SOURCE(
 				[void foo(void); void foo(void) { }])], [
 			AM_CFLAGS="$AM_CFLAGS $NEW_FLAG"
 			AC_MSG_RESULT([yes])
 		], [
 			AC_MSG_RESULT([no])
 		])
 		CFLAGS="$OLD_CFLAGS"
 	done
 
 	AC_ARG_ENABLE([werror],
 		AS_HELP_STRING([--enable-werror], [Enable -Werror to abort
 			compilation on all compiler warnings.]),
 		[], [enable_werror=no])
 	if test "x$enable_werror" = "xyes"; then
 		AM_CFLAGS="$AM_CFLAGS -Werror"
 	fi
 fi
 
 
 ###############################################################################
 # Create the makefiles and config.h
 ###############################################################################
 
 echo
 
 # Don't build the lib directory at all if we don't need any replacement
 # functions.
 AM_CONDITIONAL([COND_GNULIB], test -n "$LIBOBJS")
 
 # Add default AM_CFLAGS.
 AC_SUBST([AM_CFLAGS])
 
 # This is needed for src/scripts.
 xz=`echo xz | sed "$program_transform_name"`
 AC_SUBST([xz])
 
 AC_CONFIG_FILES([
 	Doxyfile
 	Makefile
 	po/Makefile.in
 	lib/Makefile
 	src/Makefile
 	src/liblzma/Makefile
 	src/liblzma/api/Makefile
 	src/xz/Makefile
 	src/xzdec/Makefile
 	src/lzmainfo/Makefile
 	src/scripts/Makefile
 	tests/Makefile
 	debug/Makefile
 ])
 AC_CONFIG_FILES([src/scripts/xzdiff], [chmod +x src/scripts/xzdiff])
 AC_CONFIG_FILES([src/scripts/xzgrep], [chmod +x src/scripts/xzgrep])
 AC_CONFIG_FILES([src/scripts/xzmore], [chmod +x src/scripts/xzmore])
 AC_CONFIG_FILES([src/scripts/xzless], [chmod +x src/scripts/xzless])
 
 AC_OUTPUT
 
 # Some warnings
 if test x$tuklib_cv_physmem_method = xunknown; then
 	echo
 	echo "WARNING:"
 	echo "No supported method to detect the amount of RAM."
 	echo "Consider using --enable-assume-ram (if you didn't already)"
 	echo "or make a patch to add support for this operating system."
 fi
 
 if test x$tuklib_cv_cpucores_method = xunknown; then
 	echo
 	echo "WARNING:"
 	echo "No supported method to detect the number of CPU cores."
 fi
 
 if test "x$enable_threads$enable_small$have_func_attribute_constructor" \
 		= xnoyesno; then
 	echo
 	echo "NOTE:"
 	echo "liblzma will be thread-unsafe due to the combination"
 	echo "of --disable-threads --enable-small when using a compiler"
 	echo "that doesn't support __attribute__((__constructor__))."
 fi
diff --git a/src/common/mythread.h b/src/common/mythread.h
index 41382183..9be90d4e 100644
--- a/src/common/mythread.h
+++ b/src/common/mythread.h
@@ -1,522 +1,522 @@
 ///////////////////////////////////////////////////////////////////////////////
 //
 /// \file       mythread.h
 /// \brief      Some threading related helper macros and functions
 //
 //  Author:     Lasse Collin
 //
 //  This file has been put into the public domain.
 //  You can do whatever you want with this file.
 //
 ///////////////////////////////////////////////////////////////////////////////
 
 #ifndef MYTHREAD_H
 #define MYTHREAD_H
 
 #include "sysdefs.h"
 
 // If any type of threading is enabled, #define MYTHREAD_ENABLED.
 #if defined(MYTHREAD_POSIX) || defined(MYTHREAD_WIN95) \
 		|| defined(MYTHREAD_VISTA)
 #	define MYTHREAD_ENABLED 1
 #endif
 
 
 #ifdef MYTHREAD_ENABLED
 
 ////////////////////////////////////////
 // Shared between all threading types //
 ////////////////////////////////////////
 
 // Locks a mutex for a duration of a block.
 //
 // Perform mythread_mutex_lock(&mutex) in the beginning of a block
 // and mythread_mutex_unlock(&mutex) at the end of the block. "break"
 // may be used to unlock the mutex and jump out of the block.
 // mythread_sync blocks may be nested.
 //
 // Example:
 //
 //     mythread_sync(mutex) {
 //         foo();
 //         if (some_error)
 //             break; // Skips bar()
 //         bar();
 //     }
 //
 // At least GCC optimizes the loops completely away so it doesn't slow
 // things down at all compared to plain mythread_mutex_lock(&mutex)
 // and mythread_mutex_unlock(&mutex) calls.
 //
 #define mythread_sync(mutex) mythread_sync_helper1(mutex, __LINE__)
 #define mythread_sync_helper1(mutex, line) mythread_sync_helper2(mutex, line)
 #define mythread_sync_helper2(mutex, line) \
 	for (unsigned int mythread_i_ ## line = 0; \
 			mythread_i_ ## line \
 				? (mythread_mutex_unlock(&(mutex)), 0) \
 				: (mythread_mutex_lock(&(mutex)), 1); \
 			mythread_i_ ## line = 1) \
 		for (unsigned int mythread_j_ ## line = 0; \
 				!mythread_j_ ## line; \
 				mythread_j_ ## line = 1)
 #endif
 
 
 #if !defined(MYTHREAD_ENABLED)
 
 //////////////////
 // No threading //
 //////////////////
 
 // Calls the given function once. This isn't thread safe.
 #define mythread_once(func) \
 do { \
 	static bool once_ = false; \
 	if (!once_) { \
 		func(); \
 		once_ = true; \
 	} \
 } while (0)
 
 
 #if !(defined(_WIN32) && !defined(__CYGWIN__))
 // Use sigprocmask() to set the signal mask in single-threaded programs.
 #include <signal.h>
 
 static inline void
 mythread_sigmask(int how, const sigset_t *restrict set,
 		sigset_t *restrict oset)
 {
 	int ret = sigprocmask(how, set, oset);
 	assert(ret == 0);
 	(void)ret;
 }
 #endif
 
 
 #elif defined(MYTHREAD_POSIX)
 
 ////////////////////
 // Using pthreads //
 ////////////////////
 
 #include <sys/time.h>
 #include <pthread.h>
 #include <signal.h>
 #include <time.h>
 #include <errno.h>
 
 #define MYTHREAD_RET_TYPE void *
 #define MYTHREAD_RET_VALUE NULL
 
 typedef pthread_t mythread;
 typedef pthread_mutex_t mythread_mutex;
 
 typedef struct {
 	pthread_cond_t cond;
 #ifdef HAVE_CLOCK_GETTIME
 	// Clock ID (CLOCK_REALTIME or CLOCK_MONOTONIC) associated with
 	// the condition variable.
 	clockid_t clk_id;
 #endif
 } mythread_cond;
 
 typedef struct timespec mythread_condtime;
 
 
 // Calls the given function once in a thread-safe way.
 #define mythread_once(func) \
 	do { \
 		static pthread_once_t once_ = PTHREAD_ONCE_INIT; \
 		pthread_once(&once_, &func); \
 	} while (0)
 
 
 // Use pthread_sigmask() to set the signal mask in multi-threaded programs.
 // Do nothing on OpenVMS since it lacks pthread_sigmask().
 static inline void
 mythread_sigmask(int how, const sigset_t *restrict set,
 		sigset_t *restrict oset)
 {
 #ifdef __VMS
 	(void)how;
 	(void)set;
 	(void)oset;
 #else
 	int ret = pthread_sigmask(how, set, oset);
 	assert(ret == 0);
 	(void)ret;
 #endif
 }
 
 
 // Creates a new thread with all signals blocked. Returns zero on success
 // and non-zero on error.
 static inline int
 mythread_create(mythread *thread, void *(*func)(void *arg), void *arg)
 {
 	sigset_t old;
 	sigset_t all;
 	sigfillset(&all);
 
 	mythread_sigmask(SIG_SETMASK, &all, &old);
 	const int ret = pthread_create(thread, NULL, func, arg);
 	mythread_sigmask(SIG_SETMASK, &old, NULL);
 
 	return ret;
 }
 
 // Joins a thread. Returns zero on success and non-zero on error.
 static inline int
 mythread_join(mythread thread)
 {
 	return pthread_join(thread, NULL);
 }
 
 
 // Initiatlizes a mutex. Returns zero on success and non-zero on error.
 static inline int
 mythread_mutex_init(mythread_mutex *mutex)
 {
 	return pthread_mutex_init(mutex, NULL);
 }
 
 static inline void
 mythread_mutex_destroy(mythread_mutex *mutex)
 {
 	int ret = pthread_mutex_destroy(mutex);
 	assert(ret == 0);
 	(void)ret;
 }
 
 static inline void
 mythread_mutex_lock(mythread_mutex *mutex)
 {
 	int ret = pthread_mutex_lock(mutex);
 	assert(ret == 0);
 	(void)ret;
 }
 
 static inline void
 mythread_mutex_unlock(mythread_mutex *mutex)
 {
 	int ret = pthread_mutex_unlock(mutex);
 	assert(ret == 0);
 	(void)ret;
 }
 
 
 // Initializes a condition variable.
 //
 // Using CLOCK_MONOTONIC instead of the default CLOCK_REALTIME makes the
 // timeout in pthread_cond_timedwait() work correctly also if system time
 // is suddenly changed. Unfortunately CLOCK_MONOTONIC isn't available
 // everywhere while the default CLOCK_REALTIME is, so the default is
 // used if CLOCK_MONOTONIC isn't available.
 //
 // If clock_gettime() isn't available at all, gettimeofday() will be used.
 static inline int
 mythread_cond_init(mythread_cond *mycond)
 {
 #ifdef HAVE_CLOCK_GETTIME
-	// NOTE: HAVE_DECL_CLOCK_MONOTONIC is always defined to 0 or 1.
-#	if defined(HAVE_PTHREAD_CONDATTR_SETCLOCK) && HAVE_DECL_CLOCK_MONOTONIC
+#	if defined(HAVE_PTHREAD_CONDATTR_SETCLOCK) && \
+		defined(HAVE_CLOCK_MONOTONIC)
 	struct timespec ts;
 	pthread_condattr_t condattr;
 
 	// POSIX doesn't seem to *require* that pthread_condattr_setclock()
 	// will fail if given an unsupported clock ID. Test that
 	// CLOCK_MONOTONIC really is supported using clock_gettime().
 	if (clock_gettime(CLOCK_MONOTONIC, &ts) == 0
 			&& pthread_condattr_init(&condattr) == 0) {
 		int ret = pthread_condattr_setclock(
 				&condattr, CLOCK_MONOTONIC);
 		if (ret == 0)
 			ret = pthread_cond_init(&mycond->cond, &condattr);
 
 		pthread_condattr_destroy(&condattr);
 
 		if (ret == 0) {
 			mycond->clk_id = CLOCK_MONOTONIC;
 			return 0;
 		}
 	}
 
 	// If anything above fails, fall back to the default CLOCK_REALTIME.
 	// POSIX requires that all implementations of clock_gettime() must
 	// support at least CLOCK_REALTIME.
 #	endif
 
 	mycond->clk_id = CLOCK_REALTIME;
 #endif
 
 	return pthread_cond_init(&mycond->cond, NULL);
 }
 
 static inline void
 mythread_cond_destroy(mythread_cond *cond)
 {
 	int ret = pthread_cond_destroy(&cond->cond);
 	assert(ret == 0);
 	(void)ret;
 }
 
 static inline void
 mythread_cond_signal(mythread_cond *cond)
 {
 	int ret = pthread_cond_signal(&cond->cond);
 	assert(ret == 0);
 	(void)ret;
 }
 
 static inline void
 mythread_cond_wait(mythread_cond *cond, mythread_mutex *mutex)
 {
 	int ret = pthread_cond_wait(&cond->cond, mutex);
 	assert(ret == 0);
 	(void)ret;
 }
 
 // Waits on a condition or until a timeout expires. If the timeout expires,
 // non-zero is returned, otherwise zero is returned.
 static inline int
 mythread_cond_timedwait(mythread_cond *cond, mythread_mutex *mutex,
 		const mythread_condtime *condtime)
 {
 	int ret = pthread_cond_timedwait(&cond->cond, mutex, condtime);
 	assert(ret == 0 || ret == ETIMEDOUT);
 	return ret;
 }
 
 // Sets condtime to the absolute time that is timeout_ms milliseconds
 // in the future. The type of the clock to use is taken from cond.
 static inline void
 mythread_condtime_set(mythread_condtime *condtime, const mythread_cond *cond,
 		uint32_t timeout_ms)
 {
 	condtime->tv_sec = timeout_ms / 1000;
 	condtime->tv_nsec = (timeout_ms % 1000) * 1000000;
 
 #ifdef HAVE_CLOCK_GETTIME
 	struct timespec now;
 	int ret = clock_gettime(cond->clk_id, &now);
 	assert(ret == 0);
 	(void)ret;
 
 	condtime->tv_sec += now.tv_sec;
 	condtime->tv_nsec += now.tv_nsec;
 #else
 	(void)cond;
 
 	struct timeval now;
 	gettimeofday(&now, NULL);
 
 	condtime->tv_sec += now.tv_sec;
 	condtime->tv_nsec += now.tv_usec * 1000L;
 #endif
 
 	// tv_nsec must stay in the range [0, 999_999_999].
 	if (condtime->tv_nsec >= 1000000000L) {
 		condtime->tv_nsec -= 1000000000L;
 		++condtime->tv_sec;
 	}
 }
 
 
 #elif defined(MYTHREAD_WIN95) || defined(MYTHREAD_VISTA)
 
 /////////////////////
 // Windows threads //
 /////////////////////
 
 #define WIN32_LEAN_AND_MEAN
 #ifdef MYTHREAD_VISTA
 #	undef _WIN32_WINNT
 #	define _WIN32_WINNT 0x0600
 #endif
 #include <windows.h>
 #include <process.h>
 
 #define MYTHREAD_RET_TYPE unsigned int __stdcall
 #define MYTHREAD_RET_VALUE 0
 
 typedef HANDLE mythread;
 typedef CRITICAL_SECTION mythread_mutex;
 
 #ifdef MYTHREAD_WIN95
 typedef HANDLE mythread_cond;
 #else
 typedef CONDITION_VARIABLE mythread_cond;
 #endif
 
 typedef struct {
 	// Tick count (milliseconds) in the beginning of the timeout.
 	// NOTE: This is 32 bits so it wraps around after 49.7 days.
 	// Multi-day timeouts may not work as expected.
 	DWORD start;
 
 	// Length of the timeout in milliseconds. The timeout expires
 	// when the current tick count minus "start" is equal or greater
 	// than "timeout".
 	DWORD timeout;
 } mythread_condtime;
 
 
 // mythread_once() is only available with Vista threads.
 #ifdef MYTHREAD_VISTA
 #define mythread_once(func) \
 	do { \
 		static INIT_ONCE once_ = INIT_ONCE_STATIC_INIT; \
 		BOOL pending_; \
 		if (!InitOnceBeginInitialize(&once_, 0, &pending_, NULL)) \
 			abort(); \
 		if (pending_) { \
 			func(); \
 			if (!InitOnceComplete(&once, 0, NULL)) \
 				abort(); \
 		} \
 	} while (0)
 #endif
 
 
 // mythread_sigmask() isn't available on Windows. Even a dummy version would
 // make no sense because the other POSIX signal functions are missing anyway.
 
 
 static inline int
 mythread_create(mythread *thread,
 		unsigned int (__stdcall *func)(void *arg), void *arg)
 {
 	uintptr_t ret = _beginthreadex(NULL, 0, func, arg, 0, NULL);
 	if (ret == 0)
 		return -1;
 
 	*thread = (HANDLE)ret;
 	return 0;
 }
 
 static inline int
 mythread_join(mythread thread)
 {
 	int ret = 0;
 
 	if (WaitForSingleObject(thread, INFINITE) != WAIT_OBJECT_0)
 		ret = -1;
 
 	if (!CloseHandle(thread))
 		ret = -1;
 
 	return ret;
 }
 
 
 static inline int
 mythread_mutex_init(mythread_mutex *mutex)
 {
 	InitializeCriticalSection(mutex);
 	return 0;
 }
 
 static inline void
 mythread_mutex_destroy(mythread_mutex *mutex)
 {
 	DeleteCriticalSection(mutex);
 }
 
 static inline void
 mythread_mutex_lock(mythread_mutex *mutex)
 {
 	EnterCriticalSection(mutex);
 }
 
 static inline void
 mythread_mutex_unlock(mythread_mutex *mutex)
 {
 	LeaveCriticalSection(mutex);
 }
 
 
 static inline int
 mythread_cond_init(mythread_cond *cond)
 {
 #ifdef MYTHREAD_WIN95
 	*cond = CreateEvent(NULL, FALSE, FALSE, NULL);
 	return *cond == NULL ? -1 : 0;
 #else
 	InitializeConditionVariable(cond);
 	return 0;
 #endif
 }
 
 static inline void
 mythread_cond_destroy(mythread_cond *cond)
 {
 #ifdef MYTHREAD_WIN95
 	CloseHandle(*cond);
 #else
 	(void)cond;
 #endif
 }
 
 static inline void
 mythread_cond_signal(mythread_cond *cond)
 {
 #ifdef MYTHREAD_WIN95
 	SetEvent(*cond);
 #else
 	WakeConditionVariable(cond);
 #endif
 }
 
 static inline void
 mythread_cond_wait(mythread_cond *cond, mythread_mutex *mutex)
 {
 #ifdef MYTHREAD_WIN95
 	LeaveCriticalSection(mutex);
 	WaitForSingleObject(*cond, INFINITE);
 	EnterCriticalSection(mutex);
 #else
 	BOOL ret = SleepConditionVariableCS(cond, mutex, INFINITE);
 	assert(ret);
 	(void)ret;
 #endif
 }
 
 static inline int
 mythread_cond_timedwait(mythread_cond *cond, mythread_mutex *mutex,
 		const mythread_condtime *condtime)
 {
 #ifdef MYTHREAD_WIN95
 	LeaveCriticalSection(mutex);
 #endif
 
 	DWORD elapsed = GetTickCount() - condtime->start;
 	DWORD timeout = elapsed >= condtime->timeout
 			? 0 : condtime->timeout - elapsed;
 
 #ifdef MYTHREAD_WIN95
 	DWORD ret = WaitForSingleObject(*cond, timeout);
 	assert(ret == WAIT_OBJECT_0 || ret == WAIT_TIMEOUT);
 
 	EnterCriticalSection(mutex);
 
 	return ret == WAIT_TIMEOUT;
 #else
 	BOOL ret = SleepConditionVariableCS(cond, mutex, timeout);
 	assert(ret || GetLastError() == ERROR_TIMEOUT);
 	return !ret;
 #endif
 }
 
 static inline void
 mythread_condtime_set(mythread_condtime *condtime, const mythread_cond *cond,
 		uint32_t timeout)
 {
 	(void)cond;
 	condtime->start = GetTickCount();
 	condtime->timeout = timeout;
 }
 
 #endif
 
 #endif
diff --git a/src/xz/mytime.c b/src/xz/mytime.c
index 70444001..a81c88af 100644
--- a/src/xz/mytime.c
+++ b/src/xz/mytime.c
@@ -1,85 +1,84 @@
 ///////////////////////////////////////////////////////////////////////////////
 //
 /// \file       mytime.c
 /// \brief      Time handling functions
 //
 //  Author:     Lasse Collin
 //
 //  This file has been put into the public domain.
 //  You can do whatever you want with this file.
 //
 ///////////////////////////////////////////////////////////////////////////////
 
 #include "private.h"
 
-#if !(defined(HAVE_CLOCK_GETTIME) && HAVE_DECL_CLOCK_MONOTONIC)
+#if !(defined(HAVE_CLOCK_GETTIME) && defined(HAVE_CLOCK_MONOTONIC))
 #	include <sys/time.h>
 #endif
 
 uint64_t opt_flush_timeout = 0;
 
 static uint64_t start_time;
 static uint64_t next_flush;
 
 
 /// \brief      Get the current time as milliseconds
 ///
 /// It's relative to some point but not necessarily to the UNIX Epoch.
 static uint64_t
 mytime_now(void)
 {
-	// NOTE: HAVE_DECL_CLOCK_MONOTONIC is always defined to 0 or 1.
-#if defined(HAVE_CLOCK_GETTIME) && HAVE_DECL_CLOCK_MONOTONIC
+#if defined(HAVE_CLOCK_GETTIME) && defined(HAVE_CLOCK_MONOTONIC)
 	// If CLOCK_MONOTONIC was available at compile time but for some
 	// reason isn't at runtime, fallback to CLOCK_REALTIME which
 	// according to POSIX is mandatory for all implementations.
 	static clockid_t clk_id = CLOCK_MONOTONIC;
 	struct timespec tv;
 	while (clock_gettime(clk_id, &tv))
 		clk_id = CLOCK_REALTIME;
 
 	return (uint64_t)tv.tv_sec * 1000 + (uint64_t)(tv.tv_nsec / 1000000);
 #else
 	struct timeval tv;
 	gettimeofday(&tv, NULL);
 	return (uint64_t)tv.tv_sec * 1000 + (uint64_t)(tv.tv_usec / 1000);
 #endif
 }
 
 
 extern void
 mytime_set_start_time(void)
 {
 	start_time = mytime_now();
 	return;
 }
 
 
 extern uint64_t
 mytime_get_elapsed(void)
 {
 	return mytime_now() - start_time;
 }
 
 
 extern void
 mytime_set_flush_time(void)
 {
 	next_flush = mytime_now() + opt_flush_timeout;
 	return;
 }
 
 
 extern int
 mytime_get_flush_timeout(void)
 {
 	if (opt_flush_timeout == 0 || opt_mode != MODE_COMPRESS)
 		return -1;
 
 	const uint64_t now = mytime_now();
 	if (now >= next_flush)
 		return 0;
 
 	const uint64_t remaining = next_flush - now;
 	return remaining > INT_MAX ? INT_MAX : (int)remaining;
 }