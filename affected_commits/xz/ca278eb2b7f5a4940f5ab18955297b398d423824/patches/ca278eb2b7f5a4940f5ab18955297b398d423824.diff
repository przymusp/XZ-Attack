commit ca278eb2b7f5a4940f5ab18955297b398d423824
Author: Jia Tan <jiat0218@gmail.com>
Date:   Fri Nov 17 20:35:11 2023 +0800

    Tests: Create test_suffix.sh.
    
    This tests some complicated interactions with the --suffix= option.
    The suffix option must be used with --format=raw, but can optionally
    be used to override the default .xz suffix.
    
    This test also verifies some recent bugs have been correctly solved
    and to hopefully avoid further regressions in the future.

diff --git a/tests/Makefile.am b/tests/Makefile.am
index ebc33a7b..8a0ec53e 100644
--- a/tests/Makefile.am
+++ b/tests/Makefile.am
@@ -1,76 +1,78 @@
 ##
 ## Author: Lasse Collin
 ##
 ## This file has been put into the public domain.
 ## You can do whatever you want with this file.
 ##
 
 EXTRA_DIST = \
 	files \
 	ossfuzz \
 	tuktest.h \
 	tests.h \
 	test_files.sh \
 	test_compress.sh \
 	test_compress_prepared_bcj_sparc \
 	test_compress_prepared_bcj_x86 \
 	test_compress_generated_abc \
 	test_compress_generated_random \
 	test_compress_generated_text \
 	test_scripts.sh \
+	test_suffix.sh \
 	bcj_test.c \
 	compress_prepared_bcj_sparc \
 	compress_prepared_bcj_x86 \
 	xzgrep_expected_output
 
 AM_CPPFLAGS = \
 	-I$(top_srcdir)/src/common \
 	-I$(top_srcdir)/src/liblzma/api \
 	-I$(top_srcdir)/src/liblzma
 
 LDADD = $(top_builddir)/src/liblzma/liblzma.la
 
 LDADD += $(LTLIBINTL)
 
 check_PROGRAMS = \
 	create_compress_files \
 	test_check \
 	test_hardware \
 	test_stream_flags \
 	test_filter_flags \
 	test_filter_str \
 	test_block_header \
 	test_index \
 	test_index_hash \
 	test_bcj_exact_size \
 	test_memlimit \
 	test_lzip_decoder \
 	test_vli
 
 TESTS = \
 	test_check \
 	test_hardware \
 	test_stream_flags \
 	test_filter_flags \
 	test_filter_str \
 	test_block_header \
 	test_index \
 	test_index_hash \
 	test_bcj_exact_size \
 	test_memlimit \
 	test_lzip_decoder \
 	test_vli \
 	test_files.sh \
+	test_suffix.sh \
 	test_compress_prepared_bcj_sparc \
 	test_compress_prepared_bcj_x86 \
 	test_compress_generated_abc \
 	test_compress_generated_random \
 	test_compress_generated_text
 
 if COND_SCRIPTS
 TESTS += test_scripts.sh
 endif
 
 clean-local:
 	-rm -f compress_generated_* \
 		xzgrep_test_output xzgrep_test_1.xz xzgrep_test_2.xz
diff --git a/tests/test_suffix.sh b/tests/test_suffix.sh
new file mode 100755
index 00000000..f90ff7ab
--- /dev/null
+++ b/tests/test_suffix.sh
@@ -0,0 +1,189 @@
+#!/bin/sh
+
+###############################################################################
+#
+# Author: Jia Tan
+#
+# This file has been put into the public domain.
+# You can do whatever you want with this file.
+#
+###############################################################################
+
+# If xz was not built, skip this test.
+XZ=../src/xz/xz
+test -x "$XZ" || XZ=
+if test -z "$XZ"; then
+	echo "xz was not built, skipping this test."
+	exit 77
+fi
+
+# If compression or decompression support is missing, this test is skipped.
+# This isn't perfect because it does not specifically check for LZMA1/2
+# filters. Many of the other tests also assume LZMA1/2 support if encoders
+# or decoders are enabled.
+if grep 'define HAVE_ENCODERS' ../config.h > /dev/null \
+		&& grep 'define HAVE_DECODERS' ../config.h > /dev/null ; then
+	:
+else
+	echo "Compression or decompression support is disabled, skipping this test."
+	exit 77
+fi
+
+# Create temporary input file. The file contents are not important.
+SUFFIX_INPUT="suffix_temp"
+SUFFIX_INPUT_FILES="$SUFFIX_INPUT"_files
+SUFFIX_INPUT_FILES0="$SUFFIX_INPUT"_files0
+
+# Remove possible leftover temporary files
+rm -f \
+	"$SUFFIX_INPUT" \
+	"$SUFFIX_INPUT.foo" \
+	"$SUFFIX_INPUT_FILES" \
+	"$SUFFIX_INPUT_FILES"
+
+echo "foobar" > "$SUFFIX_INPUT"
+
+# Test basic suffix when compressing with raw format.
+if "$XZ" -zfk --suffix=".foo" -Fraw --lzma1=preset=0 "$SUFFIX_INPUT" ; then
+	:
+else
+	echo "Failed to compress a file with a suffix set in raw format"
+	exit 1
+fi
+
+# Test the output file is named properly.
+if test -f "$SUFFIX_INPUT.foo" ; then
+	:
+else
+	echo "Raw format compressed output file not named properly"
+	exit 1
+fi
+
+# Expect an error when compressing with raw format without a suffix
+if "$XZ" -zfk -Fraw --lzma1=preset=0 "$SUFFIX_INPUT" 2> /dev/null; then
+	echo "Error not reported when compressing in raw format without a suffix"
+	exit 1
+fi
+
+# Expect an error when decompressing with raw format without a suffix
+if "$XZ" -df -Fraw --lzma1=preset=0 "$SUFFIX_INPUT.foo" 2> /dev/null; then
+	echo "Error not reported when decompressing in raw format without a suffix"
+	exit 1
+fi
+
+# Test basic decompression with raw format and a suffix. This will also
+# delete $SUFFIX_INPUT.foo
+if "$XZ" -df --suffix=".foo" -Fraw --lzma1=preset=0 "$SUFFIX_INPUT.foo"; then
+	:
+else
+	echo "Failed to decompress a file with a suffix set in raw format"
+	exit 1
+fi
+
+# Test basic compression with .xz format and a suffix
+if "$XZ" -zfk --suffix=".foo" --lzma2=preset=0 "$SUFFIX_INPUT" ; then
+	:
+else
+	echo "Failed to compress a file with a suffix set in .xz format"
+	exit 1
+fi
+
+# Test the output file is named properly.
+if test -f "$SUFFIX_INPUT.foo" ; then
+	:
+else
+	echo ".xz format compressed output file named properly"
+	exit 1
+fi
+
+# This will delete $SUFFIX_INPUT.foo
+if "$XZ" -df --suffix=".foo" "$SUFFIX_INPUT.foo"; then
+	:
+else
+	echo "Failed to decompress a file with a suffix set in .xz format"
+	exit 1
+fi
+
+# Test reading from stdin in raw mode. This was broken in
+# cc5aa9ab138beeecaee5a1e81197591893ee9ca0 and fixed in
+# 837ea40b1c9d4998cac4500b55171bf33e0c31a6
+if echo foo | "$XZ" -Fraw --lzma1=preset=0 > /dev/null ; then
+	:
+else
+	echo "Implicit write to stdout not detected"
+	exit 1
+fi
+
+# Create two temporary files to be used with --files and --files0.
+printf "$SUFFIX_INPUT\n" > "$SUFFIX_INPUT_FILES"
+printf "$SUFFIX_INPUT\0" > "$SUFFIX_INPUT_FILES0"
+
+# Test proper handling of --files/--files0 when no suffix is set. This
+# must result in an error because xz does not know how to rename the output
+# file from the input files. This caused a segmentation fault due to a
+# mistake in f481523baac946fa3bc13d79186ffaf0c0b818a7, which was fixed by
+# 0a601ddc89fd7e1370807c6b58964f361dfcd34a.
+if "$XZ" -Fraw --lzma1=preset=0 --files="$SUFFIX_INPUT_FILES" 2> /dev/null ; then
+	echo "Failed to report error when compressing a file specified by --files in raw mode without a suffix"
+	exit 1
+fi
+
+if "$XZ" -Fraw --lzma1=preset=0 --files0="$SUFFIX_INPUT_FILES0" 2> /dev/null ; then
+	echo "Failed to report error when compressing a file specified by --files0 in raw mode without a suffix"
+	exit 1
+fi
+
+# Test proper suffix usage in raw mode with --files and --files0.
+if "$XZ" -zfk -Fraw --lzma1=preset=0 --suffix=.foo --files="$SUFFIX_INPUT_FILES" ; then
+	:
+else
+	echo "Error compressing a file specified by --files in raw mode with a suffix set"
+	exit 1
+fi
+
+if test -f "$SUFFIX_INPUT.foo" ; then
+	:
+else
+	echo "Entry processed by --files not named properly"
+	exit 1
+fi
+
+# Remove the artifact so we can be sure the next test executes properly.
+rm "$SUFFIX_INPUT.foo"
+
+if "$XZ" -zfk -Fraw --lzma1=preset=0 --suffix=.foo --files0="$SUFFIX_INPUT_FILES0" ; then
+	:
+else
+	echo "Error compressing a file specified by --files0 in raw mode with a suffix set"
+	exit 1
+fi
+
+if test -f "$SUFFIX_INPUT.foo" ; then
+	:
+else
+	echo "Entry processed by --files0 not named properly"
+	exit 1
+fi
+
+# When the file type cannot be determined by xz, it will copy the contents
+# of the file only if -c,--stdout is used. This was broken by
+# 837ea40b1c9d4998cac4500b55171bf33e0c31a6 and fixed by
+# f481523baac946fa3bc13d79186ffaf0c0b818a7.
+if echo foo | "$XZ" -df > /dev/null 2>&1; then
+	echo "Failed to report error when decompressing unknown file type without -c,--stdout"
+	exit 1
+fi
+
+if echo foo | "$XZ" -dfc > /dev/null; then
+	:
+else
+	echo "Failed to copy input to standard out when decompressing unknown file type with -c,--stdout"
+	exit 1
+fi
+
+# Remove remaining test artifacts
+rm -f \
+	"$SUFFIX_INPUT" \
+	"$SUFFIX_INPUT.foo" \
+	"$SUFFIX_INPUT_FILES" \
+	"$SUFFIX_INPUT_FILES0"