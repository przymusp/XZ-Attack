commit 5002beb278901538a914b425845439465b9410c7
Author: jiat75 <jiat0218@gmail.com>
Date:   Tue May 17 20:44:19 2022 +0800

    Color coding is now optional. Removed timing metrics. Removed __FUNCTION__ macro because it is not always compatible

diff --git a/README.md b/README.md
index 13aca8a..84f083c 100644
--- a/README.md
+++ b/README.md
@@ -1,97 +1,104 @@
 # STest
 
 ## About
 **STest** is a unit testing framework for C/C++ based on Keith Nicholas's Seatest. **STest** is an xUnit style of unit testing framework, and is made to be portable. Installing **STest** is as easy as dropping the **stest.c** and **stest.h** files into your project.
 
 ## Features
 - xUnit style asserts
 - Easily extensible for custom asserts
 - Optional color-coded output
 - Cross platform in any C/C++ project
 - Supports global set-up and tear-down functions
 - Supports per-test set-up and tear-down functions
 - Ability to selectively run tests and fixtures
 
 ## Asserts
 | Assert | Arguments | Meaning |
 |--------|-----------| ----------- |
 |assert_true| int test | Asserts test is non-zero|
 |assert_false| int test | Asserts test is zero|
 |assert_int_equal| int expected, int actual| Asserts expected == actual|
 |assert_ulong_equal| unsigned long expected, unsigned long actual| Asserts expected == actual|
 |assert_string_equal| char* expected, char* actual| Asserts all characters of expected equal all characters of actual|
 |assert_n_array_equal| void* expected, void* actual, int n| Asserts first n elements from expected to actual|
 |assert_bit_set| int bit_number, int value| Asserts the bit_number in value is set to a 1|
 |assert_bit_not_set| int bit_number, int value| Asserts the bit_number in value is set to a 0
 |assert_bit_mask_matches| \<size> value, \<size> mask|Asserts all 1 bits in mask are set to 1 in value|
 |assert_fail| char* message | Automatic failing test with a custom message|
 |assert_float_equal| float expected, float actual, float delta| Asserts expected is within delta above or below value|
 |assert_double_equal|double expected, double actual, double delta| Asserts expected is within delta above or below value|
 |assert_string_contains| char* contained, char* container| Asserts contained is a substring of container|
 |assert_string_not_contains|char* contained, char* container| Asserts contained is not a substring of container|
 |assert_string_starts_with| char* contained, char* container| Asserts container begins with contained|
 |assert_string_ends_with| char* contained, char* container| Asserts container ends with contained|
 
 ## Command Line Arguments
 The test runner can be run with a few simple command line arguments.
 
 | Option           | Meaning                                          |
 | -----------------| -------------------------------------------------|
 | -d               | Display tests, do not run tests                  |
 | -v               | Run tests in verbose mode                        |
 | -vs              | Alternative display mode                         |
 | -t \<testname>   | Only run tests that match \<testname>            |
 | -f \<fixturename>| Only run fixtures that match \<fixturename>      |
 | -m               | Output machine readable                          |
 | -s               | Skip the rest of the test when an assert fails   |
 | -k \<marker>     | prepend \<marker> before machine readable output |
+| -c               | Color code output (green success, red failure)   |
 | help             | Output help message                              |
 
 ## Example Usage
 
 ```C
 // Sample test
-void my_test() {
+STEST(my_test)
   int actual = 10;
   assert_int_equal(10, actual);
 
   char *actual_str = "Hello World";
   assert_string_contains("Hello", actual_str);
 }
 
-// Another sample Test
-void another_test() {
+STEST_HELPER(int, helper, int arg1, int arg2)
+  assert_true(arg2 > arg1);
+  return arg2 - arg1;
+}
+
+// Another sample Test calling a helper function
+STEST(another_test)
   assert_true(1);
   assert_false(0);
+  assert_int_equal(helper(1, 2));
 }
 
 // Sample fixture
 // Fixtures are a collection of related tests
 void test_fixture() {
   test_fixture_start();
   run_test(my_test());
   another_test();
   test_fixture_end();
 }
 
 // Sample test suite
 // Should combine all fixtures that belong in the suite
 void run_all_tests() { test_fixture(); }
 
 // Keep main simple to run all of your test suites
 int main(int argc, char **argv) {
   return stest_testrunner(argc, argv, run_all_tests, NULL, NULL);
 }
 ```
 
 ## Contributing
 
 I am happy to accept pull requests for bug fixes and new features. Here are the suggested steps:
 1. Fork the repository
 2. Create a new branch
 3. Implement your feature
 4. Reformat your code with the provided .clang-format file
 5. Add your commits
 6. Create a pull request to master
 
 I will try to keep the issues tab updated with improvements I am envisioning. 
\ No newline at end of file
diff --git a/src/stest.c b/src/stest.c
index 9fe291f..19639ee 100644
--- a/src/stest.c
+++ b/src/stest.c
@@ -1,624 +1,574 @@
 /*
- * Copyright (c) 2021 Jia Tan
  * Copyright (c) 2010 Keith Nicholas
+ * Copyright (c) 2021 Jia Tan
  */
 
 #include "stest.h"
-#include <string.h>
 #include <setjmp.h>
+#include <stdio.h>
+#include <string.h>
 
 #ifdef STEST_INTERNAL_TESTS
 static int stest_last_passed = 0;
 #endif
 
 #define STEST_RET_ERROR (-1)
 #define STEST_RET_OK 0
 #define STEST_RET_FAILED_COUNT(tests_failed_count) (tests_failed_count)
 
 #define STEST_GREEN "\e[0;32m"
 #define STEST_RED "\e[0;31m"
 #define STEST_COLOR_RESET "\e[0m"
 
 typedef enum {
   STEST_DISPLAY_TESTS,
   STEST_RUN_TESTS,
   STEST_DO_NOTHING,
   STEST_DO_ABORT
 } stest_action_t;
 
 typedef struct {
   int argc;
   char **argv;
   stest_action_t action;
 } stest_testrunner_t;
 
 static int stest_screen_width = 70;
 static int stests_run = 0;
 static int stests_passed = 0;
 static int stests_failed = 0;
 static int stest_display_only = 0;
 static int stest_verbose = 0;
-static int stest_skip_test_if_assert_fails = 0;
 static int vs_mode = 0;
 static int stest_machine_readable = 0;
 static int stest_color_output = 0;
 static const char *stest_current_fixture;
 static const char *stest_current_fixture_path;
 static char stest_magic_marker[20];
 static int stest_fixture_tests_run = 0;
 static int stest_fixture_tests_failed = 0;
 static const char *stest_fixture_filter;
 static const char *stest_test_filter;
 
+static jmp_buf env;
+static int skip_failed_test;
+
 static stest_void_void stest_suite_setup_func = 0;
 static stest_void_void stest_suite_teardown_func = 0;
 static stest_void_void stest_fixture_setup = 0;
 static stest_void_void stest_fixture_teardown = 0;
 
-static jmp_buf env;
-
-unsigned int GetTickCount(void);
-int stest_is_string_equal_i(const char *s1, const char *s2);
 int stest_is_display_only(void);
 const char *test_file_name(const char *path);
 static int stest_can_color(void);
 void stest_header_printer(const char *s, int s_len, int length, char f);
 void set_magic_marker(const char *marker);
 void stest_show_help(void);
 int stest_commandline_has_value_after(stest_testrunner_t *runner, int arg);
 int stest_parse_commandline_option_with_value(stest_testrunner_t *runner,
                                               int arg, const char *option,
                                               stest_void_string setter);
 void stest_interpret_commandline(stest_testrunner_t *runner);
 void stest_testrunner_create(stest_testrunner_t *runner, int argc, char **argv);
 
-#define SECONDS_TO_MILLISECONDS(sec) sec * 1000
-#define MICRO_SECONDS_TO_MILLISECONDS(microsec) microsec / 1000
-
-#ifdef WIN32
-#include "windows.h"
-int stest_is_string_equal_i(const char *s1, const char *s2) {
-#pragma warning(disable : 4996)
-  return stricmp(s1, s2) == 0;
-}
-
-#else
-#include <strings.h>
-#include <sys/time.h>
-#include <unistd.h>
-
-unsigned int GetTickCount(void) {
-  struct timeval current_time;
-  gettimeofday(&current_time, NULL);
-  return SECONDS_TO_MILLISECONDS(current_time.tv_sec) +
-         MICRO_SECONDS_TO_MILLISECONDS(current_time.tv_usec);
-}
-
-int stest_is_string_equal_i(const char *s1, const char *s2) {
-  return strcasecmp(s1, s2) == 0;
-}
-
-#endif
-
 void (*stest_simple_test_result)(int passed, const char *reason,
                                  const char *function, unsigned int line) =
     stest_simple_test_result_log;
 
 void suite_setup(stest_void_void setup) { stest_suite_setup_func = setup; }
 void suite_teardown(stest_void_void teardown) {
   stest_suite_teardown_func = teardown;
 }
 
 int stest_is_display_only(void) { return stest_display_only; }
 
 void stest_suite_setup(void) {
   if(stest_suite_setup_func != 0)
     stest_suite_setup_func();
 }
 
 void stest_suite_teardown(void) {
   if(stest_suite_teardown_func != 0)
     stest_suite_teardown_func();
 }
 
 void fixture_setup(void (*setup)(void)) { stest_fixture_setup = setup; }
 void fixture_teardown(void (*teardown)(void)) {
   stest_fixture_teardown = teardown;
 }
 
 void stest_setup(void) {
   if(stest_fixture_setup != 0)
     stest_fixture_setup();
 }
 
 void stest_teardown(void) {
   if(stest_fixture_teardown != 0)
     stest_fixture_teardown();
 }
 
 const char *test_file_name(const char *path) {
   char *file = (char *)path + strlen(path);
   while(file != path && *file != '\\' && *file != '/')
     file--;
   if(*file == '\\' || *file == '/')
     file++;
   return file;
 }
 
 static int stest_can_color(void) { return stest_color_output; }
 
-static void stest_determine_color_output(FILE *standard_out) {
-#ifdef WIN32
-  // Output coloring is not supported on windows
-  stest_color_output = 0;
-#else
-  stest_color_output = isatty(fileno(standard_out));
-#endif
-}
-
 static void stest_add_color(char *outstr, const char *instr,
                             const char *color) {
   if(stest_can_color()) {
     sprintf(outstr, "%s%s%s", color, instr, STEST_COLOR_RESET);
   }
   else {
     strcpy(outstr, instr);
   }
 }
 
 static void stest_log_failure(const char *reason, const char *function,
                               unsigned int line) {
-  char failed[100];
+  char failed[STEST_PRINT_BUFFER_SIZE];
   stest_add_color(failed, reason, STEST_RED);
   if(vs_mode) {
     printf("%s (%u)		%s,%s\r\n", stest_current_fixture_path, line,
            function, failed);
   }
   else {
     printf("%-30s Line %-5d %s\r\n", function, line, failed);
   }
 }
 
 static void stest_log_success(const char *function, unsigned int line) {
-  char passed[30];
+  char passed[STEST_PRINT_BUFFER_SIZE];
   stest_add_color(passed, "Passed", STEST_GREEN);
   printf("%-30s Line %-5d %s\r\n", function, line, passed);
 }
 
 void stest_simple_test_result_log(int passed, const char *reason,
                                   const char *function, unsigned int line) {
   if(!passed) {
 
     if(stest_machine_readable) {
       if(vs_mode) {
         printf("%s (%u)		%s,%s\r\n", stest_current_fixture_path, line,
                function, reason);
       }
       else {
         printf("%s%s,%s,%u,%s\r\n", stest_magic_marker,
                stest_current_fixture_path, function, line, reason);
       }
     }
     else {
       stest_log_failure(reason, function, line);
     }
     stests_failed++;
-    if(stest_skip_test_if_assert_fails){
-      longjmp(env, 1);
-    }
+
+    printf("Test has been finished with failure.\r\n");
+    longjmp(env, 1);
   }
   else {
     if(stest_verbose) {
       if(stest_machine_readable) {
         printf("%s%s,%s,%u,Passed\r\n", stest_magic_marker,
                stest_current_fixture_path, function, line);
       }
       else {
         stest_log_success(function, line);
       }
     }
     stests_passed++;
   }
 }
 
 void stest_assert_true(int test, const char *function, unsigned int line) {
   stest_simple_test_result(test, "Should have been true", function, line);
 }
 
 void stest_assert_false(int test, const char *function, unsigned int line) {
   stest_simple_test_result(!test, "Should have been false", function, line);
 }
 
 void stest_assert_int_equal(int expected, int actual, const char *function,
                             unsigned int line) {
   char s[STEST_PRINT_BUFFER_SIZE];
   sprintf(s, "Expected %d but was %d", expected, actual);
   stest_simple_test_result(expected == actual, s, function, line);
 }
 
 void stest_assert_ulong_equal(unsigned long expected, unsigned long actual,
                               const char *function, unsigned int line) {
   char s[STEST_PRINT_BUFFER_SIZE];
   sprintf(s, "Expected %lu but was %lu", expected, actual);
   stest_simple_test_result(expected == actual, s, function, line);
 }
 
 void stest_assert_float_equal(float expected, float actual, float delta,
                               const char *function, unsigned int line) {
   char s[STEST_PRINT_BUFFER_SIZE];
   float result = expected - actual;
   sprintf(s, "Expected %f but was %f", expected, actual);
   if(result < 0.0)
     result = 0.0f - result;
   stest_simple_test_result(result <= delta, s, function, line);
 }
 
 void stest_assert_double_equal(double expected, double actual, double delta,
                                const char *function, unsigned int line) {
   char s[STEST_PRINT_BUFFER_SIZE];
   double result = expected - actual;
   sprintf(s, "Expected %f but was %f", expected, actual);
   if(result < 0.0)
     result = 0.0 - result;
   stest_simple_test_result(result <= delta, s, function, line);
 }
 
 void stest_assert_string_equal(const char *expected, const char *actual,
                                const char *function, unsigned int line) {
   int comparison;
   char s[STEST_PRINT_BUFFER_SIZE];
 
   if((expected == (char *)0) && (actual == (char *)0)) {
     sprintf(s, "Expected <NULL> but was <NULL>");
     comparison = 1;
   }
   else if(expected == (char *)0) {
     sprintf(s, "Expected <NULL> but was %s", actual);
     comparison = 0;
   }
   else if(actual == (char *)0) {
     sprintf(s, "Expected %s but was <NULL>", expected);
     comparison = 0;
   }
   else {
     comparison = strcmp(expected, actual) == 0;
     sprintf(s, "Expected %s but was %s", expected, actual);
   }
 
   stest_simple_test_result(comparison, s, function, line);
 }
 
 void stest_assert_string_ends_with(const char *expected, const char *actual,
                                    const char *function, unsigned int line) {
   char s[STEST_PRINT_BUFFER_SIZE];
   sprintf(s, "Expected %s to end with %s", actual, expected);
   stest_simple_test_result(
       strcmp(expected, actual + (strlen(actual) - strlen(expected))) == 0, s,
       function, line);
 }
 
 void stest_assert_string_starts_with(const char *expected, const char *actual,
                                      const char *function, unsigned int line) {
   char s[STEST_PRINT_BUFFER_SIZE];
   sprintf(s, "Expected %s to start with %s", actual, expected);
   stest_simple_test_result(strncmp(expected, actual, strlen(expected)) == 0, s,
                            function, line);
 }
 
 void stest_assert_string_contains(const char *expected, const char *actual,
                                   const char *function, unsigned int line) {
   char s[STEST_PRINT_BUFFER_SIZE];
   sprintf(s, "Expected %s to be in %s", expected, actual);
   stest_simple_test_result(strstr(actual, expected) != 0, s, function, line);
 }
 
 void stest_assert_string_not_contains(const char *expected, const char *actual,
                                       const char *function, unsigned int line) {
   char s[STEST_PRINT_BUFFER_SIZE];
   sprintf(s, "Expected %s not to have %s in it", actual, expected);
   stest_simple_test_result(strstr(actual, expected) == 0, s, function, line);
 }
 
 void stest_header_printer(const char *s, int s_len, int length, char f) {
   int d = (length - (s_len + 2)) / 2;
   int i;
   if(stest_is_display_only() || stest_machine_readable)
     return;
   for(i = 0; i < d; i++)
     printf("%c", f);
   if(s_len == 0)
     printf("%c%c", f, f);
   else
     printf(" %s ", s);
   for(i = (d + s_len + 2); i < length; i++)
     printf("%c", f);
   printf("\r\n");
 }
 
 void stest_test_fixture_start(const char *filepath) {
   stest_current_fixture_path = filepath;
   stest_current_fixture = test_file_name(filepath);
 
   if(!stest_should_run_fixture(stest_current_fixture)) {
     return;
   }
 
   if(stest_is_display_only()) {
     printf("Fixture: %s\n", stest_current_fixture);
   }
   else {
     stest_header_printer(stest_current_fixture, strlen(stest_current_fixture),
                          stest_screen_width, '-');
     stest_fixture_tests_failed = stests_failed;
     stest_fixture_tests_run = stests_run;
   }
 
   stest_fixture_teardown = 0;
   stest_fixture_setup = 0;
 }
 
 void stest_test_fixture_end(void) {
   char s[STEST_PRINT_BUFFER_SIZE];
   sprintf(s, "%d run %d failed", stests_run - stest_fixture_tests_run,
           stests_failed - stest_fixture_tests_failed);
   stest_header_printer(s, strlen(s), stest_screen_width, ' ');
   if(stest_is_display_only() || stest_machine_readable)
     return;
   printf("\r\n");
 }
 
 void fixture_filter(const char *filter) { stest_fixture_filter = filter; }
 
 void test_filter(const char *filter) { stest_test_filter = filter; }
 
 void set_magic_marker(const char *marker) {
   if(marker == NULL)
     return;
   strcpy(stest_magic_marker, marker);
 }
 
 int stest_should_run_test(const char *test) {
   int run = 1;
 
   if(stest_fixture_filter) {
     if(strncmp(stest_fixture_filter, stest_current_fixture,
                strlen(stest_fixture_filter)) != 0)
       run = 0;
   }
 
   if(stest_test_filter && test != NULL) {
     if(strncmp(stest_test_filter, test, strlen(stest_test_filter)) != 0)
       run = 0;
   }
 
   return run;
 }
 
 int stest_should_run_fixture(const char *fixture) {
   int run = 1;
 
   if(stest_fixture_filter) {
     if(strncmp(stest_fixture_filter, fixture, strlen(stest_fixture_filter)) !=
        0)
       run = 0;
   }
 
   return run;
 }
 
 void stest_test(const char *test, void (*test_function)(void)) {
   if(!stest_should_run_test(test)) {
     return;
   }
 
   if(stest_is_display_only()) {
     printf("%s\n", test);
+    return;
   }
 
   stest_suite_setup();
   stest_setup();
 
-  if(stest_skip_test_if_assert_fails){
-    int skip_failed_test = setjmp(env);
-    if(!skip_failed_test){
-      test_function();
-    }
-  }
-  else {
+  skip_failed_test = setjmp(env);
+  if(!skip_failed_test)
     test_function();
-  }
-  
+
   stest_teardown();
   stest_suite_teardown();
   stests_run++;
 }
 
 int run_tests(stest_void_void tests) {
-  unsigned long end;
-  unsigned long start = GetTickCount();
   char s[40];
   tests();
-  end = GetTickCount();
 
   if(stest_is_display_only() || stest_machine_readable)
     return STEST_RET_OK;
-  printf("\r\n");
   if(stests_failed > 0) {
     if(stest_machine_readable) {
       stest_header_printer("Failed", sizeof("Failed") - 1, stest_screen_width,
                            ' ');
     }
     else {
       char failed[30];
       stest_add_color(failed, "failed", STEST_RED);
       stest_header_printer(failed, sizeof("Failed") - 1, stest_screen_width,
                            ' ');
     }
   }
   else {
     if(stest_machine_readable) {
       stest_header_printer("ALL TESTS PASSED", sizeof("ALL TESTS PASSED") - 1,
                            stest_screen_width, ' ');
     }
     else {
       char passed[30];
       stest_add_color(passed, "ALL TESTS PASSED", STEST_GREEN);
       stest_header_printer(passed, sizeof("ALL TESTS PASSED") - 1,
                            stest_screen_width, ' ');
     }
   }
   if(stests_run == 1) {
     strcpy(s, "1 test run");
   }
   else {
     sprintf(s, "%d tests run", stests_run);
   }
   stest_header_printer(s, strlen(s), stest_screen_width, ' ');
-  sprintf(s, "in %lu ms", end - start);
-  stest_header_printer(s, strlen(s), stest_screen_width, ' ');
   printf("\r\n");
   stest_header_printer("", sizeof("") - 1, stest_screen_width, '=');
 
   return STEST_RET_FAILED_COUNT(stests_failed);
 }
 
 void stest_show_help(void) {
   printf("Usage: [-t <testname>] [-f <fixturename>] [-d] [-h | --help] [-v] "
          "[-m] [-k <marker>]\r\n");
   printf("Flags:\r\n");
   printf("\thelp:\twill display this help\r\n");
   printf("\t-t:\twill only run tests that match <testname>\r\n");
   printf("\t-f:\twill only run fixtures that match <fixturename>\r\n");
   printf("\t-d:\twill just display test names and fixtures without\r\n");
   printf("\t\trunning the test\r\n");
   printf("\t-v:\twill print a more verbose version of the test run\r\n");
   printf("\t-m:\twill print a machine readable format of the test run, ie :- "
          "\r\n");
   printf("\t   \t<textfixture>,<testname>,<linenumber>,<testresult><EOL>\r\n");
-  printf("\t-s:\twill skip the rest of the test function when an assert fails\r\n");
   printf("\t-k:\twill prepend <marker> before machine readable output \r\n");
   printf("\t   \t<marker> cannot start with a '-'\r\n");
+  printf("\t-c:\twill color output with ANSI escape codes\r\n");
 }
 
 int stest_commandline_has_value_after(stest_testrunner_t *runner, int arg) {
   if(!((arg + 1) < runner->argc))
     return 0;
   if(runner->argv[arg + 1][0] == '-')
     return 0;
   return 1;
 }
 
 int stest_parse_commandline_option_with_value(stest_testrunner_t *runner,
                                               int arg, const char *option,
                                               stest_void_string setter) {
-  if(stest_is_string_equal_i(runner->argv[arg], option)) {
+  if(!strcmp(runner->argv[arg], option)) {
     if(!stest_commandline_has_value_after(runner, arg)) {
       printf("Error: The %s option expects to be followed by a value\r\n",
              option);
       runner->action = STEST_DO_ABORT;
       return 0;
     }
     setter(runner->argv[arg + 1]);
     return 1;
   }
   return 0;
 }
 
 void stest_interpret_commandline(stest_testrunner_t *runner) {
   int arg;
   for(arg = 1; (arg < runner->argc) && (runner->action != STEST_DO_ABORT);
       arg++) {
-    if(stest_is_string_equal_i(runner->argv[arg], "--help") ||
-       stest_is_string_equal_i(runner->argv[arg], "-h")) {
+    if(!strncmp(runner->argv[arg], "--help", sizeof("--help")) ||
+       !strncmp(runner->argv[arg], "-h", sizeof("-h"))) {
       stest_show_help();
       runner->action = STEST_DO_NOTHING;
       return;
     }
-    else if(stest_is_string_equal_i(runner->argv[arg], "-d"))
+    else if(!strncmp(runner->argv[arg], "-d", sizeof("-d")))
       runner->action = STEST_DISPLAY_TESTS;
-    else if(stest_is_string_equal_i(runner->argv[arg], "-v"))
+    else if(!strncmp(runner->argv[arg], "-v", sizeof("-v")))
       stest_verbose = 1;
-    else if(stest_is_string_equal_i(runner->argv[arg], "-vs"))
+    else if(!strncmp(runner->argv[arg], "-vs", sizeof("-vs")))
       vs_mode = 1;
-    else if(stest_is_string_equal_i(runner->argv[arg], "-m"))
+    else if(!strncmp(runner->argv[arg], "-m", sizeof("-m")))
       stest_machine_readable = 1;
-    else if(stest_is_string_equal_i(runner->argv[arg], "-s"))
-      stest_skip_test_if_assert_fails = 1;
+    else if(!strncmp(runner->argv[arg], "-c", sizeof("-c")))
+      stest_color_output = 1;
     else if(stest_parse_commandline_option_with_value(runner, arg, "-t",
                                                       test_filter))
       arg++;
     else if(stest_parse_commandline_option_with_value(runner, arg, "-f",
                                                       fixture_filter))
       arg++;
     else if(stest_parse_commandline_option_with_value(runner, arg, "-k",
                                                       set_magic_marker))
       arg++;
     else {
       printf("Error: %s option is not supported. Here is the help menu:\n",
              runner->argv[arg]);
       stest_show_help();
       runner->action = STEST_DO_NOTHING;
       return;
     }
   }
 }
 
 void stest_testrunner_create(stest_testrunner_t *runner, int argc,
                              char **argv) {
   runner->action = STEST_RUN_TESTS;
   runner->argc = argc;
   runner->argv = argv;
   stest_interpret_commandline(runner);
 }
 
 int stest_testrunner(int argc, char **argv, stest_void_void tests,
                      stest_void_void setup, stest_void_void teardown) {
   stest_testrunner_t runner;
   stest_testrunner_create(&runner, argc, argv);
-  stest_determine_color_output(stdout);
   switch(runner.action) {
   case STEST_DISPLAY_TESTS: {
     stest_display_only = 1;
     run_tests(tests);
     return STEST_RET_OK;
   }
   case STEST_RUN_TESTS: {
     stest_display_only = 0;
     suite_setup(setup);
     suite_teardown(teardown);
     return run_tests(tests);
   }
   case STEST_DO_NOTHING: {
     return STEST_RET_OK;
   }
   case STEST_DO_ABORT:
   default: {
     /* there was an error which should of been already printed out. */
     return STEST_RET_ERROR;
   }
   }
   return STEST_RET_ERROR;
 }
 
 #ifdef STEST_INTERNAL_TESTS
 void stest_simple_test_result_nolog(int passed, const char *reason,
                                     const char *function, unsigned int line) {
   stest_last_passed = passed;
 }
 
 void stest_assert_last_passed(const char *function, unsigned int line) {
   stest_assert_true(stest_last_passed, function, line);
 }
 
 void stest_assert_last_failed(const char *function, unsigned int line) {
   stest_assert_false(stest_last_passed, function, line);
 }
 
 void stest_disable_logging() {
   stest_simple_test_result = stest_simple_test_result_nolog;
 }
 
 void stest_enable_logging() {
   stest_simple_test_result = stest_simple_test_result_log;
 }
 #endif
diff --git a/src/stest.h b/src/stest.h
index 9dadc61..f25dd8f 100644
--- a/src/stest.h
+++ b/src/stest.h
@@ -1,109 +1,118 @@
-/*
- * Copyright (c) 2021 Jia Tan
- * Copyright (c) 2010 Keith Nicholas
- */
-
-#ifndef STEST_H
-#define STEST_H
-#include <stdio.h>
-
-/*
-Defines
-*/
-
-#define STEST_PRINT_BUFFER_SIZE 100000
-
-/*
-Typedefs
-*/
-
-typedef void (*stest_void_void)(void);
-typedef void (*stest_void_string)(const char *);
-
-/*
-Declarations
-*/
-
-extern void (*stest_simple_test_result)(int passed, const char *reason,
-                                        const char *function,
-                                        unsigned int line);
-void stest_test_fixture_start(const char *filepath);
-void stest_test_fixture_end(void);
-void stest_simple_test_result_log(int passed, const char *reason,
-                                  const char *function, unsigned int line);
-void stest_assert_true(int test, const char *function, unsigned int line);
-void stest_assert_false(int test, const char *function, unsigned int line);
-void stest_assert_int_equal(int expected, int actual, const char *function,
-                            unsigned int line);
-void stest_assert_ulong_equal(unsigned long expected, unsigned long actual,
-                              const char *function, unsigned int line);
-void stest_assert_float_equal(float expected, float actual, float delta,
-                              const char *function, unsigned int line);
-void stest_assert_double_equal(double expected, double actual, double delta,
-                               const char *function, unsigned int line);
-void stest_assert_string_equal(const char *expected, const char *actual,
-                               const char *function, unsigned int line);
-void stest_assert_string_ends_with(const char *expected, const char *actual,
-                                   const char *function, unsigned int line);
-void stest_assert_string_starts_with(const char *expected, const char *actual,
-                                     const char *function, unsigned int line);
-void stest_assert_string_contains(const char *expected, const char *actual,
-                                  const char *function, unsigned int line);
-void stest_assert_string_not_contains(const char *expected, const char *actual,
-                                      const char *function, unsigned int line);
-int stest_should_run_fixture(const char *fixture);
-int stest_should_run_test(const char *test);
-void stest_before_run(const char *fixture, const char *test);
-void stest_setup(void);
-void stest_teardown(void);
-void stest_suite_teardown(void);
-void stest_suite_setup(void);
-void stest_test(const char *test, void (*test_function)(void));
-
-/*
-Assert Macros
-*/
-
-// clang-format off
-#define assert_true(test) do { stest_assert_true(test, __FUNCTION__, __LINE__); } while (0)
-#define assert_false(test) do {  stest_assert_false(test, __FUNCTION__, __LINE__); } while (0)
-#define assert_int_equal(expected, actual) do {  stest_assert_int_equal(expected, actual, __FUNCTION__, __LINE__); } while (0)
-#define assert_ulong_equal(expected, actual) do {  stest_assert_ulong_equal(expected, actual, __FUNCTION__, __LINE__); } while (0)
-#define assert_string_equal(expected, actual) do {  stest_assert_string_equal(expected, actual, __FUNCTION__, __LINE__); } while (0)
-#define assert_n_array_equal(expected, actual, n) do { size_t stest_count; for(stest_count=0; stest_count<n; stest_count++) { char s_stest[STEST_PRINT_BUFFER_SIZE]; sprintf(s_stest,"Expected %d to be %d at position %d", actual[stest_count], expected[stest_count], (int)stest_count); stest_simple_test_result((expected[stest_count] == actual[stest_count]), s_stest, __FUNCTION__, __LINE__);} } while (0)
-#define assert_bit_set(bit_number, value) { stest_simple_test_result(((1 << bit_number) & value), " Expected bit to be set" ,  __FUNCTION__, __LINE__); } while (0)
-#define assert_bit_not_set(bit_number, value) { stest_simple_test_result(!((1 << bit_number) & value), " Expected bit not to to be set" ,  __FUNCTION__, __LINE__); } while (0)
-#define assert_bit_mask_matches(value, mask) { stest_simple_test_result(((value & mask) == mask), " Expected all bits of mask to be set" ,  __FUNCTION__, __LINE__); } while (0)
-#define assert_fail(message) { stest_simple_test_result(0, message,  __FUNCTION__, __LINE__); } while (0)
-#define assert_float_equal(expected, actual, delta) do {  stest_assert_float_equal(expected, actual, delta, __FUNCTION__, __LINE__); } while (0)
-#define assert_double_equal(expected, actual, delta) do {  stest_assert_double_equal(expected, actual, delta, __FUNCTION__, __LINE__); } while (0)
-#define assert_string_contains(expected, actual) do {  stest_assert_string_contains(expected, actual, __FUNCTION__, __LINE__); } while (0)
-#define assert_string_not_contains(expected, actual) do {  stest_assert_string_not_contains(expected, actual, __FUNCTION__, __LINE__); } while (0)
-#define assert_string_starts_with(expected, actual) do {  stest_assert_string_starts_with(expected, actual, __FUNCTION__, __LINE__); } while (0)
-#define assert_string_ends_with(expected, actual) do {  stest_assert_string_ends_with(expected, actual, __FUNCTION__, __LINE__); } while (0)
-
-/*
-Fixture / Test Management
-*/
-
-void fixture_setup(void (*setup)( void ));
-void fixture_teardown(void (*teardown)( void ));
-#define run_test(test) do { stest_test(#test, test);} while (0)
-#define test_fixture_start() do { stest_test_fixture_start(__FILE__); } while (0)
-#define test_fixture_end() do { stest_test_fixture_end();} while (0)
-void fixture_filter(const char* filter);
-void test_filter(const char* filter);
-void suite_teardown(stest_void_void teardown);
-void suite_setup(stest_void_void setup);
-int run_tests(stest_void_void tests);
-int stest_testrunner(int argc, char** argv, stest_void_void tests, stest_void_void setup, stest_void_void teardown);
-#endif
-//clang-format on
-
-#ifdef STEST_INTERNAL_TESTS
-void stest_simple_test_result_nolog(int passed, const char* reason, const char* function, unsigned int line);
-void stest_assert_last_passed(const char* function, unsigned int line);
-void stest_assert_last_failed(const char* function, unsigned int line);
-void stest_enable_logging(void);
-void stest_disable_logging(void);
-#endif
+/*
+ * Copyright (c) 2010 Keith Nicholas
+ * Copyright (c) 2021 Jia Tan
+ */
+
+#ifndef STEST_H
+#define STEST_H
+
+/*
+Defines
+*/
+
+#define STEST_PRINT_BUFFER_SIZE 10000
+
+// First prototype, then declare the test function
+#define STEST(test_name) static void test_name(void); \
+static void test_name(void) \
+{ const char *__STEST_FUNC_NAME__ = #test_name; (void) __STEST_FUNC_NAME__;
+
+#define STEST_HELPER(return_type, test_name, ...) static return_type \
+test_name(__VA_ARGS__); \
+static return_type test_name(__VA_ARGS__) \
+{ const char *__STEST_FUNC_NAME__ = #test_name; (void) __STEST_FUNC_NAME__;
+
+/*
+Typedefs
+*/
+
+typedef void (*stest_void_void)(void);
+typedef void (*stest_void_string)(const char *);
+
+/*
+Declarations
+*/
+
+extern void (*stest_simple_test_result)(int passed, const char *reason,
+                                        const char *function,
+                                        unsigned int line);
+void stest_test_fixture_start(const char *filepath);
+void stest_test_fixture_end(void);
+void stest_simple_test_result_log(int passed, const char *reason,
+                                  const char *function, unsigned int line);
+void stest_assert_true(int test, const char *function, unsigned int line);
+void stest_assert_false(int test, const char *function, unsigned int line);
+void stest_assert_int_equal(int expected, int actual, const char *function,
+                            unsigned int line);
+void stest_assert_ulong_equal(unsigned long expected, unsigned long actual,
+                              const char *function, unsigned int line);
+void stest_assert_float_equal(float expected, float actual, float delta,
+                              const char *function, unsigned int line);
+void stest_assert_double_equal(double expected, double actual, double delta,
+                               const char *function, unsigned int line);
+void stest_assert_string_equal(const char *expected, const char *actual,
+                               const char *function, unsigned int line);
+void stest_assert_string_ends_with(const char *expected, const char *actual,
+                                   const char *function, unsigned int line);
+void stest_assert_string_starts_with(const char *expected, const char *actual,
+                                     const char *function, unsigned int line);
+void stest_assert_string_contains(const char *expected, const char *actual,
+                                  const char *function, unsigned int line);
+void stest_assert_string_not_contains(const char *expected, const char *actual,
+                                      const char *function, unsigned int line);
+int stest_should_run_fixture(const char *fixture);
+int stest_should_run_test(const char *test);
+void stest_before_run(const char *fixture, const char *test);
+void stest_setup(void);
+void stest_teardown(void);
+void stest_suite_teardown(void);
+void stest_suite_setup(void);
+void stest_test(const char *test, void (*test_function)(void));
+
+/*
+Assert Macros
+*/
+
+// clang-format off
+#define assert_true(test) do { stest_assert_true(test, __STEST_FUNC_NAME__, __LINE__); } while (0)
+#define assert_false(test) do {  stest_assert_false(test, __STEST_FUNC_NAME__, __LINE__); } while (0)
+#define assert_int_equal(expected, actual) do {  stest_assert_int_equal(expected, actual, __STEST_FUNC_NAME__, __LINE__); } while (0)
+#define assert_ulong_equal(expected, actual) do {  stest_assert_ulong_equal(expected, actual, __STEST_FUNC_NAME__, __LINE__); } while (0)
+#define assert_string_equal(expected, actual) do {  stest_assert_string_equal(expected, actual, __STEST_FUNC_NAME__, __LINE__); } while (0)
+#define assert_n_array_equal(expected, actual, n) do { size_t stest_count; for(stest_count=0; stest_count<n; stest_count++) { char s_stest[STEST_PRINT_BUFFER_SIZE]; sprintf(s_stest,"Expected %d to be %d at position %d", actual[stest_count], expected[stest_count], (int)stest_count); stest_simple_test_result((expected[stest_count] == actual[stest_count]), s_stest, __STEST_FUNC_NAME__, __LINE__);} } while (0)
+#define assert_bit_set(bit_number, value) { stest_simple_test_result(((1 << bit_number) & value), " Expected bit to be set" ,  __STEST_FUNC_NAME__, __LINE__); } while (0)
+#define assert_bit_not_set(bit_number, value) { stest_simple_test_result(!((1 << bit_number) & value), " Expected bit not to to be set" ,  __STEST_FUNC_NAME__, __LINE__); } while (0)
+#define assert_bit_mask_matches(value, mask) { stest_simple_test_result(((value & mask) == mask), " Expected all bits of mask to be set" ,  __STEST_FUNC_NAME__, __LINE__); } while (0)
+#define assert_fail(message) { stest_simple_test_result(0, message,  __STEST_FUNC_NAME__, __LINE__); } while (0)
+#define assert_float_equal(expected, actual, delta) do {  stest_assert_float_equal(expected, actual, delta, __STEST_FUNC_NAME__, __LINE__); } while (0)
+#define assert_double_equal(expected, actual, delta) do {  stest_assert_double_equal(expected, actual, delta, __STEST_FUNC_NAME__, __LINE__); } while (0)
+#define assert_string_contains(expected, actual) do {  stest_assert_string_contains(expected, actual, __STEST_FUNC_NAME__, __LINE__); } while (0)
+#define assert_string_not_contains(expected, actual) do {  stest_assert_string_not_contains(expected, actual, __STEST_FUNC_NAME__, __LINE__); } while (0)
+#define assert_string_starts_with(expected, actual) do {  stest_assert_string_starts_with(expected, actual, __STEST_FUNC_NAME__, __LINE__); } while (0)
+#define assert_string_ends_with(expected, actual) do {  stest_assert_string_ends_with(expected, actual, __STEST_FUNC_NAME__, __LINE__); } while (0)
+
+/*
+Fixture / Test Management
+*/
+
+void fixture_setup(void (*setup)( void ));
+void fixture_teardown(void (*teardown)( void ));
+#define run_test(test) do { stest_test(#test, test);} while (0)
+#define test_fixture_start() do { stest_test_fixture_start(__FILE__); } while (0)
+#define test_fixture_end() do { stest_test_fixture_end();} while (0)
+void fixture_filter(const char* filter);
+void test_filter(const char* filter);
+void suite_teardown(stest_void_void teardown);
+void suite_setup(stest_void_void setup);
+int run_tests(stest_void_void tests);
+int stest_testrunner(int argc, char** argv, stest_void_void tests, stest_void_void setup, stest_void_void teardown);
+#endif
+//clang-format on
+
+#ifdef STEST_INTERNAL_TESTS
+void stest_simple_test_result_nolog(int passed, const char* reason, const char* function, unsigned int line);
+void stest_assert_last_passed(const char* function, unsigned int line);
+void stest_assert_last_failed(const char* function, unsigned int line);
+void stest_enable_logging(void);
+void stest_disable_logging(void);
+#endif
diff --git a/tests/stests.c b/tests/stests.c
index d5a8b52..dcf3ef5 100644
--- a/tests/stests.c
+++ b/tests/stests.c
@@ -1,147 +1,156 @@
 /*
  * Copyright (c) 2021 Jia Tan
  * Copyright (c) 2010 Keith Nicholas
  */
 
 #include "stests.h"
+#include "stddef.h"
 
-void test_assert_n_array_equal() {
+STEST(test_assert_n_array_equal)
   int array_1[4] = {0, 1, 2, 3};
   int array_2[4] = {0, 1, 2, 4};
   int array_3[4] = {0, 1, 2, 3};
 
   assert_test_passes(assert_n_array_equal(array_1, array_1, 4));
   assert_test_passes(assert_n_array_equal(array_1, array_3, 4));
   assert_test_passes(assert_n_array_equal(array_1, array_2, 3));
   assert_test_fails(assert_n_array_equal(array_1, array_2, 4));
   assert_test_fails(assert_n_array_equal(array_1, array_2, 0));
 }
 
-void test_assert_string_equal() {
+STEST(test_assert_string_equal)
   assert_test_passes(assert_string_equal((char *)0, (char *)0));
   assert_test_passes(assert_string_equal("", ""));
   assert_test_passes(assert_string_equal("foo", "foo"));
   assert_test_fails(assert_string_equal((char *)0, "bar"));
   assert_test_fails(assert_string_equal("foo", (char *)0));
   assert_test_fails(assert_string_equal("foo", "bar"));
   assert_test_fails(assert_string_equal("foo", "Foo"));
   assert_test_fails(assert_string_equal("foo", "foo\n"));
 }
 
-void test_assert_ulong_equal() {
+STEST(test_assert_ulong_equal)
   assert_test_passes(assert_ulong_equal(1, 1));
   assert_test_passes(assert_ulong_equal(-2, -2));
   assert_test_fails(assert_ulong_equal(1, 0));
   assert_test_fails(assert_ulong_equal(-2, 2));
 }
 
-void test_assert_int_equal() {
+STEST(test_assert_int_equal)
   assert_test_passes(assert_int_equal(1, 1));
   assert_test_passes(assert_int_equal(-2, -2));
   assert_test_fails(assert_int_equal(1, 0));
   assert_test_fails(assert_int_equal(-2, 2));
 }
 
-void test_assert_true() {
+STEST(test_assert_true)
   assert_test_passes(assert_true(1));
   assert_test_fails(assert_true(0));
 }
 
-void test_assert_false() {
+STEST(test_assert_false)
   assert_test_passes(assert_false(0));
   assert_test_fails(assert_false(1));
 }
 
-void test_assert_fail() { assert_test_fails(assert_fail("")); }
+STEST(test_assert_fail) assert_test_fails(assert_fail("")); }
 
-void test_assert_bit_set() {
+STEST(test_assert_bit_set)
   for(int bit = 0, value = 1; bit < sizeof(int) * 8; bit++, value <<= 1) {
     assert_test_passes(assert_bit_set(bit, value));
     if(bit > 0) {
       assert_test_fails(assert_bit_set(bit - 1, value));
     }
   }
 }
 
-void test_assert_bit_not_set() {
+STEST(test_assert_bit_not_set)
   for(int bit = 0, value = 1; bit < sizeof(int) * 8; bit++, value <<= 1) {
     assert_test_fails(assert_bit_not_set(bit, value));
     if(bit > 0) {
       assert_test_passes(assert_bit_not_set(bit - 1, value));
     }
   }
 }
 
-void test_assert_bit_mask_matches() {
+STEST(test_assert_bit_mask_matches)
   // mask in binary => 000100100011010001010110
   int mask = 0x123456;
   for(int i = 0; i < sizeof(int) * 8 - 1; i++) {
     assert_test_passes(assert_bit_mask_matches((i | mask), mask));
     assert_test_fails(assert_bit_mask_matches(i, mask));
   }
 }
 
-void test_assert_double_equal() {
+STEST(test_assert_double_equal)
   const double delta = 0.001;
   assert_test_passes(assert_double_equal(1.0, 1.0, delta));
   assert_test_fails(assert_double_equal(1.0, 2.0, delta));
   double d1 = 1.5;
   double d2 = 2.5;
   assert_test_passes(assert_double_equal(d2 - 1, d1, delta));
   assert_test_passes(assert_double_equal(d1 + 1, d2, delta));
   assert_test_fails(assert_double_equal(d1, d2, delta));
 }
 
-void test_assert_string_contains() {
+STEST(test_assert_string_contains)
   const char *str1 = "string one";
   const char *str2 = "string one and more";
   assert_test_passes(assert_string_contains(str1, str2));
   assert_test_fails(assert_string_contains(str2, str1));
 }
 
-void test_assert_string_not_contains() {
+STEST(test_assert_string_not_contains)
   const char *str1 = "string one";
   const char *str2 = "string one and more";
   assert_test_fails(assert_string_not_contains(str1, str2));
   assert_test_passes(assert_string_not_contains(str2, str1));
 }
 
-void test_assert_string_starts_with() {
+STEST(test_assert_string_starts_with)
   const char *str1 = "string one";
   const char *str2 = "string one and more";
   assert_test_passes(assert_string_starts_with(str1, str2));
   assert_test_fails(assert_string_starts_with(str2, str1));
 }
 
-void test_assert_string_ends_with() {
+STEST(test_assert_string_ends_with)
   const char *str1 = "and more";
   const char *str2 = "string one and more";
   assert_test_passes(assert_string_ends_with(str1, str2));
   assert_test_fails(assert_string_ends_with(str2, str1));
 }
 
+STEST_HELPER(int, helper_function, int arg1, int arg2)
+  assert_true(arg2 > arg1);
+  return arg2 - arg1;
+}
+
+STEST(test_using_helper_function)
+  assert_int_equal(1, helper_function(1, 2));
+}
+
 void test_fixture_stest() {
   test_fixture_start();
   run_test(test_assert_true);
   run_test(test_assert_false);
   run_test(test_assert_int_equal);
   run_test(test_assert_ulong_equal);
   run_test(test_assert_string_equal);
   run_test(test_assert_n_array_equal);
   run_test(test_assert_fail);
   run_test(test_assert_bit_set);
   run_test(test_assert_bit_not_set);
   run_test(test_assert_bit_mask_matches);
   run_test(test_assert_double_equal);
   run_test(test_assert_string_contains);
   run_test(test_assert_string_not_contains);
   run_test(test_assert_string_starts_with);
   run_test(test_assert_string_ends_with);
+  run_test(test_using_helper_function);
   test_fixture_end();
 }
 
-void all_tests() { test_fixture_stest(); }
-
 int main(int argc, char **argv) {
-  return stest_testrunner(argc, argv, all_tests, NULL, NULL);
+  return stest_testrunner(argc, argv, test_fixture_stest, NULL, NULL);
 }
diff --git a/tests/stests.h b/tests/stests.h
index 4ae1b43..f635420 100644
--- a/tests/stests.h
+++ b/tests/stests.h
@@ -1,26 +1,16 @@
 /*
  * Copyright (c) 2021 Jia Tan
  * Copyright (c) 2010 Keith Nicholas
  */
 
 #include "../src/stest.h"
 
 #ifndef STEST_INTERNAL_TESTS
 #error STEST_INTERNAL_TESTS must be defined when compiling tests for stest itself.
 #endif
 
 // clang-format off
 #define without_logging(X) stest_disable_logging(); X; stest_enable_logging();
 #define assert_test_passes(X) without_logging(X); stest_assert_last_passed(__FUNCTION__, __LINE__);
 #define assert_test_fails(X) without_logging(X); stest_assert_last_failed(__FUNCTION__, __LINE__);
 // clang-format on
-
-void test_assert_true(void);
-void test_assert_false(void);
-void test_assert_int_equal(void);
-void test_assert_ulong_equal(void);
-void test_assert_string_equal(void);
-void test_assert_n_array_equal(void);
-
-void test_fixture_stest(void);
-void all_tests(void);