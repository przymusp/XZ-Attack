<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Recent posts to Limitation for lzma2 when used for streaming</title><link>https://sourceforge.net/p/lzmautils/discussion/708858/thread/9cd47d66/</link><description>Recent posts to Limitation for lzma2 when used for streaming</description><language>en</language><lastBuildDate>Mon, 03 Jun 2019 17:55:41 -0000</lastBuildDate><atom:link href="https://sourceforge.net/p/lzmautils/discussion/708858/thread/9cd47d66/feed.rss" rel="self" type="application/rss+xml"></atom:link><item><title>Limitation for lzma2 when used for streaming</title><link>https://sourceforge.net/p/lzmautils/discussion/708858/thread/9cd47d66/?limit=25#0d51</link><description>&lt;div class="markdown_content"&gt;&lt;p&gt;To verify that the Index matches the Blocks, it's good enough to calculate a hash from both and compare the hashes. liblzma uses SHA-256 for this.&lt;/p&gt;
&lt;p&gt;For each Block there are two integers in the Index. When decoding, after each Block those two integers are passed to the hashing algorithm. Then when decoding the Index, hashing is done the same way from the integers read from the Index. If the Index matches the Blocks, the hashes must be identical. This way even if there were millions of Blocks and thus a long Index, the memory requirement wouldn't be any larger than with one Block and a tiny Index.&lt;/p&gt;&lt;/div&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Lasse Collin</dc:creator><pubDate>Mon, 03 Jun 2019 17:55:41 -0000</pubDate><guid isPermaLink="false">https://sourceforge.net20d2ccca8cfa4738c92238182795e38e9bb2b22a</guid></item><item><title>Limitation for lzma2 when used for streaming</title><link>https://sourceforge.net/p/lzmautils/discussion/708858/thread/9cd47d66/?limit=25#bc22</link><description>&lt;div class="markdown_content"&gt;&lt;p&gt;I have some doubts about this:&lt;br/&gt;
* xz Decoder in stream mode doesn't need memory for Index.&lt;/p&gt;
&lt;p&gt;In Stream Decoder, I found the process:"Decode the Index and compare it to the hash calculated from the sizes of the Blocks (if any)". So, I think it is a necessary part and xz decoder in stream mode may need memory for Index.&lt;br/&gt;
You mean that we just use the block data and not check the index?&lt;/p&gt;&lt;/div&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Bruce Stark</dc:creator><pubDate>Sat, 01 Jun 2019 07:57:43 -0000</pubDate><guid isPermaLink="false">https://sourceforge.net0237ccecd2811eb3ef4841f1824ede2a4985f0f4</guid></item><item><title>Limitation for lzma2 when used for streaming</title><link>https://sourceforge.net/p/lzmautils/discussion/708858/thread/9cd47d66/?limit=25#3103</link><description>&lt;div class="markdown_content"&gt;&lt;p&gt;Also you can compress whole stream to one big block. So index will be small - less than 64 bytes.&lt;/p&gt;&lt;/div&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Igor Pavlov</dc:creator><pubDate>Fri, 26 Jan 2018 15:18:02 -0000</pubDate><guid isPermaLink="false">https://sourceforge.net4106045387860a6898b8f15be62aa4a1205a3f47</guid></item><item><title>Limitation for lzma2 when used for streaming</title><link>https://sourceforge.net/p/lzmautils/discussion/708858/thread/9cd47d66/?limit=25#e2a9</link><description>&lt;div class="markdown_content"&gt;&lt;p&gt;1) xz Encoder needs memory for Index.&lt;br/&gt;
2) xz Decoder in stream mode doesn't need memory for Index.&lt;br/&gt;
3) xz Decoder in random access mode must load index to memory.&lt;/p&gt;&lt;/div&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Igor Pavlov</dc:creator><pubDate>Fri, 26 Jan 2018 15:16:28 -0000</pubDate><guid isPermaLink="false">https://sourceforge.net452d16501896dab1723d466ea4feb4c2f8c2c772</guid></item><item><title>Limitation for lzma2 when used for streaming</title><link>https://sourceforge.net/p/lzmautils/discussion/708858/thread/9cd47d66/?limit=25#db16</link><description>&lt;div class="markdown_content"&gt;&lt;p&gt;Thanks of the explanation!&lt;br/&gt;
But do I want to load this index? When I look at "2.1. Stream" in &lt;a href="https://tukaani.org/xz/xz-file-format.txt" rel="nofollow"&gt;https://tukaani.org/xz/xz-file-format.txt&lt;/a&gt; it's comes after the blocks. So at this point all data is already decompressed at the sink. &lt;/p&gt;&lt;/div&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Robert Kuhn</dc:creator><pubDate>Fri, 26 Jan 2018 14:01:19 -0000</pubDate><guid isPermaLink="false">https://sourceforge.net3b944af787911f5cf4d998c4893cdb7a85150683</guid></item><item><title>Limitation for lzma2 when used for streaming</title><link>https://sourceforge.net/p/lzmautils/discussion/708858/thread/9cd47d66/?limit=25#3431</link><description>&lt;div class="markdown_content"&gt;&lt;p&gt;It's not lzma2 limitation, it's xz limitation.&lt;br/&gt;
You must select the size of block, then you can estimate required RAM size to store index.&lt;br/&gt;
For example, if blocksize = 1 MB, and you need 6 bytes per block, you need about  600 MB of RAM to store index for 100 TB file.&lt;/p&gt;&lt;/div&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Igor Pavlov</dc:creator><pubDate>Fri, 26 Jan 2018 13:16:01 -0000</pubDate><guid isPermaLink="false">https://sourceforge.netac736eaf3d07d6733ce3e9e550a43f272025e92b</guid></item><item><title>Limitation for lzma2 when used for streaming</title><link>https://sourceforge.net/p/lzmautils/discussion/708858/thread/9cd47d66/?limit=25#d3ed</link><description>&lt;div class="markdown_content"&gt;&lt;p&gt;Hi,&lt;/p&gt;
&lt;p&gt;we send lzma2 compressed data over some GiGe network. We are wondering what are the limitations regarding maximum transmission time is. &lt;/p&gt;
&lt;p&gt;When I read the format description there are two limitations:&lt;br/&gt;
&lt;em&gt; The total size of a stream must be less than 8 EiB (2^63 bytes). This gives years of streaming even at maximum speed ;-)&lt;br/&gt;
&lt;/em&gt; The maximum size of the index field is 16 GiB. There is a index indicator (1 byte), the number of records (8byte) and then the individual records (16byte each). This gives 1073741823 records (=blocks). The block size is 4 * dictionary size. Dictionary size is at least 1048576bytes (when using defaults with preset=1), so minimal block size is 4194304b. So in the end this gives 4 EiB. This gives years of streaming, too.&lt;/p&gt;
&lt;p&gt;Is this correct?&lt;/p&gt;
&lt;p&gt;Thanks!&lt;/p&gt;&lt;/div&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Robert Kuhn</dc:creator><pubDate>Fri, 26 Jan 2018 11:42:41 -0000</pubDate><guid isPermaLink="false">https://sourceforge.net42aa37eea51e718f57b7e54d9de5454e22f9e06d</guid></item></channel></rss>