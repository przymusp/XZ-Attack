commit fce4758018f3a3589236f3fe7999fd9dd08c77e9
Author: Jia Tan <jiat0218@gmail.com>
Date:   Fri Jan 19 23:08:14 2024 +0800

    Docs: Update website URLs.

diff --git a/.github/SECURITY.md b/.github/SECURITY.md
index 756d4e39..e9b3458a 100644
--- a/.github/SECURITY.md
+++ b/.github/SECURITY.md
@@ -1,29 +1,29 @@
 # Security Policy
 
 ## Supported Versions
 
 We provide security updates to the development branch and the stable
 branches. Security patches for old releases are available on the
-[project website](https://tukaani.org/xz).
+[project website](https://xz.tukaani.org/xz-utils/).
 
 ## Reporting a Vulnerability
 
 If you discover a security vulnerability in this project, please
 report it privately. **Do not disclose it as a public issue.** This gives
 us time to work with you to fix the issue before public exposure, reducing
 the chance that the exploit will be used before a patch is released.
 
 You may submit a report by emailing us at
 [xz@tukaani.org](mailto:xz@tukaani.org), or through
 [Security Advisories](https://github.com/tukaani-project/xz/security/advisories/new).
 While both options are available, we prefer email. In any case, please
 provide a clear description of the vulnerability including:
 
 - Affected versions of XZ Utils
 - Estimated severity (low, moderate, high, critical)
 - Steps to recreate the vulnerability
 - All relevant files (core dumps, build logs, input files, etc.)
 
 This project is maintained by a team of volunteers on a reasonable-effort
 basis. As such, please give us 90 days to work on a fix before
 public exposure.
diff --git a/COPYING b/COPYING
index e54eeacf..4990c5f5 100644
--- a/COPYING
+++ b/COPYING
@@ -1,76 +1,77 @@
 
 XZ Utils Licensing
 ==================
 
     Different licenses apply to different files in this package. Here
     is a rough summary of which licenses apply to which parts of this
     package (but check the individual files to be sure!):
 
       - liblzma is in the public domain.
 
       - xz, xzdec, and lzmadec command line tools are in the public
         domain unless GNU getopt_long had to be compiled and linked
         in from the lib directory. The getopt_long code is under
         GNU LGPLv2.1+.
 
       - The scripts to grep, diff, and view compressed files have been
         adapted from gzip. These scripts and their documentation are
         under GNU GPLv2+.
 
       - All the documentation in the doc directory and most of the
         XZ Utils specific documentation files in other directories
         are in the public domain.
 
         Note: The JavaScript files (under the MIT license) have
         been removed from the Doxygen-generated HTML version of the
         liblzma API documentation. Doxygen itself is under the GNU GPL
         but the remaining files generated by Doxygen are not affected
         by the licenses used in Doxygen because Doxygen licensing has
         the following exception:
 
             "Documents produced by doxygen are derivative works
             derived from the input used in their production;
             they are not affected by this license."
 
       - Translated messages are in the public domain.
 
       - The build system contains public domain files, and files that
         are under GNU GPLv2+ or GNU GPLv3+. None of these files end up
         in the binaries being built.
 
       - Test files and test code in the tests directory, and debugging
         utilities in the debug directory are in the public domain.
 
       - The extra directory may contain public domain files, and files
         that are under various free software licenses.
 
     You can do whatever you want with the files that have been put into
     the public domain. If you find public domain legally problematic,
     take the previous sentence as a license grant. If you still find
     the lack of copyright legally problematic, you have too many
     lawyers.
 
     As usual, this software is provided "as is", without any warranty.
 
     If you copy significant amounts of public domain code from XZ Utils
     into your project, acknowledging this somewhere in your software is
     polite (especially if it is proprietary, non-free software), but
     naturally it is not legally required. Here is an example of a good
     notice to put into "about box" or into documentation:
 
-        This software includes code from XZ Utils <https://tukaani.org/xz/>.
+        This software includes code from XZ Utils
+        <https://xz.tukaani.org/xz-utils/>.
 
     The following license texts are included in the following files:
       - COPYING.LGPLv2.1: GNU Lesser General Public License version 2.1
       - COPYING.GPLv2: GNU General Public License version 2
       - COPYING.GPLv3: GNU General Public License version 3
 
     Note that the toolchain (compiler, linker etc.) may add some code
     pieces that are copyrighted. Thus, it is possible that e.g. liblzma
     binary wouldn't actually be in the public domain in its entirety
     even though it contains no copyrighted code from the XZ Utils source
     package.
 
     If you have questions, don't hesitate to ask the author(s) for more
     information.
 
diff --git a/README b/README
index 9e76301b..9a29c1b2 100644
--- a/README
+++ b/README
@@ -1,307 +1,307 @@
 
 XZ Utils
 ========
 
     0. Overview
     1. Documentation
        1.1. Overall documentation
        1.2. Documentation for command-line tools
        1.3. Documentation for liblzma
     2. Version numbering
     3. Reporting bugs
     4. Translations
     5. Other implementations of the .xz format
     6. Contact information
 
 
 0. Overview
 -----------
 
     XZ Utils provide a general-purpose data-compression library plus
     command-line tools. The native file format is the .xz format, but
     also the legacy .lzma format is supported. The .xz format supports
     multiple compression algorithms, which are called "filters" in the
     context of XZ Utils. The primary filter is currently LZMA2. With
     typical files, XZ Utils create about 30 % smaller files than gzip.
 
     To ease adapting support for the .xz format into existing applications
     and scripts, the API of liblzma is somewhat similar to the API of the
     popular zlib library. For the same reason, the command-line tool xz
     has a command-line syntax similar to that of gzip.
 
     When aiming for the highest compression ratio, the LZMA2 encoder uses
     a lot of CPU time and may use, depending on the settings, even
     hundreds of megabytes of RAM. However, in fast modes, the LZMA2 encoder
     competes with bzip2 in compression speed, RAM usage, and compression
     ratio.
 
     LZMA2 is reasonably fast to decompress. It is a little slower than
     gzip, but a lot faster than bzip2. Being fast to decompress means
     that the .xz format is especially nice when the same file will be
     decompressed very many times (usually on different computers), which
     is the case e.g. when distributing software packages. In such
     situations, it's not too bad if the compression takes some time,
     since that needs to be done only once to benefit many people.
 
     With some file types, combining (or "chaining") LZMA2 with an
     additional filter can improve the compression ratio. A filter chain may
     contain up to four filters, although usually only one or two are used.
     For example, putting a BCJ (Branch/Call/Jump) filter before LZMA2
     in the filter chain can improve compression ratio of executable files.
 
     Since the .xz format allows adding new filter IDs, it is possible that
     some day there will be a filter that is, for example, much faster to
     compress than LZMA2 (but probably with worse compression ratio).
     Similarly, it is possible that some day there is a filter that will
     compress better than LZMA2.
 
     XZ Utils supports multithreaded compression. XZ Utils doesn't support
     multithreaded decompression yet. It has been planned though and taken
     into account when designing the .xz file format. In the future, files
     that were created in threaded mode can be decompressed in threaded
     mode too.
 
 
 1. Documentation
 ----------------
 
 1.1. Overall documentation
 
     README              This file
 
     INSTALL.generic     Generic install instructions for those not familiar
                         with packages using GNU Autotools
     INSTALL             Installation instructions specific to XZ Utils
     PACKAGERS           Information to packagers of XZ Utils
 
     COPYING             XZ Utils copyright and license information
     COPYING.GPLv2       GNU General Public License version 2
     COPYING.GPLv3       GNU General Public License version 3
     COPYING.LGPLv2.1    GNU Lesser General Public License version 2.1
 
     AUTHORS             The main authors of XZ Utils
     THANKS              Incomplete list of people who have helped making
                         this software
     NEWS                User-visible changes between XZ Utils releases
     ChangeLog           Detailed list of changes (commit log)
     TODO                Known bugs and some sort of to-do list
 
     Note that only some of the above files are included in binary
     packages.
 
 
 1.2. Documentation for command-line tools
 
     The command-line tools are documented as man pages. In source code
     releases (and possibly also in some binary packages), the man pages
     are also provided in plain text (ASCII only) and PDF formats in the
     directory "doc/man" to make the man pages more accessible to those
     whose operating system doesn't provide an easy way to view man pages.
 
 
 1.3. Documentation for liblzma
 
     The liblzma API headers include short docs about each function
     and data type as Doxygen tags. These docs should be quite OK as
     a quick reference.
 
     There are a few example/tutorial programs that should help in
     getting started with liblzma. In the source package the examples
     are in "doc/examples" and in binary packages they may be under
     "examples" in the same directory as this README.
 
     Since the liblzma API has similarities to the zlib API, some people
     may find it useful to read the zlib docs and tutorial too:
 
         https://zlib.net/manual.html
         https://zlib.net/zlib_how.html
 
 
 2. Version numbering
 --------------------
 
     The version number format of XZ Utils is X.Y.ZS:
 
       - X is the major version. When this is incremented, the library
         API and ABI break.
 
       - Y is the minor version. It is incremented when new features
         are added without breaking the existing API or ABI. An even Y
         indicates a stable release and an odd Y indicates unstable
         (alpha or beta version).
 
       - Z is the revision. This has a different meaning for stable and
         unstable releases:
 
           * Stable: Z is incremented when bugs get fixed without adding
             any new features. This is intended to be convenient for
             downstream distributors that want bug fixes but don't want
             any new features to minimize the risk of introducing new bugs.
 
           * Unstable: Z is just a counter. API or ABI of features added
             in earlier unstable releases having the same X.Y may break.
 
       - S indicates stability of the release. It is missing from the
         stable releases, where Y is an even number. When Y is odd, S
         is either "alpha" or "beta" to make it very clear that such
         versions are not stable releases. The same X.Y.Z combination is
         not used for more than one stability level, i.e. after X.Y.Zalpha,
         the next version can be X.Y.(Z+1)beta but not X.Y.Zbeta.
 
 
 3. Reporting bugs
 -----------------
 
     Naturally it is easiest for me if you already know what causes the
     unexpected behavior. Even better if you have a patch to propose.
     However, quite often the reason for unexpected behavior is unknown,
     so here are a few things to do before sending a bug report:
 
       1. Try to create a small example how to reproduce the issue.
 
       2. Compile XZ Utils with debugging code using configure switches
          --enable-debug and, if possible, --disable-shared. If you are
          using GCC, use CFLAGS='-O0 -ggdb3'. Don't strip the resulting
          binaries.
 
       3. Turn on core dumps. The exact command depends on your shell;
          for example in GNU bash it is done with "ulimit -c unlimited",
          and in tcsh with "limit coredumpsize unlimited".
 
       4. Try to reproduce the suspected bug. If you get "assertion failed"
          message, be sure to include the complete message in your bug
          report. If the application leaves a coredump, get a backtrace
          using gdb:
            $ gdb /path/to/app-binary   # Load the app to the debugger.
            (gdb) core core   # Open the coredump.
            (gdb) bt   # Print the backtrace. Copy & paste to bug report.
            (gdb) quit   # Quit gdb.
 
     Report your bug via email or IRC (see Contact information below).
     Don't send core dump files or any executables. If you have a small
     example file(s) (total size less than 256 KiB), please include
     it/them as an attachment. If you have bigger test files, put them
     online somewhere and include a URL to the file(s) in the bug report.
 
     Always include the exact version number of XZ Utils in the bug report.
     If you are using a snapshot from the git repository, use "git describe"
     to get the exact snapshot version. If you are using XZ Utils shipped
     in an operating system distribution, mention the distribution name,
     distribution version, and exact xz package version; if you cannot
     repeat the bug with the code compiled from unpatched source code,
     you probably need to report a bug to your distribution's bug tracking
     system.
 
 
 4. Translations
 ---------------
 
     The xz command line tool and all man pages can be translated.
     The translations are handled via the Translation Project. If you
     wish to help translating xz, please join the Translation Project:
 
         https://translationproject.org/html/translators.html
 
     Below are notes and testing instructions specific to xz
     translations.
 
     Testing can be done by installing xz into a temporary directory:
 
         ./configure --disable-shared --prefix=/tmp/xz-test
         # <Edit the .po file in the po directory.>
         make -C po update-po
         make install
         bash debug/translation.bash | less
         bash debug/translation.bash | less -S  # For --list outputs
 
     Repeat the above as needed (no need to re-run configure though).
 
     Note especially the following:
 
       - The output of --help and --long-help must look nice on
         an 80-column terminal. It's OK to add extra lines if needed.
 
       - In contrast, don't add extra lines to error messages and such.
         They are often preceded with e.g. a filename on the same line,
         so you have no way to predict where to put a \n. Let the terminal
         do the wrapping even if it looks ugly. Adding new lines will be
         even uglier in the generic case even if it looks nice in a few
         limited examples.
 
       - Be careful with column alignment in tables and table-like output
         (--list, --list --verbose --verbose, --info-memory, --help, and
         --long-help):
 
           * All descriptions of options in --help should start in the
             same column (but it doesn't need to be the same column as
             in the English messages; just be consistent if you change it).
             Check that both --help and --long-help look OK, since they
             share several strings.
 
           * --list --verbose and --info-memory print lines that have
             the format "Description:   %s". If you need a longer
             description, you can put extra space between the colon
             and %s. Then you may need to add extra space to other
             strings too so that the result as a whole looks good (all
             values start at the same column).
 
           * The columns of the actual tables in --list --verbose --verbose
             should be aligned properly. Abbreviate if necessary. It might
             be good to keep at least 2 or 3 spaces between column headings
             and avoid spaces in the headings so that the columns stand out
             better, but this is a matter of opinion. Do what you think
             looks best.
 
       - Be careful to put a period at the end of a sentence when the
         original version has it, and don't put it when the original
         doesn't have it. Similarly, be careful with \n characters
         at the beginning and end of the strings.
 
       - Read the TRANSLATORS comments that have been extracted from the
         source code and included in xz.pot. Some comments suggest
         testing with a specific command which needs an .xz file. You
         may use e.g. any tests/files/good-*.xz. However, these test
         commands are included in translations.bash output, so reading
         translations.bash output carefully can be enough.
 
       - If you find language problems in the original English strings,
         feel free to suggest improvements. Ask if something is unclear.
 
       - The translated messages should be understandable (sometimes this
         may be a problem with the original English messages too). Don't
         make a direct word-by-word translation from English especially if
         the result doesn't sound good in your language.
 
     Thanks for your help!
 
 
 5. Other implementations of the .xz format
 ------------------------------------------
 
     7-Zip and the p7zip port of 7-Zip support the .xz format starting
     from the version 9.00alpha.
 
         https://7-zip.org/
         https://p7zip.sourceforge.net/
 
     XZ Embedded is a limited implementation written for use in the Linux
     kernel, but it is also suitable for other embedded use.
 
-        https://tukaani.org/xz/embedded.html
+        https://xz.tukaani.org/xz-embedded/
 
     XZ for Java is a complete implementation written in pure Java.
 
-        https://tukaani.org/xz/java.html
+        https://xz.tukaani.org/xz-for-java/
 
 
 6. Contact information
 ----------------------
 
     If you have questions, bug reports, patches etc. related to XZ Utils,
     the project maintainers Lasse Collin and Jia Tan can be reached via
     <xz@tukaani.org>.
 
     You might find Lasse also from #tukaani on Libera Chat (IRC).
     The nick is Larhzu. The channel tends to be pretty quiet,
     so just ask your question and someone might wake up.
 
diff --git a/doc/faq.txt b/doc/faq.txt
index 3f9068b4..a49e7e74 100644
--- a/doc/faq.txt
+++ b/doc/faq.txt
@@ -1,244 +1,244 @@
 
 XZ Utils FAQ
 ============
 
 Q:  What do the letters XZ mean?
 
 A:  Nothing. They are just two letters, which come from the file format
     suffix .xz. The .xz suffix was selected, because it seemed to be
     pretty much unused. It has no deeper meaning.
 
 
 Q:  What are LZMA and LZMA2?
 
 A:  LZMA stands for Lempel-Ziv-Markov chain-Algorithm. It is the name
     of the compression algorithm designed by Igor Pavlov for 7-Zip.
     LZMA is based on LZ77 and range encoding.
 
     LZMA2 is an updated version of the original LZMA to fix a couple of
     practical issues. In context of XZ Utils, LZMA is called LZMA1 to
     emphasize that LZMA is not the same thing as LZMA2. LZMA2 is the
     primary compression algorithm in the .xz file format.
 
 
 Q:  There are many LZMA related projects. How does XZ Utils relate to them?
 
 A:  7-Zip and LZMA SDK are the original projects. LZMA SDK is roughly
     a subset of the 7-Zip source tree.
 
     p7zip is 7-Zip's command-line tools ported to POSIX-like systems.
 
     LZMA Utils provide a gzip-like lzma tool for POSIX-like systems.
     LZMA Utils are based on LZMA SDK. XZ Utils are the successor to
     LZMA Utils.
 
     There are several other projects using LZMA. Most are more or less
     based on LZMA SDK. See <https://7-zip.org/links.html>.
 
 
 Q:  Why is liblzma named liblzma if its primary file format is .xz?
     Shouldn't it be e.g. libxz?
 
 A:  When the designing of the .xz format began, the idea was to replace
     the .lzma format and use the same .lzma suffix. It would have been
     quite OK to reuse the suffix when there were very few .lzma files
     around. However, the old .lzma format became popular before the
     new format was finished. The new format was renamed to .xz but the
     name of liblzma wasn't changed.
 
 
 Q:  Do XZ Utils support the .7z format?
 
 A:  No. Use 7-Zip (Windows) or p7zip (POSIX-like systems) to handle .7z
     files.
 
 
 Q:  I have many .tar.7z files. Can I convert them to .tar.xz without
     spending hours recompressing the data?
 
 A:  In the "extra" directory, there is a script named 7z2lzma.bash which
     is able to convert some .7z files to the .lzma format (not .xz). It
     needs the 7za (or 7z) command from p7zip. The script may silently
     produce corrupt output if certain assumptions are not met, so
     decompress the resulting .lzma file and compare it against the
     original before deleting the original file!
 
 
 Q:  I have many .lzma files. Can I quickly convert them to the .xz format?
 
 A:  For now, no. Since XZ Utils supports the .lzma format, it's usually
     not too bad to keep the old files in the old format. If you want to
     do the conversion anyway, you need to decompress the .lzma files and
     then recompress to the .xz format.
 
     Technically, there is a way to make the conversion relatively fast
     (roughly twice the time that normal decompression takes). Writing
     such a tool would take quite a bit of time though, and would probably
     be useful to only a few people. If you really want such a conversion
     tool, contact Lasse Collin and offer some money.
 
 
 Q:  I have installed xz, but my tar doesn't recognize .tar.xz files.
     How can I extract .tar.xz files?
 
 A:  xz -dc foo.tar.xz | tar xf -
 
 
 Q:  Can I recover parts of a broken .xz file (e.g. a corrupted CD-R)?
 
 A:  It may be possible if the file consists of multiple blocks, which
     typically is not the case if the file was created in single-threaded
     mode. There is no recovery program yet.
 
 
 Q:  Is (some part of) XZ Utils patented?
 
 A:  Lasse Collin is not aware of any patents that could affect XZ Utils.
     However, due to the nature of software patents, it's not possible to
     guarantee that XZ Utils isn't affected by any third party patent(s).
 
 
 Q:  Where can I find documentation about the file format and algorithms?
 
 A:  The .xz format is documented in xz-file-format.txt. It is a container
     format only, and doesn't include descriptions of any non-trivial
     filters.
 
     Documenting LZMA and LZMA2 is planned, but for now, there is no other
     documentation than the source code. Before you begin, you should know
     the basics of LZ77 and range-coding algorithms. LZMA is based on LZ77,
     but LZMA is a lot more complex. Range coding is used to compress
     the final bitstream like Huffman coding is used in Deflate.
 
 
 Q:  I cannot find BCJ and BCJ2 filters. Don't they exist in liblzma?
 
 A:  BCJ filter is called "x86" in liblzma. BCJ2 is not included,
     because it requires using more than one encoded output stream.
 
 
 Q:  I need to use a script that runs "xz -9". On a system with 256 MiB
     of RAM, xz says that it cannot allocate memory. Can I make the
     script work without modifying it?
 
 A:  Set a default memory usage limit for compression. You can do it e.g.
     in a shell initialization script such as ~/.bashrc or /etc/profile:
 
         XZ_DEFAULTS=--memlimit-compress=150MiB
         export XZ_DEFAULTS
 
     xz will then scale the compression settings down so that the given
     memory usage limit is not reached. This way xz shouldn't run out
     of memory.
 
     Check also that memory-related resource limits are high enough.
     On most systems, "ulimit -a" will show the current resource limits.
 
 
 Q:  How do I create files that can be decompressed with XZ Embedded?
 
 A:  See the documentation in XZ Embedded. In short, something like
     this is a good start:
 
         xz --check=crc32 --lzma2=preset=6e,dict=64KiB
 
     Or if a BCJ filter is needed too, e.g. if compressing
     a kernel image for PowerPC:
 
         xz --check=crc32 --powerpc --lzma2=preset=6e,dict=64KiB
 
     Adjust the dictionary size to get a good compromise between
     compression ratio and decompressor memory usage. Note that
     in single-call decompression mode of XZ Embedded, a big
     dictionary doesn't increase memory usage.
 
 
 Q:  How is multi-threaded compression implemented in XZ Utils?
 
 A:  The simplest method is splitting the uncompressed data into blocks
     and compressing them in parallel independent from each other.
     This is currently the only threading method supported in XZ Utils.
     Since the blocks are compressed independently, they can also be
     decompressed independently. Together with the index feature in .xz,
     this allows using threads to create .xz files for random-access
     reading. This also makes threaded decompression possible.
 
     The independent blocks method has a couple of disadvantages too. It
     will compress worse than a single-block method. Often the difference
     is not too big (maybe 1-2 %) but sometimes it can be too big. Also,
     the memory usage of the compressor increases linearly when adding
     threads.
 
     At least two other threading methods are possible but these haven't
     been implemented in XZ Utils:
 
     Match finder parallelization has been in 7-Zip for ages. It doesn't
     affect compression ratio or memory usage significantly. Among the
     three threading methods, only this is useful when compressing small
     files (files that are not significantly bigger than the dictionary).
     Unfortunately this method scales only to about two CPU cores.
 
     The third method is pigz-style threading (I use that name, because
     pigz <https://www.zlib.net/pigz/> uses that method). It doesn't
     affect compression ratio significantly and scales to many cores.
     The memory usage scales linearly when threads are added. This isn't
     significant with pigz, because Deflate uses only a 32 KiB dictionary,
     but with LZMA2 the memory usage will increase dramatically just like
     with the independent-blocks method. There is also a constant
     computational overhead, which may make pigz-method a bit dull on
     dual-core compared to the parallel match finder method, but with more
     cores the overhead is not a big deal anymore.
 
     Combining the threading methods will be possible and also useful.
     For example, combining match finder parallelization with pigz-style
     threading or independent-blocks-threading can cut the memory usage
     by 50 %.
 
 
 Q:  I told xz to use many threads but it is using only one or two
     processor cores. What is wrong?
 
 A:  Since multi-threaded compression is done by splitting the data into
     blocks that are compressed individually, if the input file is too
     small for the block size, then many threads cannot be used. The
     default block size increases when the compression level is
     increased. For example, xz -6 uses 8 MiB LZMA2 dictionary and
     24 MiB blocks, and xz -9 uses 64 MiB LZMA dictionary and 192 MiB
     blocks. If the input file is 100 MiB, xz -6 can use five threads
     of which one will finish quickly as it has only 4 MiB to compress.
     However, for the same file, xz -9 can only use one thread.
 
     One can adjust block size with --block-size=SIZE but making the
     block size smaller than LZMA2 dictionary is waste of RAM: using
     xz -9 with 6 MiB blocks isn't any better than using xz -6 with
     6 MiB blocks. The default settings use a block size bigger than
     the LZMA2 dictionary size because this was seen as a reasonable
     compromise between RAM usage and compression ratio.
 
     When decompressing, the ability to use threads depends on how the
     file was created. If it was created in multi-threaded mode then
     it can be decompressed in multi-threaded mode too if there are
     multiple blocks in the file.
 
 
 Q:  How do I build a program that needs liblzmadec (lzmadec.h)?
 
 A:  liblzmadec is part of LZMA Utils. XZ Utils has liblzma, but no
     liblzmadec. The code using liblzmadec should be ported to use
     liblzma instead. If you cannot or don't want to do that, download
     LZMA Utils from <https://tukaani.org/lzma/>.
 
 
 Q:  The default build of liblzma is too big. How can I make it smaller?
 
 A:  Give --enable-small to the configure script. Use also appropriate
     --enable or --disable options to include only those filter encoders
     and decoders and integrity checks that you actually need. Use
     CFLAGS=-Os (with GCC) or equivalent to tell your compiler to optimize
     for size. See INSTALL for information about configure options.
 
     If the result is still too big, take a look at XZ Embedded. It is
     a separate project, which provides a limited but significantly
     smaller XZ decoder implementation than XZ Utils. You can find it
-    at <https://tukaani.org/xz/embedded.html>.
+    at <https://xz.tukaani.org/xz-embedded/>.
 
diff --git a/doc/lzma-file-format.txt b/doc/lzma-file-format.txt
index 4865defd..1dd365eb 100644
--- a/doc/lzma-file-format.txt
+++ b/doc/lzma-file-format.txt
@@ -1,173 +1,173 @@
 
 The .lzma File Format
 =====================
 
         0. Preface
            0.1. Notices and Acknowledgements
            0.2. Changes
         1. File Format
            1.1. Header
                 1.1.1. Properties
                 1.1.2. Dictionary Size
                 1.1.3. Uncompressed Size
            1.2. LZMA Compressed Data
         2. References
 
 
 0. Preface
 
         This document describes the .lzma file format, which is
         sometimes also called LZMA_Alone format. It is a legacy file
         format, which is being or has been replaced by the .xz format.
         The MIME type of the .lzma format is `application/x-lzma'.
 
         The most commonly used software to handle .lzma files are
         LZMA SDK, LZMA Utils, 7-Zip, and XZ Utils. This document
         describes some of the differences between these implementations
         and gives hints what subset of the .lzma format is the most
         portable.
 
 
 0.1. Notices and Acknowledgements
 
         This file format was designed by Igor Pavlov for use in
         LZMA SDK. This document was written by Lasse Collin
         <lasse.collin@tukaani.org> using the documentation found
         from the LZMA SDK.
 
         This document has been put into the public domain.
 
 
 0.2. Changes
 
-        Last modified: 2022-07-13 21:00+0300
+        Last modified: 2024-01-16 18:00+0800
 
-        Compared to the previous version (2011-04-12 11:55+0300)
-        the section 1.1.3 was modified to allow End of Payload Marker
-        with a known Uncompressed Size.
+        Compared to the previous version (2022-07-13 21:00+0300)
+        the section 2 was modified to change links from http to
+        https and to update XZ links.
 
 
 1. File Format
 
         +-+-+-+-+-+-+-+-+-+-+-+-+-+==========================+
         |         Header          |   LZMA Compressed Data   |
         +-+-+-+-+-+-+-+-+-+-+-+-+-+==========================+
 
         The .lzma format file consist of 13-byte Header followed by
         the LZMA Compressed Data.
 
         Unlike the .gz, .bz2, and .xz formats, it is not possible to
         concatenate multiple .lzma files as is and expect the
         decompression tool to decode the resulting file as if it were
         a single .lzma file.
 
         For example, the command line tools from LZMA Utils and
         LZMA SDK silently ignore all the data after the first .lzma
         stream. In contrast, the command line tool from XZ Utils
         considers the .lzma file to be corrupt if there is data after
         the first .lzma stream.
 
 
 1.1. Header
 
         +------------+----+----+----+----+--+--+--+--+--+--+--+--+
         | Properties |  Dictionary Size  |   Uncompressed Size   |
         +------------+----+----+----+----+--+--+--+--+--+--+--+--+
 
 
 1.1.1. Properties
 
         The Properties field contains three properties. An abbreviation
         is given in parentheses, followed by the value range of the
         property. The field consists of
 
             1) the number of literal context bits (lc, [0, 8]);
             2) the number of literal position bits (lp, [0, 4]); and
             3) the number of position bits (pb, [0, 4]).
 
         The properties are encoded using the following formula:
 
             Properties = (pb * 5 + lp) * 9 + lc
 
         The following C code illustrates a straightforward way to
         decode the Properties field:
 
             uint8_t lc, lp, pb;
             uint8_t prop = get_lzma_properties();
             if (prop > (4 * 5 + 4) * 9 + 8)
                 return LZMA_PROPERTIES_ERROR;
 
             pb = prop / (9 * 5);
             prop -= pb * 9 * 5;
             lp = prop / 9;
             lc = prop - lp * 9;
 
         XZ Utils has an additional requirement: lc + lp <= 4. Files
         which don't follow this requirement cannot be decompressed
         with XZ Utils. Usually this isn't a problem since the most
         common lc/lp/pb values are 3/0/2. It is the only lc/lp/pb
         combination that the files created by LZMA Utils can have,
         but LZMA Utils can decompress files with any lc/lp/pb.
 
 
 1.1.2. Dictionary Size
 
         Dictionary Size is stored as an unsigned 32-bit little endian
         integer. Any 32-bit value is possible, but for maximum
         portability, only sizes of 2^n and 2^n + 2^(n-1) should be
         used.
 
         LZMA Utils creates only files with dictionary size 2^n,
         16 <= n <= 25. LZMA Utils can decompress files with any
         dictionary size.
 
         XZ Utils creates and decompresses .lzma files only with
         dictionary sizes 2^n and 2^n + 2^(n-1). If some other
         dictionary size is specified when compressing, the value
         stored in the Dictionary Size field is a rounded up, but the
         specified value is still used in the actual compression code.
 
 
 1.1.3. Uncompressed Size
 
         Uncompressed Size is stored as unsigned 64-bit little endian
         integer. A special value of 0xFFFF_FFFF_FFFF_FFFF indicates
         that Uncompressed Size is unknown. End of Payload Marker (*)
         is used if Uncompressed Size is unknown. End of Payload Marker
         is allowed but rarely used if Uncompressed Size is known.
         XZ Utils 5.2.5 and older don't support .lzma files that have
         End of Payload Marker together with a known Uncompressed Size.
 
         XZ Utils rejects files whose Uncompressed Size field specifies
         a known size that is 256 GiB or more. This is to reject false
         positives when trying to guess if the input file is in the
         .lzma format. When Uncompressed Size is unknown, there is no
         limit for the uncompressed size of the file.
 
         (*) Some tools use the term End of Stream (EOS) marker
             instead of End of Payload Marker.
 
 
 1.2. LZMA Compressed Data
 
         Detailed description of the format of this field is out of
         scope of this document.
 
 
 2. References
 
         LZMA SDK - The original LZMA implementation
-        http://7-zip.org/sdk.html
+        https://7-zip.org/sdk.html
 
         7-Zip
-        http://7-zip.org/
+        https://7-zip.org/
 
         LZMA Utils - LZMA adapted to POSIX-like systems
-        http://tukaani.org/lzma/
+        https://tukaani.org/lzma/
 
         XZ Utils - The next generation of LZMA Utils
-        http://tukaani.org/xz/
+        https://xz.tukaani.org/xz-utils/
 
         The .xz file format - The successor of the .lzma format
-        http://tukaani.org/xz/xz-file-format.txt
+        https://xz.tukaani.org/format/xz-file-format.txt
 
diff --git a/windows/README-Windows.txt b/windows/README-Windows.txt
index 87e8f464..9d277773 100644
--- a/windows/README-Windows.txt
+++ b/windows/README-Windows.txt
@@ -1,120 +1,121 @@
 
 XZ Utils for Windows
 ====================
 
 Introduction
 ------------
 
     This package includes command line tools (xz.exe and a few others)
     and the liblzma compression library from XZ Utils. You can find the
-    latest version and full source code from <https://tukaani.org/xz/>.
+    latest version and full source code from
+    <https://xz.tukaani.org/xz-utils/>.
 
     The parts of the XZ Utils source code, that are relevant to this
     binary package, are in the public domain. XZ Utils have been built
     for this package with MinGW-w64 and linked statically against its
     runtime libraries. See COPYING-Windows.txt for the copyright and
     license information that applies to the MinGW-w64 runtime. You must
     include it when redistributing these XZ Utils binaries.
 
 
 Package contents
 ----------------
 
     All executables and libraries in this package require msvcrt.dll,
     not Universal CRT (UCRT).
 
     There is a SSE2 optimization in the compression code but this
     version of XZ Utils doesn't include run-time processor detection.
     This is why there is a separate i686-SSE2 version.
 
     There is one directory for each type of executable and library files:
 
         bin_i686        32-bit x86 (i686 and newer), Windows 2000 and later
         bin_i686-sse2   32-bit x86 (i686 with SSE2), Windows 2000 and later
         bin_x86-64      64-bit x86-64, Windows Vista and later
 
     Each of the above directories have the following files:
 
         *.exe       Command line tools. (It's useless to double-click
                     these; use the command prompt instead.) These have
                     been linked statically against liblzma, so they
                     don't require liblzma.dll. Thus, you can copy e.g.
                     xz.exe to a directory that is in PATH without copying
                     any other files from this package.
 
         liblzma.dll Shared version of the liblzma compression library.
                     This file is mostly useful to developers, although
                     some non-developers might use it to upgrade their
                     copy of liblzma.
 
         liblzma.a   Static version of the liblzma compression library.
                     This file is useful only for developers.
 
     The rest of the directories contain architecture-independent files:
 
         doc         Documentation in the plain text (TXT) format. The
                     manuals of the command line tools are provided also
                     in the PDF format. liblzma.def is in this directory
                     too.
 
         include     C header files for liblzma. These should be
                     compatible with most C and C++ compilers. If you
                     have problems, try to fix it and send your fixes
                     upstream, or at least report a bug, thanks.
 
 
 Linking against liblzma
 -----------------------
 
 MinGW
 
     If you use MinGW, linking against liblzma.dll or liblzma.a should
     be straightforward. You don't need an import library to link
     against liblzma.dll, and for static linking, you don't need to
     worry about the LZMA_API_STATIC macro.
 
     Note that the MinGW distribution includes liblzma. If you are
     building packages that will be part of the MinGW distribution, you
     probably should use the version of liblzma shipped in MinGW instead
     of this package.
 
 
 Microsoft Visual C++
 
     To link against liblzma.dll, you need to create an import library
     first. You need the "lib" command from MSVC and liblzma.def from
     the "doc" directory of this package. Here is the command that works
     on 32-bit x86:
 
         lib /def:liblzma.def /out:liblzma.lib /machine:ix86
 
     On x86-64, the /machine argument has to naturally be changed:
 
         lib /def:liblzma.def /out:liblzma.lib /machine:x64
 
     If you need to link statically against liblzma, you should build
     liblzma with MSVC 2013 update 2 or later. Alternatively, if having
     a decompressor is enough, consider using XZ Embedded or LZMA SDK.
 
     When you plan to link against static liblzma, you need to tell
     lzma.h to not use __declspec(dllimport) by defining the macro
     LZMA_API_STATIC. You can do it either in the C/C++ code
 
         #define LZMA_API_STATIC
         #include <lzma.h>
 
     or by adding it to compiler options.
 
 
 Other compilers
 
     If you are using some other compiler, see its documentation how to
     create an import library (if it is needed). If it is simple, I
     might consider including the instructions here.
 
 
 Reporting bugs
 --------------
 
     Report bugs to <xz@tukaani.org>.
 