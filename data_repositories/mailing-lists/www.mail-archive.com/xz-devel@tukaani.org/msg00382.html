<!DOCTYPE html>
<html lang="en">
<head>
<title>[xz-devel] [PATCH] liblzma: Add multi-threaded decoder</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="apple-touch-icon" sizes="114x114" href="/apple-touch-icon-114x114.png">
<link rel="apple-touch-icon" sizes="72x72" href="/apple-touch-icon-72x72.png">
<link rel="apple-touch-icon" sizes="57x57" href="/apple-touch-icon-57x57.png">
<link rel="shortcut icon" href="/favicon.ico">
<link rel="contents" href="index.html#00382" id="c">
<link rel="index" href="maillist.html#00382" id="i">
<link rel="prev" href="msg00381.html" id="p">
<link rel="next" href="msg00386.html" id="n">
<link rel="canonical" href="https://www.mail-archive.com/xz-devel@tukaani.org/msg00382.html">
<link rel="stylesheet" href="/normalize.css" media="screen">
<link rel="stylesheet" href="/master.css" media="screen">

<!--[if lt IE 9]>
<link rel="stylesheet" href="/ie.css" media="screen">
<![endif]-->
</head>
<body>
<script language="javascript" type="text/javascript">
document.onkeydown = NavigateThrough;
function NavigateThrough (event)
{
  if (!document.getElementById) return;
  if (window.event) event = window.event;
  if (event.target.tagName == 'INPUT') return;
  if (event.ctrlKey || event.metaKey) return;
  var link = null;
  switch (event.keyCode ? event.keyCode : event.which ? event.which : null) {
    case 74:
    case 80:
      link = document.getElementById ('p');
      break;
    case 75:
    case 78:
      link = document.getElementById ('n');
      break;
    case 69:
      link = document.getElementById ('e');
      break;
    }
  if (link && link.href) document.location = link.href;
}
</script>
<div itemscope itemtype="http://schema.org/Article" class="container">
<div class="skipLink">
<a href="#nav">Skip to site navigation (Press enter)</a>
</div>
<div class="content" role="main">
<div class="msgHead">
<h1>
<span class="subject"><a href="/search?l=xz-devel@tukaani.org&amp;q=subject:%22%5C%5Bxz%5C-devel%5C%5D+%5C%5BPATCH%5C%5D+liblzma%5C%3A+Add+multi%5C-threaded+decoder%22&amp;o=newest" rel="nofollow"><span itemprop="name">[xz-devel] [PATCH] liblzma: Add multi-threaded decoder</span></a></span>
</h1>
<p class="darkgray font13">
<span class="sender pipe"><a href="/search?l=xz-devel@tukaani.org&amp;q=from:%22Sebastian+Andrzej+Siewior%22" rel="nofollow"><span itemprop="author" itemscope itemtype="http://schema.org/Person"><span itemprop="name">Sebastian Andrzej Siewior</span></span></a></span>
<span class="date"><a href="/search?l=xz-devel@tukaani.org&amp;q=date:20201223" rel="nofollow">Wed, 23 Dec 2020 16:03:26 -0800</a></span>
</p>
</div>
<div itemprop="articleBody" class="msgBody">
<!--X-Body-of-Message-->
<pre>From: Sebastian Andrzej Siewior &lt;sebast...@breakpoint.cc&gt;

Changes since last post:
- Options are considered
- Memory limits are considered. The limit may get exceeded if we get
  close to it and then the existing threads enlarge their in-buffer.
- Blocks with no size information in the header can be decompressed.
  This happens synchronous.</pre><pre>

Signed-off-by: Sebastian Andrzej Siewior &lt;sebast...@breakpoint.cc&gt;
---
 src/liblzma/api/lzma/container.h       |    5 +-
 src/liblzma/common/Makefile.inc        |    6 +
 src/liblzma/common/stream_decoder_mt.c | 1058 ++++++++++++++++++++++++
 src/liblzma/liblzma.map                |    1 +
 src/xz/coder.c                         |   15 +-
 5 files changed, 1080 insertions(+), 5 deletions(-)
 create mode 100644 src/liblzma/common/stream_decoder_mt.c

diff --git a/src/liblzma/api/lzma/container.h b/src/liblzma/api/lzma/container.h
index 9fbf4df06178e..de0a77b5d6482 100644
--- a/src/liblzma/api/lzma/container.h
+++ b/src/liblzma/api/lzma/container.h
@@ -173,7 +173,7 @@ typedef struct {
        uint32_t reserved_int2;
        uint32_t reserved_int3;
        uint32_t reserved_int4;
-       uint64_t reserved_int5;
+       uint64_t memlimit;
        uint64_t reserved_int6;
        uint64_t reserved_int7;
        uint64_t reserved_int8;
@@ -630,3 +630,6 @@ extern LZMA_API(lzma_ret) lzma_stream_buffer_decode(
                const uint8_t *in, size_t *in_pos, size_t in_size,
                uint8_t *out, size_t *out_pos, size_t out_size)
                lzma_nothrow lzma_attr_warn_unused_result;
+
+extern LZMA_API(lzma_ret)
+       lzma_stream_decoder_mt(lzma_stream *strm, const lzma_mt *options);
diff --git a/src/liblzma/common/Makefile.inc b/src/liblzma/common/Makefile.inc
index 0408f9a48c4db..3c140c2955475 100644
--- a/src/liblzma/common/Makefile.inc
+++ b/src/liblzma/common/Makefile.inc
@@ -78,4 +78,10 @@ liblzma_la_SOURCES += \
        common/stream_decoder.h \
        common/stream_flags_decoder.c \
        common/vli_decoder.c
+
+if COND_THREADS
+liblzma_la_SOURCES += \
+       common/stream_decoder_mt.c
+endif
+
 endif
diff --git a/src/liblzma/common/stream_decoder_mt.c 
b/src/liblzma/common/stream_decoder_mt.c
new file mode 100644
index 0000000000000..b2f1c9ebfa607
--- /dev/null
+++ b/src/liblzma/common/stream_decoder_mt.c
@@ -0,0 +1,1058 @@
+///////////////////////////////////////////////////////////////////////////////
+//
+/// \file       stream_decoder_mt.c
+/// \brief      Multithreaded .xz Stream decoder
+//
+//  Author:     Sebastian Andrzej Siewior
+//
+//  This file has been put into the public domain.
+//  You can do whatever you want with this file.
+//
+///////////////////////////////////////////////////////////////////////////////
+
+#include &quot;common.h&quot;
+#include &quot;block_decoder.h&quot;
+#include &quot;outqueue.h&quot;
+#include &quot;stream_decoder.h&quot;
+#include &quot;index.h&quot;
+
+#include &lt;stdio.h&gt;
+
+typedef enum {
+       /// Waiting for work.
+       THR_IDLE,
+
+       /// Decoding is in progress.
+       THR_RUN,
+
+       /// The main thread wants the thread to stop whatever it was doing
+       /// but not exit.
+       THR_STOP,
+
+       /// The main thread wants the thread to exit.
+       THR_EXIT,
+
+} worker_state;
+
+struct out_buffer {
+       uint8_t *out;
+       size_t out_block_size;  /* Size of -&gt;out                        */
+       size_t out_pos;         /* Bytes written to -&gt;out (worker)      */
+       size_t out_filled;      /* Bytes consumed of -&gt;out (coordinator) */
+};
+
+struct worker_thread {
+       worker_state state;
+
+       uint8_t *in;
+       size_t in_size;         /* Size of -&gt;in                         */
+       size_t in_block_size;   /* Size of current block                */
+       size_t in_filled;       /* Bytes written to -&gt;in (coordinator)  */
+       size_t in_pos;          /* Bytes consumed of -&gt;in (worker)      */
+
+       struct out_buffer out;
+
+       /// Pointer to the main structure is needed when putting this
+       /// thread back to the stack of free threads.
+       struct lzma_stream_coder *coder;
+
+       /* The allocator is set by the main thread. */
+       const lzma_allocator *allocator;
+       /* Filter size is used for memusage accounting */
+       size_t filter_size;
+
+       lzma_next_coder block_decoder;
+       lzma_block block_options;
+       struct worker_thread *next;
+
+       mythread_mutex mutex;
+       mythread_cond cond;
+       lzma_ret thread_error;
+
+       mythread thread_id;
+};
+
+struct lzma_stream_coder {
+       enum {
+               SEQ_STREAM_HEADER,
+               SEQ_BLOCK_HEADER,
+               SEQ_BLOCK,
+               SEQ_INDEX,
+               SEQ_STREAM_FOOTER,
+               SEQ_STREAM_PADDING,
+       } sequence;
+
+
+       /// Memory usage limit
+       uint64_t memlimit;
+       /// Amount of memory actually needed (only an estimate)
+       uint64_t memusage;
+       size_t exp_filter_size;
+       size_t exp_block_size;
+
+       lzma_index_hash *index_hash;
+
+       mythread_mutex mutex;
+       mythread_cond cond;
+
+       /// Array of allocated thread-specific structures
+       struct worker_thread *threads;
+
+       /// Number of structures in &quot;threads&quot; above. This is also the
+       /// number of threads that will be created at maximum.
+       uint32_t threads_max;
+
+       /// Number of thread structures that have been initialized, and
+       /// thus the number of worker threads actually created so far.
+       uint32_t threads_initialized;
+
+       /// Stack of free threads. When a thread finishes, it puts itself
+       /// back into this stack. This starts as empty because threads
+       /// are created only when actually needed.
+       struct worker_thread *threads_free;
+       /* Current thread decompressed is read from */
+       struct worker_thread *thr_read;
+       /* Last read thread, used for -&gt;next assignment */
+       struct worker_thread *thr_read_last;
+       /* Current thread compressed data is written to */
+       struct worker_thread *thr_write;
+
+       lzma_stream_flags stream_flags;
+       bool tell_no_check;
+       bool tell_unsupported_check;
+       bool tell_any_check;
+       bool ignore_check;
+       bool concatenated;
+       bool first_stream;
+       /* True if block sizes are missing and threads are not used */
+       bool direct_decomp;
+
+       size_t pos;
+       uint8_t buffer[LZMA_BLOCK_HEADER_SIZE_MAX];
+};
+
+/* Use smaller chunks so cancalation attempts don't block for long */
+#define CHUNK_SIZE     16384
+static MYTHREAD_RET_TYPE worker_decoder(void *thr_ptr)
+{
+       struct worker_thread *thr = thr_ptr;
+       size_t in_filled;
+       size_t out_pos;
+       lzma_ret ret;
+       struct out_buffer *out;
+
+next_loop_lock:
+
+       mythread_mutex_lock(&amp;thr-&gt;mutex);
+next_loop_unlocked:
+
+       if (thr-&gt;state == THR_IDLE) {
+               mythread_cond_wait(&amp;thr-&gt;cond, &amp;thr-&gt;mutex);
+               goto next_loop_unlocked;
+       } else if (thr-&gt;state == THR_EXIT) {
+               mythread_mutex_unlock(&amp;thr-&gt;mutex);
+
+               lzma_free(thr-&gt;in, thr-&gt;allocator);
+               lzma_free(thr-&gt;out.out, thr-&gt;allocator);
+               lzma_next_end(&amp;thr-&gt;block_decoder, thr-&gt;allocator);
+
+               mythread_mutex_destroy(&amp;thr-&gt;mutex);
+               mythread_cond_destroy(&amp;thr-&gt;cond);
+               return MYTHREAD_RET_VALUE;
+
+       } else if (thr-&gt;state == THR_STOP) {
+               thr-&gt;state = THR_IDLE;
+               mythread_cond_wait(&amp;thr-&gt;cond, &amp;thr-&gt;mutex);
+               goto next_loop_unlocked;
+       } else if (thr-&gt;state != THR_RUN) {
+               thr-&gt;state = THR_IDLE;
+               thr-&gt;thread_error = LZMA_PROG_ERROR;
+               mythread_mutex_unlock(&amp;thr-&gt;mutex);
+
+               mythread_mutex_lock(&amp;thr-&gt;coder-&gt;mutex);
+               mythread_cond_signal(&amp;thr-&gt;coder-&gt;cond);
+               mythread_mutex_unlock(&amp;thr-&gt;coder-&gt;mutex);
+               goto next_loop_lock;
+       }
+
+       in_filled = thr-&gt;in_filled;
+
+       if (in_filled == thr-&gt;in_pos) {
+               mythread_cond_wait(&amp;thr-&gt;cond, &amp;thr-&gt;mutex);
+               goto next_loop_unlocked;
+       }
+       out = &amp;thr-&gt;out;
+       mythread_mutex_unlock(&amp;thr-&gt;mutex);
+
+       if ((in_filled - thr-&gt;in_pos) &gt; CHUNK_SIZE)
+               in_filled = thr-&gt;in_pos + CHUNK_SIZE;
+
+       out_pos = out-&gt;out_pos;
+       ret = thr-&gt;block_decoder.code(thr-&gt;block_decoder.coder,
+                                     thr-&gt;allocator,
+                                     thr-&gt;in, &amp;thr-&gt;in_pos, in_filled,
+                                     out-&gt;out, &amp;out_pos, out-&gt;out_block_size,
+                                     LZMA_RUN);
+       if (ret == LZMA_OK || ret == LZMA_STREAM_END) {
+
+               if (thr-&gt;in_pos == thr-&gt;in_block_size) {
+                       mythread_mutex_lock(&amp;thr-&gt;mutex);
+                       thr-&gt;state = THR_IDLE;
+                       mythread_mutex_unlock(&amp;thr-&gt;mutex);
+               }
+
+               if (out_pos != out-&gt;out_pos) {
+                       mythread_mutex_lock(&amp;thr-&gt;coder-&gt;mutex);
+                       out-&gt;out_pos = out_pos;
+                       if (thr-&gt;coder-&gt;thr_read == thr) {
+                               mythread_cond_signal(&amp;thr-&gt;coder-&gt;cond);
+                       }
+                       mythread_mutex_unlock(&amp;thr-&gt;coder-&gt;mutex);
+               }
+               goto next_loop_lock;
+       } else {
+
+               mythread_mutex_lock(&amp;thr-&gt;mutex);
+               thr-&gt;state = THR_IDLE;
+               thr-&gt;thread_error = ret;
+               mythread_mutex_unlock(&amp;thr-&gt;mutex);
+
+               mythread_mutex_lock(&amp;thr-&gt;coder-&gt;mutex);
+               mythread_cond_signal(&amp;thr-&gt;coder-&gt;cond);
+               mythread_mutex_unlock(&amp;thr-&gt;coder-&gt;mutex);
+               goto next_loop_lock;
+       }
+       return MYTHREAD_RET_VALUE;
+}
+
+static void threads_end(struct lzma_stream_coder *coder,
+                       const lzma_allocator *allocator)
+{
+       uint32_t i;
+
+       for (i = 0; i &lt; coder-&gt;threads_initialized; ++i) {
+               mythread_mutex_lock(&amp;coder-&gt;threads[i].mutex);
+               coder-&gt;threads[i].state = THR_EXIT;
+               mythread_cond_signal(&amp;coder-&gt;threads[i].cond);
+               mythread_mutex_unlock(&amp;coder-&gt;threads[i].mutex);
+       }
+
+       for (i = 0; i &lt; coder-&gt;threads_initialized; ++i)
+               mythread_join(coder-&gt;threads[i].thread_id);
+
+       coder-&gt;threads_initialized = 0;
+       lzma_free(coder-&gt;threads, allocator);
+       return;
+}
+
+static void threads_stop(struct lzma_stream_coder *coder, bool 
wait_for_threads)
+{
+       uint32_t i;
+
+       for (i = 0; i &lt; coder-&gt;threads_initialized; ++i) {
+               mythread_mutex_lock(&amp;coder-&gt;threads[i].mutex);
+               coder-&gt;threads[i].state = THR_STOP;
+               mythread_cond_signal(&amp;coder-&gt;threads[i].cond);
+               mythread_mutex_unlock(&amp;coder-&gt;threads[i].mutex);
+       }
+
+       if (!wait_for_threads)
+               return;
+
+       for (i = 0; i &lt; coder-&gt;threads_initialized; ++i) {
+               mythread_mutex_lock(&amp;coder-&gt;threads[i].mutex);
+               while (coder-&gt;threads[i].state != THR_IDLE) {
+                       mythread_cond_wait(&amp;coder-&gt;threads[i].cond,
+                                          &amp;coder-&gt;threads[i].mutex);
+               }
+               mythread_mutex_unlock(&amp;coder-&gt;threads[i].mutex);
+       }
+}
+
+static void stream_decoder_mt_end(void *coder_ptr,
+                                 const lzma_allocator *allocator)
+{
+       struct lzma_stream_coder *coder = coder_ptr;
+
+       threads_end(coder, allocator);
+       lzma_index_hash_end(coder-&gt;index_hash, allocator);
+       lzma_free(coder, allocator);
+}
+
+static lzma_ret stream_decode_in(struct lzma_stream_coder *coder,
+                                const uint8_t *restrict in,
+                                size_t *restrict in_pos,
+                                size_t in_size)
+{
+       struct worker_thread *thr = coder-&gt;thr_write;
+       size_t old_filled;
+       size_t cur_in_infilled;
+       lzma_ret ret = LZMA_OK;
+
+       mythread_mutex_lock(&amp;thr-&gt;mutex);
+
+       if (thr-&gt;state == THR_IDLE) {
+               ret = thr-&gt;thread_error;
+               if (ret != LZMA_OK) {
+                       mythread_mutex_unlock(&amp;thr-&gt;mutex);
+                       return ret;
+               }
+       }
+
+       old_filled = thr-&gt;in_filled;
+       mythread_mutex_unlock(&amp;thr-&gt;mutex);
+       cur_in_infilled = old_filled;
+
+       lzma_bufcpy(in, in_pos, in_size,
+                   thr-&gt;in, &amp;cur_in_infilled, thr-&gt;in_block_size);
+
+       mythread_mutex_lock(&amp;thr-&gt;mutex);
+       thr-&gt;in_filled = cur_in_infilled;
+
+       if (old_filled == thr-&gt;in_pos)
+               mythread_cond_signal(&amp;thr-&gt;cond);
+
+       mythread_mutex_unlock(&amp;thr-&gt;mutex);
+
+       /* complete in buffer consumed and out-buffer written */
+       if (thr-&gt;in_filled == thr-&gt;in_block_size) {
+
+               coder-&gt;sequence = SEQ_BLOCK_HEADER;
+               coder-&gt;thr_write = NULL;
+               return LZMA_OK;
+       }
+
+       return ret;
+}
+
+/// Initialize a new worker_thread structure and create a new thread.
+static lzma_ret initialize_new_thread(struct lzma_stream_coder *coder,
+                                     const lzma_allocator *allocator)
+{
+       struct worker_thread *thr = &amp;coder-&gt;threads[coder-&gt;threads_initialized];
+
+       memset(thr, 0, sizeof(struct worker_thread));
+
+       if (mythread_mutex_init(&amp;thr-&gt;mutex))
+               goto error_mutex;
+
+       if (mythread_cond_init(&amp;thr-&gt;cond))
+               goto error_cond;
+
+       thr-&gt;state = THR_IDLE;
+       thr-&gt;thread_error = LZMA_OK;
+       thr-&gt;allocator = allocator;
+       thr-&gt;coder = coder;
+       thr-&gt;block_decoder = LZMA_NEXT_CODER_INIT;
+
+       if (mythread_create(&amp;thr-&gt;thread_id, worker_decoder, thr))
+               goto error_thread;
+
+       ++coder-&gt;threads_initialized;
+       coder-&gt;thr_write = thr;
+
+       return LZMA_OK;
+
+error_thread:
+       mythread_cond_destroy(&amp;thr-&gt;cond);
+
+error_cond:
+       mythread_mutex_destroy(&amp;thr-&gt;mutex);
+
+error_mutex:
+       return LZMA_MEM_ERROR;
+}
+
+
+static lzma_ret get_thread(struct lzma_stream_coder *coder,
+                          const lzma_allocator *allocator)
+{
+       // If there is a free structure on the stack, use it.
+       if (coder-&gt;threads_free != NULL) {
+               coder-&gt;thr_write = coder-&gt;threads_free;
+               coder-&gt;threads_free = coder-&gt;threads_free-&gt;next;
+       }
+
+       if (coder-&gt;thr_write == NULL) {
+               // If there are no uninitialized structures left, return.
+               if (coder-&gt;threads_initialized == coder-&gt;threads_max)
+                       return LZMA_OK;
+
+               if (coder-&gt;exp_filter_size &amp;&amp; coder-&gt;exp_block_size) {
+                       size_t exp;
+
+                       /*
+                        * It is assumed that the archive consists of multiple
+                        * blocks sharing the same filter and block settings.
+                        * Therefore it is assumed the new thread will consume
+                        * the same amount of filter memory and block-size for
+                        * the out (decompressed) memory. For in (compressed)
+                        * buffer it is assumed to consume block-size/2. The
+                        * in-buffer will grow if needed so we may exceed the
+                        * actual limit.
+                        */
+                       exp = coder-&gt;exp_filter_size;
+                       exp += coder-&gt;exp_block_size;
+                       exp += coder-&gt;exp_block_size / 2;
+
+                       if (coder-&gt;memusage + exp &gt; coder-&gt;memlimit) {
+                               coder-&gt;threads_max = coder-&gt;threads_initialized;
+                               return LZMA_OK;
+                       }
+               }
+
+               // Initialize a new thread.
+               return_if_error(initialize_new_thread(coder, allocator));
+       }
+
+       mythread_mutex_lock(&amp;coder-&gt;thr_write-&gt;mutex);
+       coder-&gt;thr_write-&gt;next = NULL;
+
+       coder-&gt;thr_write-&gt;in_block_size = 0;
+       coder-&gt;thr_write-&gt;in_filled = 0;
+       coder-&gt;thr_write-&gt;in_pos = 0;
+
+       coder-&gt;thr_write-&gt;out.out_pos = 0;
+       coder-&gt;thr_write-&gt;out.out_filled = 0;
+
+       memset(&amp;coder-&gt;thr_write-&gt;block_options, 0, sizeof(lzma_block));
+       coder-&gt;thr_write-&gt;state = THR_RUN;
+       mythread_mutex_unlock(&amp;coder-&gt;thr_write-&gt;mutex);
+
+       return LZMA_OK;
+}
+
+static lzma_ret alloc_out_buffer(struct lzma_stream_coder *coder,
+                                const lzma_allocator *allocator)
+{
+       struct worker_thread *thr;
+       struct out_buffer *buf;
+       size_t uncomp_size;
+
+       thr = coder-&gt;thr_write;
+       buf = &amp;thr-&gt;out;
+       uncomp_size = thr-&gt;block_options.uncompressed_size;
+
+       if (buf-&gt;out) {
+               if (buf-&gt;out_block_size == uncomp_size)
+                       goto recycle_old;
+
+               coder-&gt;memusage -= buf-&gt;out_block_size;
+               buf-&gt;out_block_size = 0;
+               lzma_free(buf-&gt;out, allocator);
+       }
+       buf-&gt;out = lzma_alloc(uncomp_size, allocator);
+       if (!buf-&gt;out)
+               return LZMA_MEM_ERROR;
+       coder-&gt;memusage += uncomp_size;
+       buf-&gt;out_block_size = uncomp_size;
+       if (coder-&gt;exp_block_size &lt; uncomp_size)
+               coder-&gt;exp_block_size = uncomp_size;
+
+recycle_old:
+       buf-&gt;out_pos = 0;
+       buf-&gt;out_filled = 0;
+
+       mythread_mutex_lock(&amp;coder-&gt;mutex);
+       if (!coder-&gt;thr_read) {
+               coder-&gt;thr_read = thr;
+               coder-&gt;thr_read_last = thr;
+       } else {
+               coder-&gt;thr_read_last-&gt;next = thr;
+               coder-&gt;thr_read_last = thr;
+       }
+       mythread_mutex_unlock(&amp;coder-&gt;mutex);
+       return LZMA_OK;
+}
+
+static lzma_ret try_copy_decoded(struct lzma_stream_coder *coder,
+                            uint8_t *restrict out, size_t *restrict out_pos,
+                            size_t out_size)
+{
+       struct out_buffer *out_buff;
+       size_t out_buff_size;
+
+       if (!coder-&gt;thr_read)
+               return LZMA_OK;
+
+       out_buff = &amp;coder-&gt;thr_read-&gt;out;
+
+       do {
+               /* block fully consumed */
+               if (out_buff-&gt;out_filled == out_buff-&gt;out_block_size) {
+                       struct worker_thread *thr_new;
+                       struct worker_thread *thr_old;
+                       lzma_ret ret;
+
+                       ret = lzma_index_hash_append(coder-&gt;index_hash,
+                                                    
lzma_block_unpadded_size(&amp;coder-&gt;thr_read-&gt;block_options),
+                                                    
coder-&gt;thr_read-&gt;block_options.uncompressed_size);
+                       if (ret != LZMA_OK)
+                               return ret;
+
+                       mythread_mutex_lock(&amp;coder-&gt;mutex);
+                       thr_old = coder-&gt;thr_read;
+                       thr_new = thr_old-&gt;next;
+                       thr_old-&gt;next = NULL;
+
+                       if (coder-&gt;threads_free)
+                               thr_old-&gt;next = coder-&gt;threads_free;
+                       coder-&gt;threads_free = thr_old;
+                       coder-&gt;thr_read = thr_new;
+
+                       mythread_mutex_unlock(&amp;coder-&gt;mutex);
+
+                       if (!thr_new)
+                               return LZMA_OK;
+
+                       out_buff = &amp;thr_new-&gt;out;
+               }
+
+               /* whatever is done has been consumed */
+               if (out_buff-&gt;out_pos == out_buff-&gt;out_filled)
+                       return LZMA_OK;
+
+               if (*out_pos == out_size)
+                       return LZMA_OK;
+
+               mythread_mutex_lock(&amp;coder-&gt;mutex);
+               out_buff_size = out_buff-&gt;out_pos;
+               mythread_mutex_unlock(&amp;coder-&gt;mutex);
+
+               lzma_bufcpy(out_buff-&gt;out, &amp;out_buff-&gt;out_filled, out_buff_size,
+                           out, out_pos, out_size);
+       } while (1);
+}
+
+static size_t comp_blk_size(struct lzma_stream_coder *coder, size_t size)
+{
+       return vli_ceil4(size) + lzma_check_size(coder-&gt;stream_flags.check);
+}
+
+static lzma_ret
+stream_decoder_reset(struct lzma_stream_coder *coder, const lzma_allocator 
*allocator)
+{
+       // Initialize the Index hash used to verify the Index.
+       coder-&gt;index_hash = lzma_index_hash_init(coder-&gt;index_hash, allocator);
+       if (coder-&gt;index_hash == NULL)
+               return LZMA_MEM_ERROR;
+
+       // Reset the rest of the variables.
+       coder-&gt;sequence = SEQ_STREAM_HEADER;
+       coder-&gt;pos = 0;
+
+       return LZMA_OK;
+}
+
+static lzma_ret
+stream_decode_mt(void *coder_ptr, const lzma_allocator *allocator,
+                const uint8_t *restrict in, size_t *restrict in_pos,
+                size_t in_size,
+                uint8_t *restrict out, size_t *restrict out_pos,
+                size_t out_size, lzma_action action)
+{
+       struct lzma_stream_coder *coder = coder_ptr;
+       struct worker_thread *thr;
+       lzma_ret ret;
+       size_t start_in_pos = *in_pos;
+       size_t start_out_pos = *out_pos;
+
+
+       while (true)
+       switch (coder-&gt;sequence) {
+       case SEQ_STREAM_HEADER: {
+               // Copy the Stream Header to the internal buffer.
+               lzma_bufcpy(in, in_pos, in_size, coder-&gt;buffer, &amp;coder-&gt;pos,
+                           LZMA_STREAM_HEADER_SIZE);
+
+               // Return if we didn't get the whole Stream Header yet.
+               if (coder-&gt;pos &lt; LZMA_STREAM_HEADER_SIZE)
+                       return LZMA_OK;
+
+               coder-&gt;pos = 0;
+
+               // Decode the Stream Header.
+               ret = lzma_stream_header_decode(&amp;coder-&gt;stream_flags,
+                                               coder-&gt;buffer);
+               if (ret != LZMA_OK)
+                       return ret == LZMA_FORMAT_ERROR &amp;&amp; !coder-&gt;first_stream
+                               ? LZMA_DATA_ERROR : ret;
+
+               // If we are decoding concatenated Streams, and the later
+               // Streams have invalid Header Magic Bytes, we give
+               // LZMA_DATA_ERROR instead of LZMA_FORMAT_ERROR.
+               coder-&gt;first_stream = false;
+
+               // Even if we return LZMA_*_CHECK below, we want
+               // to continue from Block Header decoding.
+               coder-&gt;sequence = SEQ_BLOCK_HEADER;
+
+               // Detect if there's no integrity check or if it is
+               // unsupported if those were requested by the application.
+               if (coder-&gt;tell_no_check &amp;&amp; coder-&gt;stream_flags.check
+                    == LZMA_CHECK_NONE)
+                       return LZMA_NO_CHECK;
+
+               if (coder-&gt;tell_unsupported_check
+                    &amp;&amp; !lzma_check_is_supported(coder-&gt;stream_flags.check))
+                        return LZMA_UNSUPPORTED_CHECK;
+
+                if (coder-&gt;tell_any_check)
+                        return LZMA_GET_CHECK;
+                break;
+       }
+
+       case SEQ_BLOCK_HEADER: {
+              if (*in_pos &gt;= in_size)
+                      return LZMA_OK;
+
+              thr = coder-&gt;thr_write;
+              if (!thr) {
+seq_blk_hdr_again:
+                      ret = try_copy_decoded(coder, out, out_pos, out_size);
+                      if (ret != LZMA_OK)
+                              return ret;
+
+                      ret = get_thread(coder, allocator);
+                      if (ret != LZMA_OK)
+                              return ret;
+
+                      if (!coder-&gt;thr_write) {
+
+                              /* No out buffer but making progress ? */
+                              if ((start_in_pos != *in_pos) ||
+                                   (start_out_pos != *out_pos))
+                                      return LZMA_OK;
+
+                              mythread_mutex_lock(&amp;coder-&gt;mutex);
+                              if (coder-&gt;thr_read-&gt;out.out_pos == 
coder-&gt;thr_read-&gt;out.out_filled)
+                                      mythread_cond_wait(&amp;coder-&gt;cond, 
&amp;coder-&gt;mutex);
+
+                              mythread_mutex_unlock(&amp;coder-&gt;mutex);
+                      }
+                      thr = coder-&gt;thr_write;
+                      if (!thr)
+                              goto seq_blk_hdr_again;
+              }
+
+              if (coder-&gt;pos == 0) {
+                      // Detect if it's Index.
+                      if (in[*in_pos] == 0x00) {
+                              coder-&gt;sequence = SEQ_INDEX;
+                              break;
+                      }
+
+                      // Calculate the size of the Block Header. Note that
+                      // Block Header decoder wants to see this byte too
+                      // so don't advance *in_pos.
+                      thr-&gt;block_options.header_size =
+                              lzma_block_header_size_decode(in[*in_pos]);
+              }
+
+              // Copy the Block Header to the internal buffer.
+
+              lzma_bufcpy(in, in_pos, in_size, coder-&gt;buffer, &amp;coder-&gt;pos,
+                          thr-&gt;block_options.header_size);
+
+              // Return if we didn't get the whole Block Header yet.
+              if (coder-&gt;pos &lt; thr-&gt;block_options.header_size)
+                      return LZMA_OK;
+
+              coder-&gt;pos = 0;
+
+              // Version 1 is needed to support the .ignore_check option.
+              thr-&gt;block_options.version = 1;
+
+              // Set up a buffer to hold the filter chain. Block Header
+              // decoder will initialize all members of this array so
+              // we don't need to do it here.
+              lzma_filter filters[LZMA_FILTERS_MAX + 1];
+              thr-&gt;block_options.filters = filters;
+
+              // Copy the type of the Check so that Block Header and Block
+              // decoders see it.
+              thr-&gt;block_options.check = coder-&gt;stream_flags.check;
+
+              // Decode the Block Header.
+              ret = lzma_block_header_decode(&amp;thr-&gt;block_options, allocator,
+                                             coder-&gt;buffer);
+              if (ret != LZMA_OK)
+                      return ret;
+
+              // If LZMA_IGNORE_CHECK was used, this flag needs to be set.
+              // It has to be set after lzma_block_header_decode() because
+              // it always resets this to false.
+              thr-&gt;block_options.ignore_check = coder-&gt;ignore_check;
+
+              if (thr-&gt;block_options.compressed_size == LZMA_VLI_UNKNOWN ||
+                  thr-&gt;block_options.uncompressed_size == LZMA_VLI_UNKNOWN) {
+
+                      /*
+                       * Happens if the previous (first) block header has sizes
+                       * encoded but one of the following block header does
+                       * not.
+                       */
+                      if (coder-&gt;threads_initialized != 1)
+                              return LZMA_PROG_ERROR;
+
+                      coder-&gt;direct_decomp = true;
+              } else {
+                      ret = alloc_out_buffer(coder, allocator);
+                      if (ret != LZMA_OK)
+                              return ret;
+
+                      thr-&gt;in_block_size = comp_blk_size(coder, 
thr-&gt;block_options.compressed_size);
+
+                      if (thr-&gt;in_size &lt; thr-&gt;in_block_size) {
+                              coder-&gt;memusage -= thr-&gt;in_size;
+                              lzma_free(thr-&gt;in, allocator);
+
+                              thr-&gt;in = lzma_alloc(thr-&gt;in_block_size, 
allocator);
+                              if (!thr-&gt;in)
+                                      return LZMA_MEM_ERROR;
+                              thr-&gt;in_size = thr-&gt;in_block_size;
+                              coder-&gt;memusage += thr-&gt;in_size;
+                      }
+              }
+
+              // Check the memory usage limit.
+              const uint64_t memusage = lzma_raw_decoder_memusage(filters);
+
+              if (memusage == UINT64_MAX) {
+                      // One or more unknown Filter IDs.
+                      ret = LZMA_OPTIONS_ERROR;
+              } else {
+                      if (coder-&gt;exp_filter_size &lt; memusage)
+                              coder-&gt;exp_filter_size = memusage;
+
+                      /*
+                       * The coder-&gt;memusage contains the size of in+out
+                       * buffer. Only for the first thread the check against
+                       * the filter size is made. Later it is attempted not to
+                       * create new threads if the memory limit is about to get
+                       * exceeded. Since the `in' buffer will be enlarged if
+                       * needed we may exceed the memory limit. Therefore there
+                       * is no further check for memusage to not abort work in
+                       * the middle.
+                       */
+                      if (coder-&gt;threads_initialized == 1 &amp;&amp;
+                          coder-&gt;memusage + memusage &gt; coder-&gt;memlimit) {
+                              // The chain would need too much memory.
+                              ret = LZMA_MEMLIMIT_ERROR;
+                      } else {
+                              // Memory usage is OK.
+                              // Initialize the Block decoder.
+                              ret = lzma_block_decoder_init(
+                                                            
&amp;thr-&gt;block_decoder,
+                                                            allocator,
+                                                            
&amp;thr-&gt;block_options);
+                              if (thr-&gt;filter_size != memusage) {
+                                      coder-&gt;memusage -= thr-&gt;filter_size;
+                                      coder-&gt;memusage += memusage;
+                                      thr-&gt;filter_size = memusage;
+                              }
+                      }
+              }
+
+              // Free the allocated filter options since they are needed
+              // only to initialize the Block decoder.
+              for (size_t i = 0; i &lt; LZMA_FILTERS_MAX; ++i)
+                      lzma_free(filters[i].options, allocator);
+              thr-&gt;block_options.filters = NULL;
+              // Check if memory usage calculation and Block enocoder
+              // initialization succeeded.
+              if (ret != LZMA_OK)
+                      return ret;
+
+              coder-&gt;sequence = SEQ_BLOCK;
+              break;
+
+       case SEQ_BLOCK:
+              thr = coder-&gt;thr_write;
+
+              /* Direct decompression if we lack sizes in block header */
+              if (coder-&gt;direct_decomp) {
+                      ret = thr-&gt;block_decoder.code(thr-&gt;block_decoder.coder,
+                                                    thr-&gt;allocator,
+                                                    in, in_pos, in_size,
+                                                    out, out_pos, out_size,
+                                                    action);
+                      if (ret != LZMA_STREAM_END)
+                              return ret;
+
+                      // Block decoded successfully. Add the new size pair to
+                      // the Index hash.
+                      ret = lzma_index_hash_append(coder-&gt;index_hash,
+                                                   
lzma_block_unpadded_size(&amp;thr-&gt;block_options),
+                                                   
thr-&gt;block_options.uncompressed_size);
+                      if (ret != LZMA_OK)
+                              return ret;
+
+                      coder-&gt;sequence = SEQ_BLOCK_HEADER;
+                      break;
+              }
+
+              ret = try_copy_decoded(coder, out, out_pos, out_size);
+              if (ret != LZMA_OK)
+                      return ret;
+
+              ret = stream_decode_in(coder, in, in_pos, in_size);
+              if (ret != LZMA_OK) {
+                      threads_stop(coder, false);
+                      return ret;
+              }
+
+              if ((*in_pos &gt;= in_size) || (*out_pos &gt;= out_size))
+                      return LZMA_OK;
+
+              break;
+       }
+
+       case SEQ_INDEX: {
+                // If we don't have any input, don't call
+                // lzma_index_hash_decode() since it would return
+                // LZMA_BUF_ERROR, which we must not do here.
+                if (*in_pos &gt;= in_size)
+                        return LZMA_OK;
+
+               /* first flush all worker threads, so the accounting of decoded
+                * blocks matches index's expectation.
+                */
+               while (coder-&gt;thr_read) {
+                       ret = try_copy_decoded(coder, out, out_pos, out_size);
+                       if (ret != LZMA_OK)
+                               return ret;
+
+                       if (*out_pos &gt;= out_size)
+                               return LZMA_OK;
+
+                       if (!coder-&gt;thr_read)
+                               break;
+
+                       mythread_mutex_lock(&amp;coder-&gt;mutex);
+                       if (coder-&gt;thr_read-&gt;out.out_pos == 
coder-&gt;thr_read-&gt;out.out_filled)
+                               mythread_cond_wait(&amp;coder-&gt;cond, &amp;coder-&gt;mutex);
+                       mythread_mutex_unlock(&amp;coder-&gt;mutex);
+               }
+
+                // Decode the Index and compare it to the hash calculated
+                // from the sizes of the Blocks (if any).
+               ret = lzma_index_hash_decode(coder-&gt;index_hash, in, in_pos,
+                                            in_size);
+                if (ret != LZMA_STREAM_END) {
+                        return ret;
+               }
+
+                coder-&gt;sequence = SEQ_STREAM_FOOTER;
+               break;
+       }
+
+       case SEQ_STREAM_FOOTER:
+
+               lzma_bufcpy(in, in_pos, in_size, coder-&gt;buffer, &amp;coder-&gt;pos,
+                           LZMA_STREAM_HEADER_SIZE);
+
+               // Return if we didn't get the whole Stream Footer yet.
+               if (coder-&gt;pos &lt; LZMA_STREAM_HEADER_SIZE)
+                       return LZMA_OK;
+
+               coder-&gt;pos = 0;
+               // Decode the Stream Footer. The decoder gives
+               // LZMA_FORMAT_ERROR if the magic bytes don't match,
+               // so convert that return code to LZMA_DATA_ERROR.
+               lzma_stream_flags footer_flags;
+               ret = lzma_stream_footer_decode(&amp;footer_flags, coder-&gt;buffer);
+               if (ret != LZMA_OK)
+                       return ret == LZMA_FORMAT_ERROR
+                               ? LZMA_DATA_ERROR : ret;
+
+               // Check that Index Size stored in the Stream Footer matches
+               // the real size of the Index field.
+               if (lzma_index_hash_size(coder-&gt;index_hash)
+                   != footer_flags.backward_size)
+                       return LZMA_DATA_ERROR;
+
+               // Compare that the Stream Flags fields are identical in
+               // both Stream Header and Stream Footer.
+               ret = lzma_stream_flags_compare(&amp;coder-&gt;stream_flags, 
&amp;footer_flags);
+               if (ret != LZMA_OK)
+                       return ret;
+
+               if (!coder-&gt;concatenated)
+                       return LZMA_STREAM_END;
+               coder-&gt;sequence = SEQ_STREAM_PADDING;
+               break;
+
+       case SEQ_STREAM_PADDING: {
+
+               // Skip over possible Stream Padding.
+               while (true) {
+                       if (*in_pos &gt;= in_size) {
+                               // Unless LZMA_FINISH was used, we cannot
+                               // know if there's more input coming later.
+                               if (action != LZMA_FINISH) {
+                                       return LZMA_OK;
+                               }
+
+                               // Stream Padding must be a multiple of
+                               // four bytes.
+                               return coder-&gt;pos == 0
+                                       ? LZMA_STREAM_END
+                                       : LZMA_DATA_ERROR;
+                       }
+
+                       // If the byte is not zero, it probably indicates
+                       // beginning of a new Stream (or the file is corrupt).
+                       if (in[*in_pos] != 0x00)
+                               break;
+
+                       ++*in_pos;
+                       coder-&gt;pos = (coder-&gt;pos + 1) &amp; 3;
+               }
+
+               // Stream Padding must be a multiple of four bytes (empty
+               // Stream Padding is OK).
+               if (coder-&gt;pos != 0) {
+                       ++*in_pos;
+                       return LZMA_DATA_ERROR;
+               }
+
+               // Prepare to decode the next Stream.
+               return_if_error(stream_decoder_reset(coder, allocator));
+               break;
+       }
+
+       default:
+                assert(0);
+                return LZMA_PROG_ERROR;
+       }
+       return LZMA_PROG_ERROR;
+}
+
+static lzma_check stream_decoder_mt_get_check(const void *coder_ptr)
+{
+       const struct lzma_stream_coder *coder = coder_ptr;
+       return coder-&gt;stream_flags.check;
+}
+
+static lzma_ret stream_decoder_mt_memconfig(void *coder_ptr, uint64_t 
*memusage,
+                                           uint64_t *old_memlimit,
+                                           uint64_t new_memlimit)
+{
+       struct lzma_stream_coder *coder = coder_ptr;
+
+       *memusage = coder-&gt;memusage;
+       *old_memlimit = coder-&gt;memlimit;
+
+       if (new_memlimit != 0) {
+               if (new_memlimit &lt; coder-&gt;memusage)
+                       return LZMA_MEMLIMIT_ERROR;
+
+               coder-&gt;memlimit = new_memlimit;
+       }
+
+       return LZMA_OK;
+}
+
+
+static lzma_ret
+stream_decoder_mt_init(lzma_next_coder *next, const lzma_allocator *allocator,
+                      const lzma_mt *options)
+{
+       struct lzma_stream_coder *coder;
+
+       if (options-&gt;threads == 0 || options-&gt;threads &gt; LZMA_THREADS_MAX)
+               return LZMA_OPTIONS_ERROR;
+       if (options-&gt;flags &amp; ~LZMA_SUPPORTED_FLAGS)
+               return LZMA_OPTIONS_ERROR;
+
+       lzma_next_coder_init(&amp;stream_decoder_mt_init, next, allocator);
+
+       coder = next-&gt;coder;
+       if (!coder) {
+               coder = lzma_alloc(sizeof(struct lzma_stream_coder), allocator);
+               if (coder == NULL)
+                       return LZMA_MEM_ERROR;
+
+               memset(coder, 0xff, sizeof(struct lzma_stream_coder));
+
+               if (mythread_mutex_init(&amp;coder-&gt;mutex))
+                       goto err_out;
+
+               if (mythread_cond_init(&amp;coder-&gt;cond)) {
+                       mythread_mutex_destroy(&amp;coder-&gt;mutex);
+                       goto err_out;
+               }
+
+               next-&gt;coder = coder;
+
+               next-&gt;code = stream_decode_mt;
+               next-&gt;end = stream_decoder_mt_end;
+               next-&gt;get_check = stream_decoder_mt_get_check;
+               next-&gt;memconfig = &amp;stream_decoder_mt_memconfig;
+
+               next-&gt;get_progress = NULL;
+
+               coder-&gt;index_hash = NULL;
+               coder-&gt;threads_max = 0;
+               coder-&gt;threads_initialized = 0;
+       }
+
+       coder-&gt;sequence = SEQ_STREAM_HEADER;
+
+       coder-&gt;memlimit = my_max(1, options-&gt;memlimit);
+       coder-&gt;memusage = LZMA_MEMUSAGE_BASE;
+
+       coder-&gt;tell_no_check = options-&gt;flags &amp; LZMA_TELL_NO_CHECK;
+       coder-&gt;tell_unsupported_check = options-&gt;flags &amp; 
LZMA_TELL_UNSUPPORTED_CHECK;
+       coder-&gt;tell_any_check = options-&gt;flags &amp; LZMA_TELL_ANY_CHECK;
+       coder-&gt;ignore_check = options-&gt;flags &amp; LZMA_IGNORE_CHECK;
+       coder-&gt;concatenated = options-&gt;flags &amp; LZMA_CONCATENATED;
+       coder-&gt;first_stream = true;
+       coder-&gt;direct_decomp = false;
+       coder-&gt;exp_filter_size = 0;
+       coder-&gt;exp_block_size = 0;
+       coder-&gt;pos = 0;
+
+       memset(&amp;coder-&gt;stream_flags, 0, sizeof(lzma_stream_flags));
+       /* By allocating threads from scratch we can start memory-usage
+        * accouting from scratch, too. Changes in filter and block sizes may
+        * affect number of threads. We don't keep possible larger-than-needed
+        * in buffer (if the block size decreased) and have only one thread
+        * in case this stream has no block sizes (and `direct_decomp' expects
+        * no threads to keep it simple).
+        */
+       if (coder-&gt;threads_max) {
+               coder-&gt;threads_max = 0;
+               threads_end(coder, allocator);
+       }
+
+       coder-&gt;threads = lzma_alloc(options-&gt;threads * sizeof(struct 
worker_thread),
+                                   allocator);
+       if (coder-&gt;threads == NULL)
+               goto err_out;
+       coder-&gt;threads_free = NULL;
+       coder-&gt;thr_read = NULL;
+       coder-&gt;thr_read_last = NULL;
+       coder-&gt;thr_write = NULL;
+
+       coder-&gt;threads_max = options-&gt;threads;
+
+       return stream_decoder_reset(coder, allocator);
+
+err_out:
+       lzma_free(coder-&gt;threads, allocator);
+       lzma_free(coder, allocator);
+       return LZMA_MEM_ERROR;
+}
+
+extern LZMA_API(lzma_ret)
+lzma_stream_decoder_mt(lzma_stream *strm, const lzma_mt *options)
+{
+       lzma_next_strm_init(stream_decoder_mt_init, strm, options);
+
+       strm-&gt;internal-&gt;supported_actions[LZMA_RUN] = true;
+       strm-&gt;internal-&gt;supported_actions[LZMA_FINISH] = true;
+
+       return LZMA_OK;
+}
diff --git a/src/liblzma/liblzma.map b/src/liblzma/liblzma.map
index bad8633c3b8d2..3f34d8c2814f0 100644
--- a/src/liblzma/liblzma.map
+++ b/src/liblzma/liblzma.map
@@ -107,6 +107,7 @@ XZ_5.2 {
 XZ_5.3.1alpha {
 global:
        lzma_file_info_decoder;
+       lzma_stream_decoder_mt;
 
 local:
        *;
diff --git a/src/xz/coder.c b/src/xz/coder.c
index 85f954393d8bf..c22bf136285c5 100644
--- a/src/xz/coder.c
+++ b/src/xz/coder.c
@@ -51,7 +51,7 @@ static lzma_check check;
 /// This becomes false if the --check=CHECK option is used.
 static bool check_default = true;
 
-#if defined(HAVE_ENCODERS) &amp;&amp; defined(MYTHREAD_ENABLED)
+#if (defined(HAVE_ENCODERS) || defined(HAVE_DECODERS)) &amp;&amp; 
defined(MYTHREAD_ENABLED)
 static lzma_mt mt_options = {
        .flags = 0,
        .timeout = 300,
@@ -520,9 +520,16 @@ coder_init(file_pair *pair)
                        break;
 
                case FORMAT_XZ:
-                       ret = lzma_stream_decoder(&amp;strm,
-                                       hardware_memlimit_get(
-                                               MODE_DECOMPRESS), flags);
+                       if (hardware_threads_get() &gt; 1) {
+                               mt_options.threads = hardware_threads_get();
+                               mt_options.flags = flags;
+                               mt_options.memlimit = 
hardware_memlimit_get(MODE_DECOMPRESS);
+                               ret = lzma_stream_decoder_mt(&amp;strm, 
&amp;mt_options);
+                       } else {
+                               ret = lzma_stream_decoder(&amp;strm,
+                                                 hardware_memlimit_get(
+                                                       MODE_DECOMPRESS), 
flags);
+                       }
                        break;
 
                case FORMAT_LZMA:
-- 
2.29.2


</pre>

</div>
<div class="msgButtons margintopdouble">
<ul class="overflow">
<li class="msgButtonItems"><a class="button buttonleft " accesskey="p" href="msg00381.html">Previous message</a></li>
<li class="msgButtonItems textaligncenter"><a class="button" accesskey="c" href="index.html#00382">View by thread</a></li>
<li class="msgButtonItems textaligncenter"><a class="button" accesskey="i" href="maillist.html#00382">View by date</a></li>
<li class="msgButtonItems textalignright"><a class="button buttonright " accesskey="n" href="msg00386.html">Next message</a></li>
</ul>
</div>
<a name="tslice"></a>
<div class="tSliceList margintopdouble">
<ul class="icons monospace">

</ul>
</div>
<div class="overflow msgActions margintopdouble">
<div class="msgReply" >
<h2>
					Reply via email to
</h2>
<form method="POST" action="/mailto.php">
<input type="hidden" name="subject" value="[xz-devel] [PATCH] liblzma: Add multi-threaded decoder">
<input type="hidden" name="msgid" value="20201224000308.dmyxarbvel6ogdpk@flow">
<input type="hidden" name="relpath" value="xz-devel@tukaani.org/msg00382.html">
<input type="submit" value=" Sebastian Andrzej Siewior ">
</form>
</div>
</div>
</div>
<div class="aside" role="complementary">
<div class="logo">
<a href="/"><img src="/logo.png" width=247 height=88 alt="The Mail Archive"></a>
</div>
<form class="overflow" action="/search" method="get">
<input type="hidden" name="l" value="xz-devel@tukaani.org">
<label class="hidden" for="q">Search the site</label>
<input class="submittext" type="text" id="q" name="q" placeholder="Search xz-devel">
<input class="submitbutton" name="submit" type="image" src="/submit.png" alt="Submit">
</form>
<div class="nav margintop" id="nav" role="navigation">
<ul class="icons font16">
<li class="icons-home"><a href="/">The Mail Archive home</a></li>
<li class="icons-list"><a href="/xz-devel@tukaani.org/">xz-devel - all messages</a></li>
<li class="icons-about"><a href="/xz-devel@tukaani.org/info.html">xz-devel - about the list</a></li>
<li class="icons-expand"><a href="/search?l=xz-devel@tukaani.org&amp;q=subject:%22%5C%5Bxz%5C-devel%5C%5D+%5C%5BPATCH%5C%5D+liblzma%5C%3A+Add+multi%5C-threaded+decoder%22&amp;o=newest&amp;f=1" title="e" id="e">Expand</a></li>
<li class="icons-prev"><a href="msg00381.html" title="p">Previous message</a></li>
<li class="icons-next"><a href="msg00386.html" title="n">Next message</a></li>
</ul>
</div>
<div class="listlogo margintopdouble">

</div>
<div class="margintopdouble">

</div>
</div>
</div>
<div class="footer" role="contentinfo">
<ul>
<li><a href="/">The Mail Archive home</a></li>
<li><a href="/faq.html#newlist">Add your mailing list</a></li>
<li><a href="/faq.html">FAQ</a></li>
<li><a href="/faq.html#support">Support</a></li>
<li><a href="/faq.html#privacy">Privacy</a></li>
<li class="darkgray">20201224000308.dmyxarbvel6ogdpk@flow</li>
</ul>
</div>
</body>
</html>
