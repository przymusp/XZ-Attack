{"id":"29989121867","type":"IssueCommentEvent","actor":{"id":120408189,"login":"Larhzu","display_login":"Larhzu","gravatar_id":"","url":"https://api.github.com/users/Larhzu","avatar_url":"https://avatars.githubusercontent.com/u/120408189?"},"repo":{"id":503096977,"name":"riscv/riscv-cfi","url":"https://api.github.com/repos/riscv/riscv-cfi"},"payload":{"action":"created","issue":{"url":"https://api.github.com/repos/riscv/riscv-cfi/issues/113","repository_url":"https://api.github.com/repos/riscv/riscv-cfi","labels_url":"https://api.github.com/repos/riscv/riscv-cfi/issues/113/labels{/name}","comments_url":"https://api.github.com/repos/riscv/riscv-cfi/issues/113/comments","events_url":"https://api.github.com/repos/riscv/riscv-cfi/issues/113/events","html_url":"https://github.com/riscv/riscv-cfi/issues/113","id":1750993037,"node_id":"I_kwDOHfymkc5oXgiN","number":113,"title":"Landing pad encoding update","user":{"login":"ved-rivos","id":91900059,"node_id":"U_kgDOBXpImw","avatar_url":"https://avatars.githubusercontent.com/u/91900059?v=4","gravatar_id":"","url":"https://api.github.com/users/ved-rivos","html_url":"https://github.com/ved-rivos","followers_url":"https://api.github.com/users/ved-rivos/followers","following_url":"https://api.github.com/users/ved-rivos/following{/other_user}","gists_url":"https://api.github.com/users/ved-rivos/gists{/gist_id}","starred_url":"https://api.github.com/users/ved-rivos/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ved-rivos/subscriptions","organizations_url":"https://api.github.com/users/ved-rivos/orgs","repos_url":"https://api.github.com/users/ved-rivos/repos","events_url":"https://api.github.com/users/ved-rivos/events{/privacy}","received_events_url":"https://api.github.com/users/ved-rivos/received_events","type":"User","site_admin":false},"labels":[],"state":"closed","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":6,"created_at":"2023-06-10T14:32:24Z","updated_at":"2023-06-25T15:37:34Z","closed_at":"2023-06-17T15:58:31Z","author_association":"COLLABORATOR","active_lock_reason":null,"body":"Sharing an proposal for alternate encoding of landing pads from members of AR. The `lpcll` instruction to be renamed as `lpad` (landing pad) and the `lpcnl` removed. `lp` instruction embeds a 20-bit immediate as the label of the landing pad. This instruction would be encoded as `auipc` with `rd=0` - a code point that is presently a designated HINT.The encoding using the U-type hint provides a compact encoding for 20-bit labels. The indirect call/jump site would used `auipc x7, $label_imm` instruction to setup the expected landing pad label. The landing pad would be encoded as `lpad $label_imm`. \r\n","reactions":{"url":"https://api.github.com/repos/riscv/riscv-cfi/issues/113/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"timeline_url":"https://api.github.com/repos/riscv/riscv-cfi/issues/113/timeline","performed_via_github_app":null,"state_reason":"completed"},"comment":{"url":"https://api.github.com/repos/riscv/riscv-cfi/issues/comments/1606136445","html_url":"https://github.com/riscv/riscv-cfi/issues/113#issuecomment-1606136445","issue_url":"https://api.github.com/repos/riscv/riscv-cfi/issues/113","id":1606136445,"node_id":"IC_kwDOHfymkc5fu7J9","user":{"login":"Larhzu","id":120408189,"node_id":"U_kgDOBy1IfQ","avatar_url":"https://avatars.githubusercontent.com/u/120408189?v=4","gravatar_id":"","url":"https://api.github.com/users/Larhzu","html_url":"https://github.com/Larhzu","followers_url":"https://api.github.com/users/Larhzu/followers","following_url":"https://api.github.com/users/Larhzu/following{/other_user}","gists_url":"https://api.github.com/users/Larhzu/gists{/gist_id}","starred_url":"https://api.github.com/users/Larhzu/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/Larhzu/subscriptions","organizations_url":"https://api.github.com/users/Larhzu/orgs","repos_url":"https://api.github.com/users/Larhzu/repos","events_url":"https://api.github.com/users/Larhzu/events{/privacy}","received_events_url":"https://api.github.com/users/Larhzu/received_events","type":"User","site_admin":false},"created_at":"2023-06-25T15:37:34Z","updated_at":"2023-06-25T15:37:34Z","author_association":"NONE","body":"Thank you for the very exhaustive replies! I learned quite a few things.\r\n\r\nIt's great that implicit read from x7 is OK in this kind of case.\r\n\r\nI agree that requiring 4-byte alignment for landing pads is good. Even if hazardous pairs were made impossible with 16/32-bit instructions, accidental landing pads could still exist inside longer instructions and then alignment can help. The case of J-type instructions is another a good reason.\r\n\r\nMy motivation for posting was that the implications of \"assembler/linker can force instruction to be aligned to a 4-byte boundary\" in the spec sounded pretty complicated and I wondered if these requirements could be simplified easily enough but I understand that the cost of the simplest solutions is too high.\r\n\r\nIn addition to the requirements for toolchains, a minor extra thing is that assembly programmers could need to know about it (warnings can help). It's not intuitive that `srai a0, a5, 1` needs to be 4-byte aligned. If optimizing for size, assembler (or even linker) could need to be smart enough so that it won't insert a `c.nop` when `c.mv a0, a5; c.srai a0, 1` would be shorter (at the expense of a longer dependency chain).\r\n\r\nNew extensions add more accidental landing pads. For example, Zbb has a few good candidates with rs1=a4/a5: `ctz/ctzw`, and with certain immediates `rori`, `roriw`, `bclri`, `bexti`, `binvi`, `bseti`.\r\n\r\nI mention two more probably bad ideas for completeness (not proposals):\r\n\r\n  - Requiring inst[17:16]=3 (18-bit label) would ensure that accidental landing pads cannot form with 16-bit instructions. Thus jumping into such a landing pad wouldn't immediately synchronize with the instruction stream. I haven't looked at what kind of effect this would have in practice, like how often the instruction after an accidental landing pad is valid.\r\n\r\n  - Landing pads with inst[20:16]=0x1F cannot form accidentally with current and (likely) any future standard 16/32-bit instructions. If certain function signatures are especially common for indirect calls then it might help if the hash of popular functions had this kind of values. I guess it's not worth it but I mention this just in case.\r\n\r\nAnother way to look at accidental landing pads (I see @sorear edited his message so this is now partially duplicate):\r\n\r\n1. If all landing pads are labeled and thus all `jalr`, `lui+jalr`, and `auipc+jalr` uses are prefixed with `lui x7` then `lpad` with full 20-bit label is good at the ISA level. Some problematic labels could be banned in the ABI, for example, with @sorear's proposed methods. Then those labels appearing accidentally in the code wouldn't matter. The unlabeled `lpad` is a special case but `auipc x0, 0` seems pretty good since only `c.unimp` can create an accidental unlabeled landing pad with 16/32-bit instructions. This property of `c.unimp` could be good to explain in the specification, even if in practice it might not matter if `-falign-jumps=4` is used because then `jal+c.unimp` cannot be hazardous.\r\n\r\n2. If some (or all) code is built with unlabeled landing pads, then accidental labeled landing pads are a problem if attacker can control both the value of x7 and the function pointer. Here ISA restrictions on the possible landing pad labels could help to reduce the number of accidental landing pads (for example, @sorear's proposal 1 could be good as it's both quite effective and simple).\r\n\r\nHere are a few commands to count instructions that create accidental landing pads in a particular file. `objdump` is the slowest part so a tempoary file can be a good idea.\r\n\r\n```\r\nriscv64-elf-objdump -d -M no-aliases FILENAME \\\r\n    | grep '[26ae]:' \\\r\n    | grep -E '\\b[0-9a-f]017[0-9a-f]{4}\\b' \\\r\n    | tr -s ' ' | cut -f3 \\\r\n    | sort | uniq -c | sort -nr\r\n\r\n# Proposal 1, the only difference is 0->1 in \"\\b[1-9a-f]\":\r\nriscv64-elf-objdump -d -M no-aliases FILENAME \\\r\n    | grep '[26ae]:' \\\r\n    | grep -E '\\b[1-9a-f]017[0-9a-f]{4}\\b' \\\r\n    | tr -s ' ' | cut -f3 \\\r\n    | sort | uniq -c | sort -nr\r\n\r\n# Proposals 1 and 2 combined:\r\nriscv64-elf-objdump -d -M no-aliases FILENAME \\\r\n    | grep '[26ae]:' \\\r\n    | sed -rn '\r\n        /\\b[1-9a-f]017[0-9a-f]{4}\\b/{\r\n            N\r\n            /\\n.*\\b([0-9a-f]{4})?[0-9a-f]{2}([08]3|[08]7|[19]3|[2a]3|[2a]7|[6e]7)\\b/!P\r\n            D\r\n        }' \\\r\n    | tr -s ' ' | cut -f3 \\\r\n    | sort | uniq -c | sort -nr\r\n```\r\n\r\nBelow is sample output of the first command from libQt5WebKit.so.5.212.0 from Debian. .text is 19,189,602 bytes.\r\n\r\n```\r\n   4297 slliw\r\n   1455 addiw\r\n   1258 addi\r\n   1247 slli\r\n    778 andi\r\n    745 ori\r\n    508 sltiu\r\n    457 auipc\r\n    310 srliw\r\n    285 lbu\r\n    281 fcvt.s.d\r\n    176 csrrw       # csrrw zero,fflags,a4 or a5\r\n     91 xori\r\n     80 srli\r\n     45 sraiw\r\n     41 fcvt.wu.s\r\n     39 fcvt.s.wu\r\n     36 srai\r\n      7 fadd.s\r\n      4 jal\r\n      4 fmul.s\r\n      4 fle.s\r\n      3 xor\r\n      2 slti\r\n      2 ld\r\n      2 fsw\r\n      1 sd\r\n      1 lw\r\n      1 lb\r\n      1 feq.s\r\n```\r\n\r\nWith proposal 1:\r\n\r\n```\r\n    281 fcvt.s.d\r\n    102 addi\r\n     45 sraiw\r\n     41 fcvt.wu.s\r\n     39 fcvt.s.wu\r\n     36 srai\r\n      4 jal\r\n      4 fmul.s\r\n      4 fle.s\r\n      1 sd\r\n      1 ori\r\n      1 lbu\r\n      1 feq.s\r\n      1 addiw\r\n```\r\n\r\nProposals 1 and 2 combined:\r\n\r\n```\r\n    241 fcvt.s.d\r\n     93 addi\r\n     38 sraiw\r\n     35 fcvt.s.wu\r\n     25 srai\r\n     18 fcvt.wu.s\r\n      4 fmul.s\r\n      4 fle.s\r\n      3 jal\r\n      1 lbu\r\n      1 feq.s\r\n```\r\n\r\nAbout MOPs:\r\n\r\nWhile I understand that maybe-ops can be convenient in general, I didn't understand why they are useful for shadow stack when reading the spec. I got an impression that `sspush`, `sspopchk`, and their RVC counterparts could be RVI/RVC hints as they don't write to any general purpose registers and the shadow stack memory is not available for normal memory access. So those instructions have a kind of invisible effect just like `lpad` has.\r\n\r\nExcluding the control stack mode, the rest of the shadow stack instructions are needed in special locations only and thus they could be normal instructions that would be guarded with runtime detection (like `__attribute__(ifunc(...))`. Maybe they wouldn't even need to do the xBCFIE check in hardware.\r\n\r\nHowever, my understanding of this topic is very inadequate and I might be missing several elephants in the room. So it's better that I won't comment MOPs or shadow stack instructions any further. :-)\r\n","reactions":{"url":"https://api.github.com/repos/riscv/riscv-cfi/issues/comments/1606136445/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null}},"public":true,"created_at":"2023-06-25T15:37:35Z","org":{"id":10872782,"login":"riscv","gravatar_id":"","url":"https://api.github.com/orgs/riscv","avatar_url":"https://avatars.githubusercontent.com/u/10872782?"}}
