commit 761f5b69a4c778c8bcb09279b845b07c28790575
Author: Jia Tan <jiat0218@gmail.com>
Date:   Mon Jan 22 20:54:56 2024 +0800

    liblzma: Rename crc32_aarch64.h to crc32_arm64.h.
    
    Even though the proper name for the architecture is aarch64, this
    project uses ARM64 throughout. So the rename is for consistency.
    
    Additionally, crc32_arm64.h was slightly refactored for the following
    changes:
    
       * Added MSVC, FreeBSD, and macOS support in
         is_arch_extension_supported().
    
       * crc32_arch_optimized() now checks the size when aligning the
         buffer.
    
       * crc32_arch_optimized() loop conditions were slightly modified to
         avoid both decrementing the size and incrementing the buffer
         pointer.
    
       * Use the intrinsic wrappers defined in <arm_acle.h> because GCC and
         Clang name them differently.
    
       * Minor spacing and comment changes.

diff --git a/CMakeLists.txt b/CMakeLists.txt
index b21090f7..408b1605 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -1,1659 +1,1659 @@
 #############################################################################
 #
 # Very limited CMake support for building some parts of XZ Utils
 #
 # For now, this is intended to be useful to build static or shared liblzma
 # on Windows with MSVC (to avoid the need to maintain Visual Studio project
 # files). Building liblzma on a few other platforms should work too but it
 # is somewhat experimental and not as portable as using ./configure.
 #
 # On some platforms this builds also xz and xzdec, but these are
 # highly experimental and meant for testing only:
 #   - No translations
 #
 # Other missing things:
 #   - No xzgrep or other scripts or their symlinks
 #   - No xz tests (liblzma tests only)
 #
 # NOTE: Even if the code compiles without warnings, the end result may be
 # different than via ./configure. Specifically, the list of #defines
 # may be different (if so, probably this CMakeLists.txt got them wrong).
 #
 # This file provides the following installation components (if you only
 # need liblzma, install only its components!):
 #   - liblzma_Runtime
 #   - liblzma_Development
 #   - xz (on some platforms only)
 #   - xzdec (on some platforms only)
 #
 # To find the target liblzma::liblzma from other packages, use the CONFIG
 # option with find_package() to avoid a conflict with the FindLibLZMA module
 # with case-insensitive file systems. For example, to require liblzma 5.2.5
 # or a newer compatible version:
 #
 #     find_package(liblzma 5.2.5 REQUIRED CONFIG)
 #     target_link_libraries(my_application liblzma::liblzma)
 #
 #############################################################################
 #
 # Author: Lasse Collin
 #
 # This file has been put into the public domain.
 # You can do whatever you want with this file.
 #
 #############################################################################
 
 cmake_minimum_required(VERSION 3.13...3.27 FATAL_ERROR)
 
 include(CMakePushCheckState)
 include(CheckIncludeFile)
 include(CheckSymbolExists)
 include(CheckStructHasMember)
 include(CheckCSourceCompiles)
 include(cmake/tuklib_large_file_support.cmake)
 include(cmake/tuklib_integer.cmake)
 include(cmake/tuklib_cpucores.cmake)
 include(cmake/tuklib_physmem.cmake)
 include(cmake/tuklib_progname.cmake)
 include(cmake/tuklib_mbstr.cmake)
 
 set(PACKAGE_NAME "XZ Utils")
 set(PACKAGE_BUGREPORT "xz@tukaani.org")
 set(PACKAGE_URL "https://xz.tukaani.org/xz-utils/")
 
 # Get the package version from version.h into PACKAGE_VERSION variable.
 file(READ src/liblzma/api/lzma/version.h PACKAGE_VERSION)
 string(REGEX REPLACE
 "^.*\n\
 #define LZMA_VERSION_MAJOR ([0-9]+)\n\
 .*\
 #define LZMA_VERSION_MINOR ([0-9]+)\n\
 .*\
 #define LZMA_VERSION_PATCH ([0-9]+)\n\
 .*$"
        "\\1.\\2.\\3" PACKAGE_VERSION "${PACKAGE_VERSION}")
 
 # Among other things, this gives us variables xz_VERSION and xz_VERSION_MAJOR.
 project(xz VERSION "${PACKAGE_VERSION}" LANGUAGES C)
 
 # We need a compiler that supports enough C99 or newer (variable-length arrays
 # aren't needed, those are optional in C17). Setting CMAKE_C_STANDARD here
 # makes it the default for all targets. It doesn't affect the INTERFACE so
 # liblzma::liblzma won't end up with INTERFACE_COMPILE_FEATURES "c_std_99"
 # (the API headers are C89 and C++ compatible).
 set(CMAKE_C_STANDARD 99)
 set(CMAKE_C_STANDARD_REQUIRED ON)
 
 # On Apple OSes, don't build executables as bundles:
 set(CMAKE_MACOSX_BUNDLE OFF)
 
 # windres from GNU binutils can be tricky with command line arguments
 # that contain spaces or other funny characters. Unfortunately we need
 # a space in PACKAGE_NAME. Using \x20 to encode the US-ASCII space seems
 # to work in both cmd.exe and /bin/sh.
 #
 # However, even \x20 isn't enough in all situations, resulting in
 # "syntax error" from windres. Using --use-temp-file prevents windres
 # from using popen() and this seems to fix the problem.
 #
 # llvm-windres from Clang/LLVM 16.0.6 and older: The \x20 results
 # in "XZx20Utils" in the compiled binary. The option --use-temp-file
 # makes no difference.
 #
 # llvm-windres 17.0.0 and later: It emulates GNU windres more accurately, so
 # the workarounds used with GNU windres must be used with llvm-windres too.
 #
 # CMake 3.27 doesn't have CMAKE_RC_COMPILER_ID so we rely on
 # CMAKE_C_COMPILER_ID.
 if((MINGW OR CYGWIN OR MSYS) AND (
         NOT CMAKE_C_COMPILER_ID STREQUAL "Clang" OR
         CMAKE_C_COMPILER_VERSION VERSION_GREATER_EQUAL "17"))
     # Use workarounds with GNU windres and llvm-windres >= 17.0.0. The \x20
     # in PACKAGE_NAME_DEFINITION works with gcc and clang too so we don't need
     # to worry how to pass different flags to windres and the C compiler.
     # Keep the original PACKAGE_NAME intact for generation of liblzma.pc.
     string(APPEND CMAKE_RC_FLAGS " --use-temp-file")
     string(REPLACE " " "\\x20" PACKAGE_NAME_DEFINITION "${PACKAGE_NAME}")
 else()
     # Elsewhere a space is safe. This also keeps things compatible with
     # EBCDIC in case CMake-based build is ever done on such a system.
     set(PACKAGE_NAME_DEFINITION "${PACKAGE_NAME}")
 endif()
 
 # Definitions common to all targets:
 add_compile_definitions(
     # Package info:
     PACKAGE_NAME="${PACKAGE_NAME_DEFINITION}"
     PACKAGE_BUGREPORT="${PACKAGE_BUGREPORT}"
     PACKAGE_URL="${PACKAGE_URL}"
 
     # Standard headers and types are available:
     HAVE_STDBOOL_H
     HAVE__BOOL
     HAVE_STDINT_H
     HAVE_INTTYPES_H
 
     # Always enable CRC32 since liblzma should never build without it.
     HAVE_CHECK_CRC32
 
     # Disable assert() checks when no build type has been specified. Non-empty
     # build types like "Release" and "Debug" handle this by default.
     $<$<CONFIG:>:NDEBUG>
 )
 
 
 ######################
 # System definitions #
 ######################
 
 # _GNU_SOURCE and such definitions. This specific macro is special since
 # it also adds the definitions to CMAKE_REQUIRED_DEFINITIONS.
 tuklib_use_system_extensions(ALL)
 
 # Check for large file support. It's required on some 32-bit platforms and
 # even on 64-bit MinGW-w64 to get 64-bit off_t. This can be forced off on
 # the CMake command line if needed: -DLARGE_FILE_SUPPORT=OFF
 tuklib_large_file_support(ALL)
 
 # This is needed by liblzma and xz.
 tuklib_integer(ALL)
 
 # This is used for liblzma.pc generation to add -lrt if needed.
 set(LIBS)
 
 # Check for clock_gettime(). Do this before checking for threading so
 # that we know there if CLOCK_MONOTONIC is available.
 check_symbol_exists(clock_gettime time.h HAVE_CLOCK_GETTIME)
 
 if(NOT HAVE_CLOCK_GETTIME)
     # With glibc <= 2.17 or Solaris 10 this needs librt.
     # Add librt for the next check for HAVE_CLOCK_GETTIME. If it is
     # found after including the library, we know that librt is required.
     list(INSERT CMAKE_REQUIRED_LIBRARIES 0 rt)
     check_symbol_exists(clock_gettime time.h HAVE_CLOCK_GETTIME_LIBRT)
 
     # If it was found now, add librt to all targets and keep it in
     # CMAKE_REQUIRED_LIBRARIES for further tests too.
     if(HAVE_CLOCK_GETTIME_LIBRT)
         link_libraries(rt)
         set(LIBS "-lrt") # For liblzma.pc
     else()
         list(REMOVE_AT CMAKE_REQUIRED_LIBRARIES 0)
     endif()
 endif()
 
 if(HAVE_CLOCK_GETTIME OR HAVE_CLOCK_GETTIME_LIBRT)
     add_compile_definitions(HAVE_CLOCK_GETTIME)
 
     # Check if CLOCK_MONOTONIC is available for clock_gettime().
     check_symbol_exists(CLOCK_MONOTONIC time.h HAVE_CLOCK_MONOTONIC)
     tuklib_add_definition_if(ALL HAVE_CLOCK_MONOTONIC)
 endif()
 
 # Options for new enough GCC or Clang on any arch or operating system:
 if(CMAKE_C_COMPILER_ID MATCHES GNU|Clang)
     # configure.ac has a long list but it won't be copied here:
     add_compile_options(-Wall -Wextra)
 endif()
 
 
 #############################################################################
 # liblzma
 #############################################################################
 
 option(BUILD_SHARED_LIBS "Build liblzma as a shared library instead of static")
 
 add_library(liblzma
     src/common/mythread.h
     src/common/sysdefs.h
     src/common/tuklib_common.h
     src/common/tuklib_config.h
     src/common/tuklib_integer.h
     src/common/tuklib_physmem.c
     src/common/tuklib_physmem.h
     src/liblzma/api/lzma.h
     src/liblzma/api/lzma/base.h
     src/liblzma/api/lzma/bcj.h
     src/liblzma/api/lzma/block.h
     src/liblzma/api/lzma/check.h
     src/liblzma/api/lzma/container.h
     src/liblzma/api/lzma/delta.h
     src/liblzma/api/lzma/filter.h
     src/liblzma/api/lzma/hardware.h
     src/liblzma/api/lzma/index.h
     src/liblzma/api/lzma/index_hash.h
     src/liblzma/api/lzma/lzma12.h
     src/liblzma/api/lzma/stream_flags.h
     src/liblzma/api/lzma/version.h
     src/liblzma/api/lzma/vli.h
     src/liblzma/check/check.c
     src/liblzma/check/check.h
     src/liblzma/check/crc_common.h
     src/liblzma/check/crc_x86_clmul.h
-    src/liblzma/check/crc32_aarch64.h
+    src/liblzma/check/crc32_arm64.h
     src/liblzma/common/block_util.c
     src/liblzma/common/common.c
     src/liblzma/common/common.h
     src/liblzma/common/easy_preset.c
     src/liblzma/common/easy_preset.h
     src/liblzma/common/filter_common.c
     src/liblzma/common/filter_common.h
     src/liblzma/common/hardware_physmem.c
     src/liblzma/common/index.c
     src/liblzma/common/index.h
     src/liblzma/common/memcmplen.h
     src/liblzma/common/stream_flags_common.c
     src/liblzma/common/stream_flags_common.h
     src/liblzma/common/string_conversion.c
     src/liblzma/common/vli_size.c
 )
 
 target_include_directories(liblzma PRIVATE
     src/liblzma/api
     src/liblzma/common
     src/liblzma/check
     src/liblzma/lz
     src/liblzma/rangecoder
     src/liblzma/lzma
     src/liblzma/delta
     src/liblzma/simple
     src/common
 )
 
 
 ######################
 # Size optimizations #
 ######################
 
 option(ENABLE_SMALL "Reduce code size at expense of speed. \
 This may be useful together with CMAKE_BUILD_TYPE=MinSizeRel.")
 
 if(ENABLE_SMALL)
     add_compile_definitions(HAVE_SMALL)
 endif()
 
 
 ##########
 # Checks #
 ##########
 
 set(ADDITIONAL_SUPPORTED_CHECKS crc64 sha256)
 
 set(ADDITIONAL_CHECK_TYPES "${ADDITIONAL_SUPPORTED_CHECKS}" CACHE STRING
     "Additional check types to support (crc32 is always built)")
 
 foreach(CHECK IN LISTS ADDITIONAL_CHECK_TYPES)
     if(NOT CHECK IN_LIST ADDITIONAL_SUPPORTED_CHECKS)
         message(FATAL_ERROR "'${CHECK}' is not a supported check type")
     endif()
 endforeach()
 
 if(ENABLE_SMALL)
     target_sources(liblzma PRIVATE src/liblzma/check/crc32_small.c)
 else()
     target_sources(liblzma PRIVATE
         src/liblzma/check/crc32_fast.c
         src/liblzma/check/crc32_table.c
         src/liblzma/check/crc32_table_be.h
         src/liblzma/check/crc32_table_le.h
     )
 endif()
 
 if("crc64" IN_LIST ADDITIONAL_CHECK_TYPES)
     add_compile_definitions("HAVE_CHECK_CRC64")
 
     if(ENABLE_SMALL)
         target_sources(liblzma PRIVATE src/liblzma/check/crc64_small.c)
     else()
         target_sources(liblzma PRIVATE
             src/liblzma/check/crc64_fast.c
             src/liblzma/check/crc64_table.c
             src/liblzma/check/crc64_table_be.h
             src/liblzma/check/crc64_table_le.h
         )
     endif()
 endif()
 
 if("sha256" IN_LIST ADDITIONAL_CHECK_TYPES)
     add_compile_definitions("HAVE_CHECK_SHA256")
     target_sources(liblzma PRIVATE src/liblzma/check/sha256.c)
 endif()
 
 
 #################
 # Match finders #
 #################
 
 set(SUPPORTED_MATCH_FINDERS hc3 hc4 bt2 bt3 bt4)
 
 set(MATCH_FINDERS "${SUPPORTED_MATCH_FINDERS}" CACHE STRING
     "Match finders to support (at least one is required for LZMA1 or LZMA2)")
 
 foreach(MF IN LISTS MATCH_FINDERS)
     if(MF IN_LIST SUPPORTED_MATCH_FINDERS)
         string(TOUPPER "${MF}" MF_UPPER)
         add_compile_definitions("HAVE_MF_${MF_UPPER}")
     else()
         message(FATAL_ERROR "'${MF}' is not a supported match finder")
     endif()
 endforeach()
 
 
 #############
 # Threading #
 #############
 
 # Supported threading methods:
 # ON    - autodetect the best threading method. The autodetection will
 #         prefer Windows threading (win95 or vista) over posix if both are
 #         available. vista threads will be used over win95 unless it is a
 #         32-bit build.
 # OFF   - Disable threading.
 # posix - Use posix threading (pthreads), or throw an error if not available.
 # win95 - Use Windows win95 threading, or throw an error if not available.
 # vista - Use Windows vista threading, or throw an error if not available.
 set(SUPPORTED_THREADING_METHODS ON OFF posix win95 vista)
 
 set(ENABLE_THREADS ON CACHE STRING
     "Threading method: Set to 'ON' to autodetect, 'OFF' to disable threading.")
 
 # Create dropdown in CMake GUI since only 1 threading method is possible
 # to select in a build.
 set_property(CACHE ENABLE_THREADS
              PROPERTY STRINGS "${SUPPORTED_THREADING_METHODS}")
 
 # This is a flag variable set when win95 threads are used. We must ensure
 # the combination of enable_small and win95 threads is not used without a
 # compiler supporting attribute __constructor__.
 set(USE_WIN95_THREADS OFF)
 
 # This is a flag variable set when posix threads (pthreads) are used.
 # It's needed when creating liblzma-config.cmake where dependency on
 # Threads::Threads is only needed with pthreads.
 set(USE_POSIX_THREADS OFF)
 
 if(NOT ENABLE_THREADS IN_LIST SUPPORTED_THREADING_METHODS)
     message(FATAL_ERROR "'${ENABLE_THREADS}' is not a supported "
                         "threading method")
 endif()
 
 if(ENABLE_THREADS)
     # Also set THREADS_PREFER_PTHREAD_FLAG since the flag has no effect
     # for Windows threading.
     set(THREADS_PREFER_PTHREAD_FLAG TRUE)
     find_package(Threads REQUIRED)
 
     # If both Windows and posix threading are available, prefer Windows.
     # Note that on Cygwin CMAKE_USE_WIN32_THREADS_INIT is false.
     if(CMAKE_USE_WIN32_THREADS_INIT AND NOT ENABLE_THREADS STREQUAL "posix")
         if(ENABLE_THREADS STREQUAL "win95"
                 OR (ENABLE_THREADS STREQUAL "ON"
                     AND CMAKE_SIZEOF_VOID_P EQUAL 4))
             # Use Windows 95 (and thus XP) compatible threads.
             # This avoids use of features that were added in
             # Windows Vista. This is used for 32-bit x86 builds for
             # compatibility reasons since it makes no measurable difference
             # in performance compared to Vista threads.
             set(USE_WIN95_THREADS ON)
             add_compile_definitions(MYTHREAD_WIN95)
         else()
             add_compile_definitions(MYTHREAD_VISTA)
         endif()
     elseif(CMAKE_USE_PTHREADS_INIT)
         if(ENABLE_THREADS STREQUAL "posix" OR ENABLE_THREADS STREQUAL "ON")
             # The threading library only needs to be explicitly linked
             # for posix threads, so this is needed for creating
             # liblzma-config.cmake later.
             set(USE_POSIX_THREADS ON)
 
             target_link_libraries(liblzma Threads::Threads)
             add_compile_definitions(MYTHREAD_POSIX)
 
             # Check if pthread_condattr_setclock() exists to
             # use CLOCK_MONOTONIC.
             if(HAVE_CLOCK_MONOTONIC)
                 list(INSERT CMAKE_REQUIRED_LIBRARIES 0
                      "${CMAKE_THREAD_LIBS_INIT}")
                 check_symbol_exists(pthread_condattr_setclock pthread.h
                                     HAVE_PTHREAD_CONDATTR_SETCLOCK)
                 tuklib_add_definition_if(ALL HAVE_PTHREAD_CONDATTR_SETCLOCK)
             endif()
         else()
             message(SEND_ERROR
                     "Windows threading method was requested but a compatible "
                     "library could not be found")
         endif()
     else()
         message(SEND_ERROR "No supported threading library found")
     endif()
 
     target_sources(liblzma PRIVATE
         src/common/tuklib_cpucores.c
         src/common/tuklib_cpucores.h
         src/liblzma/common/hardware_cputhreads.c
         src/liblzma/common/outqueue.c
         src/liblzma/common/outqueue.h
     )
 endif()
 
 
 ############
 # Encoders #
 ############
 
 set(SIMPLE_FILTERS
     x86
     arm
     armthumb
     arm64
     powerpc
     ia64
     sparc
     riscv
 )
 
 # The SUPPORTED_FILTERS are shared between Encoders and Decoders
 # since only lzip does not appear in both lists. lzip is a special
 # case anyway, so it is handled separately in the Decoders section.
 set(SUPPORTED_FILTERS
     lzma1
     lzma2
     delta
     "${SIMPLE_FILTERS}"
 )
 
 set(ENCODERS "${SUPPORTED_FILTERS}" CACHE STRING "Encoders to support")
 
 # If LZMA2 is enabled, then LZMA1 must also be enabled.
 if(NOT "lzma1" IN_LIST ENCODERS AND "lzma2" IN_LIST ENCODERS)
     message(FATAL_ERROR "LZMA2 encoder requires that LZMA1 is also enabled")
 endif()
 
 # If LZMA1 is enabled, then at least one match finder must be enabled.
 if(MATCH_FINDERS STREQUAL "" AND "lzma1" IN_LIST ENCODERS)
     message(FATAL_ERROR "At least 1 match finder is required for an "
                         "LZ-based encoder")
 endif()
 
 set(HAVE_DELTA_CODER OFF)
 set(SIMPLE_ENCODERS OFF)
 set(HAVE_ENCODERS OFF)
 
 foreach(ENCODER IN LISTS ENCODERS)
     if(ENCODER IN_LIST SUPPORTED_FILTERS)
         set(HAVE_ENCODERS ON)
 
         if(NOT SIMPLE_ENCODERS AND ENCODER IN_LIST SIMPLE_FILTERS)
             set(SIMPLE_ENCODERS ON)
         endif()
 
         string(TOUPPER "${ENCODER}" ENCODER_UPPER)
         add_compile_definitions("HAVE_ENCODER_${ENCODER_UPPER}")
     else()
         message(FATAL_ERROR "'${ENCODER}' is not a supported encoder")
     endif()
 endforeach()
 
 if(HAVE_ENCODERS)
     add_compile_definitions(HAVE_ENCODERS)
 
     target_sources(liblzma PRIVATE
         src/liblzma/common/alone_encoder.c
         src/liblzma/common/block_buffer_encoder.c
         src/liblzma/common/block_buffer_encoder.h
         src/liblzma/common/block_encoder.c
         src/liblzma/common/block_encoder.h
         src/liblzma/common/block_header_encoder.c
         src/liblzma/common/easy_buffer_encoder.c
         src/liblzma/common/easy_encoder.c
         src/liblzma/common/easy_encoder_memusage.c
         src/liblzma/common/filter_buffer_encoder.c
         src/liblzma/common/filter_encoder.c
         src/liblzma/common/filter_encoder.h
         src/liblzma/common/filter_flags_encoder.c
         src/liblzma/common/index_encoder.c
         src/liblzma/common/index_encoder.h
         src/liblzma/common/stream_buffer_encoder.c
         src/liblzma/common/stream_encoder.c
         src/liblzma/common/stream_flags_encoder.c
         src/liblzma/common/vli_encoder.c
     )
 
     if(ENABLE_THREADS)
         target_sources(liblzma PRIVATE
             src/liblzma/common/stream_encoder_mt.c
         )
     endif()
 
     if(SIMPLE_ENCODERS)
         target_sources(liblzma PRIVATE
             src/liblzma/simple/simple_encoder.c
             src/liblzma/simple/simple_encoder.h
         )
     endif()
 
     if("lzma1" IN_LIST ENCODERS)
         target_sources(liblzma PRIVATE
             src/liblzma/lzma/lzma_encoder.c
             src/liblzma/lzma/lzma_encoder.h
             src/liblzma/lzma/lzma_encoder_optimum_fast.c
             src/liblzma/lzma/lzma_encoder_optimum_normal.c
             src/liblzma/lzma/lzma_encoder_private.h
             src/liblzma/lzma/fastpos.h
             src/liblzma/lz/lz_encoder.c
             src/liblzma/lz/lz_encoder.h
             src/liblzma/lz/lz_encoder_hash.h
             src/liblzma/lz/lz_encoder_hash_table.h
             src/liblzma/lz/lz_encoder_mf.c
             src/liblzma/rangecoder/price.h
             src/liblzma/rangecoder/price_table.c
             src/liblzma/rangecoder/range_encoder.h
         )
 
         if(NOT ENABLE_SMALL)
             target_sources(liblzma PRIVATE src/liblzma/lzma/fastpos_table.c)
         endif()
     endif()
 
     if("lzma2" IN_LIST ENCODERS)
         target_sources(liblzma PRIVATE
             src/liblzma/lzma/lzma2_encoder.c
             src/liblzma/lzma/lzma2_encoder.h
         )
     endif()
 
     if("delta" IN_LIST ENCODERS)
         set(HAVE_DELTA_CODER ON)
         target_sources(liblzma PRIVATE
             src/liblzma/delta/delta_encoder.c
             src/liblzma/delta/delta_encoder.h
         )
     endif()
 endif()
 
 
 ############
 # Decoders #
 ############
 
 set(DECODERS "${SUPPORTED_FILTERS}" CACHE STRING "Decoders to support")
 
 set(SIMPLE_DECODERS OFF)
 set(HAVE_DECODERS OFF)
 
 foreach(DECODER IN LISTS DECODERS)
     if(DECODER IN_LIST SUPPORTED_FILTERS)
         set(HAVE_DECODERS ON)
 
         if(NOT SIMPLE_DECODERS AND DECODER IN_LIST SIMPLE_FILTERS)
             set(SIMPLE_DECODERS ON)
         endif()
 
         string(TOUPPER "${DECODER}" DECODER_UPPER)
         add_compile_definitions("HAVE_DECODER_${DECODER_UPPER}")
     else()
         message(FATAL_ERROR "'${DECODER}' is not a supported decoder")
     endif()
 endforeach()
 
 if(HAVE_DECODERS)
     add_compile_definitions(HAVE_DECODERS)
 
     target_sources(liblzma PRIVATE
         src/liblzma/common/alone_decoder.c
         src/liblzma/common/alone_decoder.h
         src/liblzma/common/auto_decoder.c
         src/liblzma/common/block_buffer_decoder.c
         src/liblzma/common/block_decoder.c
         src/liblzma/common/block_decoder.h
         src/liblzma/common/block_header_decoder.c
         src/liblzma/common/easy_decoder_memusage.c
         src/liblzma/common/file_info.c
         src/liblzma/common/filter_buffer_decoder.c
         src/liblzma/common/filter_decoder.c
         src/liblzma/common/filter_decoder.h
         src/liblzma/common/filter_flags_decoder.c
         src/liblzma/common/index_decoder.c
         src/liblzma/common/index_decoder.h
         src/liblzma/common/index_hash.c
         src/liblzma/common/stream_buffer_decoder.c
         src/liblzma/common/stream_decoder.c
         src/liblzma/common/stream_flags_decoder.c
         src/liblzma/common/stream_decoder.h
         src/liblzma/common/vli_decoder.c
     )
 
     if(ENABLE_THREADS)
         target_sources(liblzma PRIVATE
             src/liblzma/common/stream_decoder_mt.c
         )
     endif()
 
     if(SIMPLE_DECODERS)
         target_sources(liblzma PRIVATE
             src/liblzma/simple/simple_decoder.c
             src/liblzma/simple/simple_decoder.h
         )
     endif()
 
     if("lzma1" IN_LIST DECODERS)
         target_sources(liblzma PRIVATE
             src/liblzma/lzma/lzma_decoder.c
             src/liblzma/lzma/lzma_decoder.h
             src/liblzma/rangecoder/range_decoder.h
             src/liblzma/lz/lz_decoder.c
             src/liblzma/lz/lz_decoder.h
         )
     endif()
 
     if("lzma2" IN_LIST DECODERS)
         target_sources(liblzma PRIVATE
             src/liblzma/lzma/lzma2_decoder.c
             src/liblzma/lzma/lzma2_decoder.h
         )
     endif()
 
     if("delta" IN_LIST DECODERS)
         set(HAVE_DELTA_CODER ON)
         target_sources(liblzma PRIVATE
             src/liblzma/delta/delta_decoder.c
             src/liblzma/delta/delta_decoder.h
         )
     endif()
 endif()
 
 # Some sources must appear if the filter is configured as either
 # an encoder or decoder.
 if("lzma1" IN_LIST ENCODERS OR "lzma1" IN_LIST DECODERS)
     target_sources(liblzma PRIVATE
         src/liblzma/rangecoder/range_common.h
         src/liblzma/lzma/lzma_encoder_presets.c
         src/liblzma/lzma/lzma_common.h
     )
 endif()
 
 if(HAVE_DELTA_CODER)
     target_sources(liblzma PRIVATE
         src/liblzma/delta/delta_common.c
         src/liblzma/delta/delta_common.h
         src/liblzma/delta/delta_private.h
     )
 endif()
 
 if(SIMPLE_ENCODERS OR SIMPLE_DECODERS)
     target_sources(liblzma PRIVATE
         src/liblzma/simple/simple_coder.c
         src/liblzma/simple/simple_coder.h
         src/liblzma/simple/simple_private.h
     )
 endif()
 
 foreach(SIMPLE_CODER IN LISTS SIMPLE_FILTERS)
     if(SIMPLE_CODER IN_LIST ENCODERS OR SIMPLE_CODER IN_LIST DECODERS)
         target_sources(liblzma PRIVATE "src/liblzma/simple/${SIMPLE_CODER}.c")
     endif()
 endforeach()
 
 
 #############
 # MicroLZMA #
 #############
 
 option(MICROLZMA_ENCODER
        "MicroLZMA encoder (needed by specific applications only)" ON)
 
 option(MICROLZMA_DECODER
        "MicroLZMA decoder (needed by specific applications only)" ON)
 
 if(MICROLZMA_ENCODER)
     if(NOT "lzma1" IN_LIST ENCODERS)
         message(FATAL_ERROR "The LZMA1 encoder is required to support the "
                             "MicroLZMA encoder")
     endif()
 
     target_sources(liblzma PRIVATE src/liblzma/common/microlzma_encoder.c)
 endif()
 
 if(MICROLZMA_DECODER)
     if(NOT "lzma1" IN_LIST DECODERS)
         message(FATAL_ERROR "The LZMA1 decoder is required to support the "
                             "MicroLZMA decoder")
     endif()
 
     target_sources(liblzma PRIVATE src/liblzma/common/microlzma_decoder.c)
 endif()
 
 
 #############################
 # lzip (.lz) format support #
 #############################
 
 option(LZIP_DECODER "Support lzip decoder" ON)
 
 if(LZIP_DECODER)
     # If lzip decoder support is requested, make sure LZMA1 decoder is enabled.
     if(NOT "lzma1" IN_LIST DECODERS)
         message(FATAL_ERROR "The LZMA1 decoder is required to support the "
                             "lzip decoder")
     endif()
 
     add_compile_definitions(HAVE_LZIP_DECODER)
 
     target_sources(liblzma PRIVATE
         src/liblzma/common/lzip_decoder.c
         src/liblzma/common/lzip_decoder.h
     )
 endif()
 
 
 ##############
 # Sandboxing #
 ##############
 
 # ON        Use sandboxing if a supported method is available in the OS.
 # OFF       Disable sandboxing.
 # capsicum  Require Capsicum (FreeBSD >= 10.2) and fail if not found.
 # pledge    Require pledge(2) (OpenBSD >= 5.9) and fail if not found.
 # landlock  Require Landlock (Linux >= 5.13) and fail if not found.
 set(SUPPORTED_SANDBOX_METHODS ON OFF capsicum pledge landlock)
 
 set(ENABLE_SANDBOX ON CACHE STRING
     "Sandboxing method to use in 'xz' and 'xzdec'")
 
 set_property(CACHE ENABLE_SANDBOX
                 PROPERTY STRINGS "${SUPPORTED_SANDBOX_METHODS}")
 
 if(NOT ENABLE_SANDBOX IN_LIST SUPPORTED_SANDBOX_METHODS)
     message(FATAL_ERROR "'${ENABLE_SANDBOX}' is not a supported "
                         "sandboxing method")
 endif()
 
 # When autodetecting, the search order is fixed and we must not find
 # more than one method.
 if(ENABLE_SANDBOX STREQUAL "OFF")
     set(SANDBOX_FOUND ON)
 else()
     set(SANDBOX_FOUND OFF)
 endif()
 
 # Since xz and xzdec can both use sandboxing, the compile definition needed
 # to use the sandbox must be added to both targets.
 set(SANDBOX_COMPILE_DEFINITION OFF)
 
 # Sandboxing: Capsicum
 if(NOT SANDBOX_FOUND AND ENABLE_SANDBOX MATCHES "^ON$|^capsicum$")
     check_symbol_exists(cap_rights_limit sys/capsicum.h
                         HAVE_CAP_RIGHTS_LIMIT)
     if(HAVE_CAP_RIGHTS_LIMIT)
         set(SANDBOX_COMPILE_DEFINITION "HAVE_CAP_RIGHTS_LIMIT")
         set(SANDBOX_FOUND ON)
     endif()
 endif()
 
 # Sandboxing: pledge(2)
 if(NOT SANDBOX_FOUND AND ENABLE_SANDBOX MATCHES "^ON$|^pledge$")
     check_symbol_exists(pledge unistd.h HAVE_PLEDGE)
     if(HAVE_PLEDGE)
         set(SANDBOX_COMPILE_DEFINITION "HAVE_PLEDGE")
         set(SANDBOX_FOUND ON)
     endif()
 endif()
 
 # Sandboxing: Landlock
 if(NOT SANDBOX_FOUND AND ENABLE_SANDBOX MATCHES "^ON$|^landlock$")
     check_include_file(linux/landlock.h HAVE_LINUX_LANDLOCK_H)
 
     if(HAVE_LINUX_LANDLOCK_H)
         set(SANDBOX_COMPILE_DEFINITION "HAVE_LINUX_LANDLOCK_H")
         set(SANDBOX_FOUND ON)
 
         # Of our three sandbox methods, only Landlock is incompatible
         # with -fsanitize. FreeBSD 13.2 with Capsicum was tested with
         # -fsanitize=address,undefined and had no issues. OpenBSD (as
         # of version 7.4) has minimal support for process instrumentation.
         # OpenBSD does not distribute the additional libraries needed
         # (libasan, libubsan, etc.) with GCC or Clang needed for runtime
         # sanitization support and instead only support
         # -fsanitize-minimal-runtime for minimal undefined behavior
         # sanitization. This minimal support is compatible with our use
         # of the Pledge sandbox. So only Landlock will result in a
         # build that cannot compress or decompress a single file to
         # standard out.
         if(CMAKE_C_FLAGS MATCHES "-fsanitize=")
             message(SEND_ERROR
                     "CMAKE_C_FLAGS or the environment variable CFLAGS "
                     "contains '-fsanitize=' which is incompatible "
                     "with Landlock sandboxing. Use -DENABLE_SANDBOX=OFF "
                     "as an argument to 'cmake' when using '-fsanitize'.")
         endif()
     endif()
 endif()
 
 if(NOT SANDBOX_FOUND AND NOT ENABLE_SANDBOX MATCHES "^ON$|^OFF$")
     message(SEND_ERROR "ENABLE_SANDBOX=${ENABLE_SANDBOX} was used but "
                         "support for the sandboxing method wasn't found.")
 endif()
 
 ###
 
 # Put the tuklib functions under the lzma_ namespace.
 target_compile_definitions(liblzma PRIVATE TUKLIB_SYMBOL_PREFIX=lzma_)
 tuklib_cpucores(liblzma)
 tuklib_physmem(liblzma)
 
 # While liblzma can be built without tuklib_cpucores or tuklib_physmem
 # modules, the liblzma API functions lzma_cputhreads() and lzma_physmem()
 # will then be useless (which isn't too bad but still unfortunate). Since
 # I expect the CMake-based builds to be only used on systems that are
 # supported by these tuklib modules, problems with these tuklib modules
 # are considered a hard error for now. This hopefully helps to catch bugs
 # in the CMake versions of the tuklib checks.
 if(NOT TUKLIB_CPUCORES_FOUND OR NOT TUKLIB_PHYSMEM_FOUND)
     # Use SEND_ERROR instead of FATAL_ERROR. If someone reports a bug,
     # seeing the results of the remaining checks can be useful too.
     message(SEND_ERROR
             "tuklib_cpucores() or tuklib_physmem() failed. "
             "Unless you really are building for a system where these "
             "modules are not supported (unlikely), this is a bug in the "
             "included cmake/tuklib_*.cmake files that should be fixed. "
             "To build anyway, edit this CMakeLists.txt to ignore this error.")
 endif()
 
 # Check for __attribute__((__constructor__)) support.
 # This needs -Werror because some compilers just warn
 # about this being unsupported.
 cmake_push_check_state()
 set(CMAKE_REQUIRED_FLAGS "-Werror")
 check_c_source_compiles("
         __attribute__((__constructor__))
         static void my_constructor_func(void) { return; }
         int main(void) { return 0; }
     "
     HAVE_FUNC_ATTRIBUTE_CONSTRUCTOR)
 cmake_pop_check_state()
 tuklib_add_definition_if(liblzma HAVE_FUNC_ATTRIBUTE_CONSTRUCTOR)
 
 # The Win95 threading lacks a thread-safe one-time initialization function.
 # The one-time initialization is needed for crc32_small.c and crc64_small.c
 # create the CRC tables. So if small mode is enabled, the threading mode is
 # win95, and the compiler does not support attribute constructor, then we
 # would end up with a multithreaded build that is thread-unsafe. As a
 # result this configuration is not allowed.
 if(USE_WIN95_THREADS AND ENABLE_SMALL AND NOT HAVE_FUNC_ATTRIBUTE_CONSTRUCTOR)
     message(SEND_ERROR "Threading method win95 and ENABLE_SMALL "
                         "cannot be used at the same time with a compiler "
                         "that doesn't support "
                         "__attribute__((__constructor__))")
 endif()
 
 
 # Check for __attribute__((__ifunc__())) support.
 # Supported values for USE_ATTR_IFUNC:
 #
 # auto (default) - Detect ifunc support with a compile test.
 # ON             - Always enable ifunc.
 # OFF            - Disable ifunc usage.
 set(USE_ATTR_IFUNC "auto" CACHE STRING "Use __attribute__((__ifunc__())).")
 
 set(SUPPORTED_USE_ATTR_IFUNC auto ON OFF)
 
 if(NOT USE_ATTR_IFUNC IN_LIST SUPPORTED_USE_ATTR_IFUNC)
     message(FATAL_ERROR "'${USE_ATTR_IFUNC}' is not a supported value for"
                         "USE_ATTR_IFUNC")
 endif()
 
 # When USE_ATTR_IFUNC is 'auto', allow the use of __attribute__((__ifunc__()))
 # if compiler support is detected and we are building for GNU/Linux (glibc)
 # or FreeBSD. uClibc and musl don't support ifunc in their dynamic linkers
 # but some compilers still accept the attribute when compiling for these
 # C libraries, which results in broken binaries. That's why we need to
 # check which libc is being used.
 if(USE_ATTR_IFUNC STREQUAL "auto")
     cmake_push_check_state()
     set(CMAKE_REQUIRED_FLAGS "-Werror")
 
     check_c_source_compiles("
             /*
              * Force a compilation error when not using glibc on Linux
              * or if we are not using FreeBSD. uClibc will define
              * __GLIBC__ but does not support ifunc, so we must have
              * an extra check to disable with uClibc.
              */
             #if defined(__linux__)
             #   include <features.h>
             #   if !defined(__GLIBC__) || defined(__UCLIBC__)
             compile error
             #   endif
             #elif !defined(__FreeBSD__)
             compile error
             #endif
 
             static void func(void) { return; }
             static void (*resolve_func(void)) (void) { return func; }
             void func_ifunc(void)
                     __attribute__((__ifunc__(\"resolve_func\")));
             int main(void) { return 0; }
             /*
              * 'clang -Wall' incorrectly warns that resolve_func is
              * unused (-Wunused-function). Correct assembly output is
              * still produced. This problem exists at least in Clang
              * versions 4 to 17. The following silences the bogus warning:
              */
             void make_clang_quiet(void);
             void make_clang_quiet(void) { resolve_func()(); }
         "
         SYSTEM_SUPPORTS_IFUNC)
 
         cmake_pop_check_state()
 endif()
 
 if(USE_ATTR_IFUNC STREQUAL "ON" OR SYSTEM_SUPPORTS_IFUNC)
     tuklib_add_definitions(liblzma HAVE_FUNC_ATTRIBUTE_IFUNC)
 
     if(CMAKE_C_FLAGS MATCHES "-fsanitize=")
         message(SEND_ERROR
                 "CMAKE_C_FLAGS or the environment variable CFLAGS "
                 "contains '-fsanitize=' which is incompatible "
                 "with ifunc. Use -DUSE_ATTR_IFUNC=OFF "
                 "as an argument to 'cmake' when using '-fsanitize'.")
     endif()
 endif()
 
 # cpuid.h
 check_include_file(cpuid.h HAVE_CPUID_H)
 tuklib_add_definition_if(liblzma HAVE_CPUID_H)
 
 # immintrin.h:
 check_include_file(immintrin.h HAVE_IMMINTRIN_H)
 if(HAVE_IMMINTRIN_H)
     target_compile_definitions(liblzma PRIVATE HAVE_IMMINTRIN_H)
 
     # SSE2 intrinsics:
     check_c_source_compiles("
             #include <immintrin.h>
             int main(void)
             {
                 __m128i x = { 0 };
                 _mm_movemask_epi8(x);
                 return 0;
             }
         "
         HAVE__MM_MOVEMASK_EPI8)
     tuklib_add_definition_if(liblzma HAVE__MM_MOVEMASK_EPI8)
 
     # CLMUL intrinsic:
     option(ALLOW_CLMUL_CRC "Allow carryless multiplication for CRC \
 calculation if supported by the system" ON)
 
     if(ALLOW_CLMUL_CRC)
         check_c_source_compiles("
                 #include <immintrin.h>
                 #if defined(__e2k__) && __iset__ < 6
                 #   error
                 #endif
                 #if (defined(__GNUC__) || defined(__clang__)) \
                         && !defined(__EDG__)
                 __attribute__((__target__(\"ssse3,sse4.1,pclmul\")))
                 #endif
                 __m128i my_clmul(__m128i a)
                 {
                     const __m128i b = _mm_set_epi64x(1, 2);
                     return _mm_clmulepi64_si128(a, b, 0);
                 }
                 int main(void) { return 0; }
             "
             HAVE_USABLE_CLMUL)
         tuklib_add_definition_if(liblzma HAVE_USABLE_CLMUL)
     endif()
 endif()
 
 # ARM64 C Language Extensions define CRC32 functions in arm_acle.h.
 # These are supported by at least GCC and Clang which both need
 # __attribute__((__target__("+crc"))), unless the needed compiler flags
 # are used to support the CRC instruction.
 option(ALLOW_ARM64_CRC32 "Allow ARM64 CRC32 instruction if supported by \
 the system" ON)
 
 if(ALLOW_ARM64_CRC32)
     check_c_source_compiles("
             #include <stdint.h>
 
             #ifndef _MSC_VER
             #include <arm_acle.h>
             #endif
 
             #if (defined(__GNUC__) || defined(__clang__)) && !defined(__EDG__)
             __attribute__((__target__(\"+crc\")))
             #endif
             uint32_t my_crc(uint32_t a, uint64_t b)
             {
                 return __crc32d(a, b);
             }
             int main(void) { return 0; }
         "
         HAVE_ARM64_CRC32)
 
     if(HAVE_ARM64_CRC32)
         target_compile_definitions(liblzma PRIVATE HAVE_ARM64_CRC32)
 
         # Check for ARM64 CRC32 instruction runtime detection.
         # getauxval() is supported on Linux.
         check_symbol_exists(getauxval sys/auxv.h HAVE_GETAUXVAL)
         tuklib_add_definition_if(liblzma HAVE_GETAUXVAL)
 
         # elf_aux_info() is supported on FreeBSD.
         check_symbol_exists(elf_aux_info sys/auxv.h HAVE_ELF_AUX_INFO)
         tuklib_add_definition_if(liblzma HAVE_ELF_AUX_INFO)
 
         # sysctlbyname("hw.optional.armv8_crc32", ...) is supported on Darwin
         # (macOS, iOS, etc.). Note that sysctlbyname() is supported on FreeBSD,
         # NetBSD, and possibly others too but the string is specific to
         # Apple OSes. The C code is responsible for checking
         # defined(__APPLE__) before using
         # sysctlbyname("hw.optional.armv8_crc32", ...).
         check_symbol_exists(sysctlbyname sys/sysctl.h HAVE_SYSCTLBYNAME)
         tuklib_add_definition_if(liblzma HAVE_SYSCTLBYNAME)
     endif()
 endif()
 
 
 # Support -fvisiblity=hidden when building shared liblzma.
 # These lines do nothing on Windows (even under Cygwin).
 # HAVE_VISIBILITY should always be defined to 0 or 1.
 if(BUILD_SHARED_LIBS)
     set_target_properties(liblzma PROPERTIES C_VISIBILITY_PRESET hidden)
     target_compile_definitions(liblzma PRIVATE HAVE_VISIBILITY=1)
 else()
     target_compile_definitions(liblzma PRIVATE HAVE_VISIBILITY=0)
 endif()
 
 if(WIN32)
     if(BUILD_SHARED_LIBS)
         # Add the Windows resource file for liblzma.dll.
         target_sources(liblzma PRIVATE src/liblzma/liblzma_w32res.rc)
 
         set_target_properties(liblzma PROPERTIES
             LINK_DEPENDS "${CMAKE_CURRENT_SOURCE_DIR}/src/common/common_w32res.rc"
         )
 
         # Export the public API symbols with __declspec(dllexport).
         target_compile_definitions(liblzma PRIVATE DLL_EXPORT)
 
         if(NOT MSVC)
             # Create a DEF file. The linker puts the ordinal numbers there
             # too so the output from the linker isn't our final file.
             target_link_options(liblzma PRIVATE
                                 "-Wl,--output-def,liblzma.def.in")
 
             # Remove the ordinal numbers from the DEF file so that
             # no one will create an import library that links by ordinal
             # instead of by name. We don't maintain a DEF file so the
             # ordinal numbers aren't stable.
             add_custom_command(TARGET liblzma POST_BUILD
                 COMMAND "${CMAKE_COMMAND}"
                     -DINPUT_FILE=liblzma.def.in
                     -DOUTPUT_FILE=liblzma.def
                     -P
                     "${CMAKE_CURRENT_SOURCE_DIR}/cmake/remove-ordinals.cmake"
                 BYPRODUCTS "liblzma.def"
                 VERBATIM)
         endif()
     else()
         # Disable __declspec(dllimport) when linking against static liblzma.
         target_compile_definitions(liblzma INTERFACE LZMA_API_STATIC)
     endif()
 elseif(BUILD_SHARED_LIBS AND CMAKE_SYSTEM_NAME STREQUAL "Linux")
     # GNU/Linux-specific symbol versioning for shared liblzma.
     # Note that adding link options doesn't affect static builds
     # but HAVE_SYMBOL_VERSIONS_LINUX must not be used with static builds
     # because it would put symbol versions into the static library which
     # can cause problems. It's clearer if all symver related things are
     # omitted when not building a shared library.
     #
     # NOTE: Set it explicitly to 1 to make it clear that versioning is
     # done unconditionally in the C files.
     target_compile_definitions(liblzma PRIVATE HAVE_SYMBOL_VERSIONS_LINUX=1)
     target_link_options(liblzma PRIVATE
         "-Wl,--version-script=${CMAKE_CURRENT_SOURCE_DIR}/src/liblzma/liblzma_linux.map"
     )
     set_target_properties(liblzma PROPERTIES
         LINK_DEPENDS "${CMAKE_CURRENT_SOURCE_DIR}/src/liblzma/liblzma_linux.map"
     )
 elseif(BUILD_SHARED_LIBS AND CMAKE_SYSTEM_NAME STREQUAL "FreeBSD")
     # Symbol versioning for shared liblzma for non-GNU/Linux.
     # FIXME? What about Solaris?
     target_link_options(liblzma PRIVATE
         "-Wl,--version-script=${CMAKE_CURRENT_SOURCE_DIR}/src/liblzma/liblzma_generic.map"
     )
     set_target_properties(liblzma PROPERTIES
         LINK_DEPENDS "${CMAKE_CURRENT_SOURCE_DIR}/src/liblzma/liblzma_generic.map"
     )
 endif()
 
 set_target_properties(liblzma PROPERTIES
     # At least for now the package versioning matches the rules used for
     # shared library versioning (excluding development releases) so it is
     # fine to use the package version here.
     SOVERSION "${xz_VERSION_MAJOR}"
     VERSION "${xz_VERSION}"
 
     # It's liblzma.so or liblzma.dll, not libliblzma.so or lzma.dll.
     # Avoid the name lzma.dll because it would conflict with LZMA SDK.
     PREFIX ""
     IMPORT_PREFIX ""
 )
 
 # Create liblzma-config-version.cmake.
 #
 # FIXME: SameMajorVersion is correct for stable releases but it is wrong
 # for development releases where each release may have incompatible changes.
 include(CMakePackageConfigHelpers)
 write_basic_package_version_file(
     "${CMAKE_CURRENT_BINARY_DIR}/liblzma-config-version.cmake"
     VERSION "${liblzma_VERSION}"
     COMPATIBILITY SameMajorVersion)
 
 # Create liblzma-config.cmake. We use this spelling instead of
 # liblzmaConfig.cmake to make find_package work in case insensitive
 # manner even with case sensitive file systems. This gives more consistent
 # behavior between operating systems. This optionally includes a dependency
 # on a threading library, so the contents are created in two separate parts.
 # The "second half" is always needed, so create it first.
 set(LZMA_CONFIG_CONTENTS
 "include(\"\${CMAKE_CURRENT_LIST_DIR}/liblzma-targets.cmake\")
 
 if(NOT TARGET LibLZMA::LibLZMA)
     # Be compatible with the spelling used by the FindLibLZMA module. This
     # doesn't use ALIAS because it would make CMake resolve LibLZMA::LibLZMA
     # to liblzma::liblzma instead of keeping the original spelling. Keeping
     # the original spelling is important for good FindLibLZMA compatibility.
     add_library(LibLZMA::LibLZMA INTERFACE IMPORTED)
     set_target_properties(LibLZMA::LibLZMA PROPERTIES
                           INTERFACE_LINK_LIBRARIES liblzma::liblzma)
 endif()
 ")
 
 if(USE_POSIX_THREADS)
     set(LZMA_CONFIG_CONTENTS
 "include(CMakeFindDependencyMacro)
 set(THREADS_PREFER_PTHREAD_FLAG TRUE)
 find_dependency(Threads)
 
 ${LZMA_CONFIG_CONTENTS}
 ")
 endif()
 
 file(WRITE "${CMAKE_CURRENT_BINARY_DIR}/liblzma-config.cmake"
         "${LZMA_CONFIG_CONTENTS}")
 
 # Set CMAKE_INSTALL_LIBDIR and friends.
 include(GNUInstallDirs)
 
 # Create liblzma.pc.
 set(prefix "${CMAKE_INSTALL_PREFIX}")
 set(exec_prefix "${CMAKE_INSTALL_PREFIX}")
 set(libdir "${CMAKE_INSTALL_FULL_LIBDIR}")
 set(includedir "${CMAKE_INSTALL_FULL_INCLUDEDIR}")
 set(PTHREAD_CFLAGS "${CMAKE_THREAD_LIBS_INIT}")
 configure_file(src/liblzma/liblzma.pc.in liblzma.pc
                @ONLY
                NEWLINE_STYLE LF)
 
 # Install the library binary. The INCLUDES specifies the include path that
 # is exported for other projects to use but it doesn't install any files.
 install(TARGETS liblzma EXPORT liblzmaTargets
         RUNTIME  DESTINATION "${CMAKE_INSTALL_BINDIR}"
                  COMPONENT liblzma_Runtime
         LIBRARY  DESTINATION "${CMAKE_INSTALL_LIBDIR}"
                  COMPONENT liblzma_Runtime
                  NAMELINK_COMPONENT liblzma_Development
         ARCHIVE  DESTINATION "${CMAKE_INSTALL_LIBDIR}"
                  COMPONENT liblzma_Development
         INCLUDES DESTINATION "${CMAKE_INSTALL_INCLUDEDIR}")
 
 # Install the liblzma API headers. These use a subdirectory so
 # this has to be done as a separate step.
 install(DIRECTORY src/liblzma/api/
         COMPONENT liblzma_Development
         DESTINATION "${CMAKE_INSTALL_INCLUDEDIR}"
         FILES_MATCHING PATTERN "*.h")
 
 # Install the CMake files that other packages can use to find liblzma.
 set(liblzma_INSTALL_CMAKEDIR
     "${CMAKE_INSTALL_LIBDIR}/cmake/liblzma"
     CACHE STRING "Path to liblzma's .cmake files")
 
 install(EXPORT liblzmaTargets
         NAMESPACE liblzma::
         FILE liblzma-targets.cmake
         DESTINATION "${liblzma_INSTALL_CMAKEDIR}"
         COMPONENT liblzma_Development)
 
 install(FILES "${CMAKE_CURRENT_BINARY_DIR}/liblzma-config.cmake"
               "${CMAKE_CURRENT_BINARY_DIR}/liblzma-config-version.cmake"
         DESTINATION "${liblzma_INSTALL_CMAKEDIR}"
         COMPONENT liblzma_Development)
 
 if(NOT MSVC)
     install(FILES "${CMAKE_CURRENT_BINARY_DIR}/liblzma.pc"
             DESTINATION "${CMAKE_INSTALL_LIBDIR}/pkgconfig"
             COMPONENT liblzma_Development)
 endif()
 
 
 #############################################################################
 # libgnu (getopt_long)
 #############################################################################
 
 # This mirrors how the Autotools build system handles the getopt_long
 # replacement, calling the object library libgnu since the replacement
 # version comes from Gnulib.
 add_library(libgnu OBJECT)
 
 # CMake requires that even an object library must have at least once source
 # file. So we give it a header file that results in no output files.
 target_sources(libgnu PRIVATE lib/getopt.in.h)
 
 # The Ninja Generator requires setting the linker language since it cannot
 # guess the programming language of just a header file. Setting this
 # property avoids needing an empty .c file or an non-empty unnecessary .c
 # file.
 set_target_properties(libgnu PROPERTIES LINKER_LANGUAGE C)
 
 # Create /lib directory in the build directory and add it to the include path.
 file(MAKE_DIRECTORY "${CMAKE_CURRENT_BINARY_DIR}/lib")
 target_include_directories(libgnu PUBLIC "${CMAKE_CURRENT_BINARY_DIR}/lib")
 
 # Include /lib from the source directory. It does no harm even if none of
 # the Gnulib replacements are used.
 target_include_directories(libgnu PUBLIC lib)
 
 # The command line tools need getopt_long in order to parse arguments. If
 # the system does not have a getopt_long implementation we can use the one
 # from Gnulib instead.
 check_symbol_exists(getopt_long getopt.h HAVE_GETOPT_LONG)
 
 if(NOT HAVE_GETOPT_LONG)
     # Set the __GETOPT_PREFIX definition to "rpl_" (replacement) to avoid
     # name conflicts with libc symbols. The same prefix is set if using
     # the Autotools build (m4/getopt.m4).
     target_compile_definitions(libgnu PUBLIC "__GETOPT_PREFIX=rpl_")
 
     # Create a custom copy command to copy the getopt header to the build
     # directory and re-copy it if it is updated. (Gnulib does it this way
     # because it allows choosing which .in.h files to actually use in the
     # build. We need just getopt.h so this is a bit overcomplicated for
     # a single header file only.)
     add_custom_command(OUTPUT "${CMAKE_CURRENT_BINARY_DIR}/lib/getopt.h"
         COMMAND "${CMAKE_COMMAND}" -E copy
             "${CMAKE_CURRENT_SOURCE_DIR}/lib/getopt.in.h"
             "${CMAKE_CURRENT_BINARY_DIR}/lib/getopt.h"
         MAIN_DEPENDENCY "${CMAKE_CURRENT_SOURCE_DIR}/lib/getopt.in.h"
         VERBATIM)
 
     target_sources(libgnu PRIVATE
         lib/getopt1.c
         lib/getopt.c
         lib/getopt_int.h
         lib/getopt-cdefs.h
         lib/getopt-core.h
         lib/getopt-ext.h
         lib/getopt-pfx-core.h
         lib/getopt-pfx-ext.h
         "${CMAKE_CURRENT_BINARY_DIR}/lib/getopt.h"
     )
 endif()
 
 
 #############################################################################
 # xzdec
 #############################################################################
 
 if(HAVE_DECODERS AND (NOT MSVC OR MSVC_VERSION GREATER_EQUAL 1900))
     add_executable(xzdec
         src/common/sysdefs.h
         src/common/tuklib_common.h
         src/common/tuklib_config.h
         src/common/tuklib_exit.c
         src/common/tuklib_exit.h
         src/common/tuklib_gettext.h
         src/common/tuklib_progname.c
         src/common/tuklib_progname.h
         src/xzdec/xzdec.c
     )
 
     target_include_directories(xzdec PRIVATE
         src/common
         src/liblzma/api
     )
 
     target_link_libraries(xzdec PRIVATE liblzma libgnu)
 
     if(WIN32)
         # Add the Windows resource file for xzdec.exe.
         target_sources(xzdec PRIVATE src/xzdec/xzdec_w32res.rc)
         set_target_properties(xzdec PROPERTIES
             LINK_DEPENDS "${CMAKE_CURRENT_SOURCE_DIR}/src/common/common_w32res.rc"
         )
     endif()
 
     if(SANDBOX_COMPILE_DEFINITION)
         target_compile_definitions(xzdec PRIVATE
                                    "${SANDBOX_COMPILE_DEFINITION}")
     endif()
 
     tuklib_progname(xzdec)
 
     install(TARGETS xzdec
             RUNTIME DESTINATION "${CMAKE_INSTALL_BINDIR}"
                     COMPONENT xzdec)
 
     if(UNIX)
         install(FILES src/xzdec/xzdec.1
                 DESTINATION "${CMAKE_INSTALL_MANDIR}/man1"
                 COMPONENT xzdec)
     endif()
 endif()
 
 
 #############################################################################
 # xz
 #############################################################################
 
 if(NOT MSVC OR MSVC_VERSION GREATER_EQUAL 1900)
     add_executable(xz
         src/common/mythread.h
         src/common/sysdefs.h
         src/common/tuklib_common.h
         src/common/tuklib_config.h
         src/common/tuklib_exit.c
         src/common/tuklib_exit.h
         src/common/tuklib_gettext.h
         src/common/tuklib_integer.h
         src/common/tuklib_mbstr.h
         src/common/tuklib_mbstr_fw.c
         src/common/tuklib_mbstr_width.c
         src/common/tuklib_open_stdxxx.c
         src/common/tuklib_open_stdxxx.h
         src/common/tuklib_progname.c
         src/common/tuklib_progname.h
         src/xz/args.c
         src/xz/args.h
         src/xz/coder.c
         src/xz/coder.h
         src/xz/file_io.c
         src/xz/file_io.h
         src/xz/hardware.c
         src/xz/hardware.h
         src/xz/main.c
         src/xz/main.h
         src/xz/message.c
         src/xz/message.h
         src/xz/mytime.c
         src/xz/mytime.h
         src/xz/options.c
         src/xz/options.h
         src/xz/private.h
         src/xz/signals.c
         src/xz/signals.h
         src/xz/suffix.c
         src/xz/suffix.h
         src/xz/util.c
         src/xz/util.h
     )
 
     target_include_directories(xz PRIVATE
         src/common
         src/liblzma/api
     )
 
     if(HAVE_DECODERS)
         target_sources(xz PRIVATE
             src/xz/list.c
             src/xz/list.h
         )
     endif()
 
     target_link_libraries(xz PRIVATE liblzma libgnu)
 
     target_compile_definitions(xz PRIVATE ASSUME_RAM=128)
 
     if(WIN32)
         # Add the Windows resource file for xz.exe.
         target_sources(xz PRIVATE src/xz/xz_w32res.rc)
         set_target_properties(xz PROPERTIES
             LINK_DEPENDS "${CMAKE_CURRENT_SOURCE_DIR}/src/common/common_w32res.rc"
         )
     endif()
 
     if(SANDBOX_COMPILE_DEFINITION)
         target_compile_definitions(xz PRIVATE "${SANDBOX_COMPILE_DEFINITION}")
     endif()
 
     tuklib_progname(xz)
     tuklib_mbstr(xz)
 
     check_symbol_exists(optreset getopt.h HAVE_OPTRESET)
     tuklib_add_definition_if(xz HAVE_OPTRESET)
 
     check_symbol_exists(posix_fadvise fcntl.h HAVE_POSIX_FADVISE)
     tuklib_add_definition_if(xz HAVE_POSIX_FADVISE)
 
     # How to get file time:
     check_struct_has_member("struct stat" st_atim.tv_nsec
                             "sys/types.h;sys/stat.h"
                             HAVE_STRUCT_STAT_ST_ATIM_TV_NSEC)
     if(HAVE_STRUCT_STAT_ST_ATIM_TV_NSEC)
         tuklib_add_definitions(xz HAVE_STRUCT_STAT_ST_ATIM_TV_NSEC)
     else()
         check_struct_has_member("struct stat" st_atimespec.tv_nsec
                                 "sys/types.h;sys/stat.h"
                                 HAVE_STRUCT_STAT_ST_ATIMESPEC_TV_NSEC)
         if(HAVE_STRUCT_STAT_ST_ATIMESPEC_TV_NSEC)
             tuklib_add_definitions(xz HAVE_STRUCT_STAT_ST_ATIMESPEC_TV_NSEC)
         else()
             check_struct_has_member("struct stat" st_atimensec
                                     "sys/types.h;sys/stat.h"
                                     HAVE_STRUCT_STAT_ST_ATIMENSEC)
             tuklib_add_definition_if(xz HAVE_STRUCT_STAT_ST_ATIMENSEC)
         endif()
     endif()
 
     # How to set file time:
     check_symbol_exists(futimens "sys/types.h;sys/stat.h" HAVE_FUTIMENS)
     if(HAVE_FUTIMENS)
         tuklib_add_definitions(xz HAVE_FUTIMENS)
     else()
         check_symbol_exists(futimes "sys/time.h" HAVE_FUTIMES)
         if(HAVE_FUTIMES)
             tuklib_add_definitions(xz HAVE_FUTIMES)
         else()
             check_symbol_exists(futimesat "sys/time.h" HAVE_FUTIMESAT)
             if(HAVE_FUTIMESAT)
                 tuklib_add_definitions(xz HAVE_FUTIMESAT)
             else()
                 check_symbol_exists(utimes "sys/time.h" HAVE_UTIMES)
                 if(HAVE_UTIMES)
                     tuklib_add_definitions(xz HAVE_UTIMES)
                 else()
                     check_symbol_exists(_futime "sys/utime.h" HAVE__FUTIME)
                     if(HAVE__FUTIME)
                         tuklib_add_definitions(xz HAVE__FUTIME)
                     else()
                         check_symbol_exists(utime "utime.h" HAVE_UTIME)
                         tuklib_add_definition_if(xz HAVE_UTIME)
                     endif()
                 endif()
             endif()
         endif()
     endif()
 
     install(TARGETS xz
             RUNTIME DESTINATION "${CMAKE_INSTALL_BINDIR}"
                     COMPONENT xz)
 
     if(UNIX)
         install(FILES src/xz/xz.1
                 DESTINATION "${CMAKE_INSTALL_MANDIR}/man1"
                 COMPONENT xz)
 
         option(CREATE_XZ_SYMLINKS "Create unxz and xzcat symlinks" ON)
         option(CREATE_LZMA_SYMLINKS "Create lzma, unlzma, and lzcat symlinks"
                ON)
         set(XZ_LINKS)
 
         if(CREATE_XZ_SYMLINKS)
             list(APPEND XZ_LINKS "unxz" "xzcat")
         endif()
 
         if(CREATE_LZMA_SYMLINKS)
             list(APPEND XZ_LINKS "lzma" "unlzma" "lzcat")
         endif()
 
         # With Windows Cygwin and MSYS2 the symlinking is complicated. Both
         # of these environments set the UNIX variable so they will try to
         # make the symlinks. The ability for Cygwin and MSYS2 to make
         # broken symlinks is determined by the CYGWIN and MSYS2 environment
         # variables, respectively. Broken symlinks are needed for the man
         # page symlinks and for determining if the xz and lzma symlinks need
         # to depend on the xz target or not. If broken symlinks cannot be
         # made then the xz binary must be created before the symlinks.
         set(ALLOW_BROKEN_SYMLINKS ON)
 
         if(CMAKE_SYSTEM_NAME STREQUAL "CYGWIN")
             # The Cygwin env variable can be set to four possible values:
             #
             # 1. "lnk". Create symlinks as Windows shortcuts.
             #
             # 2. "native". Create symlinks as native Windows symlinks
             #    if supported by the system. Fallback to "lnk" if native
             #    symlinks are not supported.
             #
             # 3. "nativestrict". Create symlinks as native Windows symlinks
             #    if supported by the system. If the target of the symlink
             #    does not exist or the creation of the symlink fails for any
             #    reason, do not create the symlink.
             #
             # 4. "sys". Create symlinks as plain files with a special
             #    system attribute containing the path to the symlink target.
             #
             # So, the only case we care about for broken symlinks is
             # "nativestrict" since all other values mean that broken
             # symlinks are allowed. If the env variable is not set the
             # default is "native". If the env variable is set but not
             # assigned one of the four values, then the default is the same
             # as option 1 "lnk".
             string(FIND "$ENV{CYGWIN}" "winsymlinks:nativestrict" SYMLINK_POS)
             if(SYMLINK_POS GREATER -1)
                 set(ALLOW_BROKEN_SYMLINKS OFF)
             endif()
         elseif(CMAKE_SYSTEM_NAME STREQUAL "MSYS")
             # The MSYS env variable behaves similar to the CYGWIN but has a
             # different default behavior. If winsymlinks is set but not
             # assigned one of the four supported values, the default is to
             # *copy* the target to the symlink destination. This will fail
             # if the target does not exist so broken symlinks cannot be
             # allowed.
             string(FIND "$ENV{MSYS}" "winsymlinks" SYMLINK_POS)
             if(SYMLINK_POS GREATER -1)
                 string(FIND "$ENV{MSYS}" "winsymlinks:nativestrict"
                         SYMLINK_POS)
                 if(SYMLINK_POS GREATER -1)
                     set(ALLOW_BROKEN_SYMLINKS OFF)
                 endif()
             else()
                 set(ALLOW_BROKEN_SYMLINKS OFF)
             endif()
         endif()
 
         # Create symlinks in the build directory and then install them.
         #
         # The symlinks do not likely need any special extension since
         # even on Windows the symlink can still be executed without
         # the .exe extension.
         foreach(LINK IN LISTS XZ_LINKS)
             add_custom_target("create_${LINK}" ALL
                 "${CMAKE_COMMAND}" -E create_symlink
                     "$<TARGET_FILE_NAME:xz>" "${LINK}"
                 BYPRODUCTS "${LINK}"
                 VERBATIM)
             install(FILES "${CMAKE_CURRENT_BINARY_DIR}/${LINK}"
                     DESTINATION "${CMAKE_INSTALL_BINDIR}"
                     COMPONENT xz)
 
             # Only create the man page symlinks if the symlinks can be
             # created broken. The symlinks will not be valid until install
             # so they cannot be created on these system environments.
             if(ALLOW_BROKEN_SYMLINKS)
                 add_custom_target("create_${LINK}.1" ALL
                     "${CMAKE_COMMAND}" -E create_symlink "xz.1" "${LINK}.1"
                     BYPRODUCTS "${LINK}.1"
                     VERBATIM)
                 install(FILES "${CMAKE_CURRENT_BINARY_DIR}/${LINK}.1"
                         DESTINATION "${CMAKE_INSTALL_MANDIR}/man1"
                         COMPONENT xz)
             else()
                 # Add the xz target as dependency when broken symlinks
                 # cannot be made. This ensures parallel builds do not fail
                 # since it will enforce the order of creating xz first, then
                 # the symlinks.
                 add_dependencies("create_${LINK}" xz)
             endif()
         endforeach()
     endif()
 endif()
 
 
 #############################################################################
 # Tests
 #############################################################################
 
 include(CTest)
 
 if(BUILD_TESTING)
     set(LIBLZMA_TESTS
         test_bcj_exact_size
         test_block_header
         test_check
         test_filter_flags
         test_filter_str
         test_hardware
         test_index
         test_index_hash
         test_lzip_decoder
         test_memlimit
         test_stream_flags
         test_vli
     )
 
     foreach(TEST IN LISTS LIBLZMA_TESTS)
         add_executable("${TEST}" "tests/${TEST}.c")
 
         target_include_directories("${TEST}" PRIVATE
             src/common
             src/liblzma/api
             src/liblzma
         )
 
         target_link_libraries("${TEST}" PRIVATE liblzma)
 
         # Put the test programs into their own subdirectory so they don't
         # pollute the top-level dir which might contain xz and xzdec.
         set_target_properties("${TEST}" PROPERTIES
             RUNTIME_OUTPUT_DIRECTORY "${CMAKE_CURRENT_BINARY_DIR}/tests_bin"
         )
 
         add_test(NAME "${TEST}"
                  COMMAND "${CMAKE_CURRENT_BINARY_DIR}/tests_bin/${TEST}"
         )
 
         # Set srcdir environment variable so that the tests find their
         # input files from the source tree.
         #
         # Set the return code for skipped tests to match Automake convention.
         set_tests_properties("${TEST}" PROPERTIES
             ENVIRONMENT "srcdir=${CMAKE_CURRENT_SOURCE_DIR}/tests"
             SKIP_RETURN_CODE 77
         )
     endforeach()
 endif()
diff --git a/src/liblzma/check/Makefile.inc b/src/liblzma/check/Makefile.inc
index e7f87c85..da7ee0db 100644
--- a/src/liblzma/check/Makefile.inc
+++ b/src/liblzma/check/Makefile.inc
@@ -1,55 +1,55 @@
 ##
 ## Author: Lasse Collin
 ##
 ## This file has been put into the public domain.
 ## You can do whatever you want with this file.
 ##
 ## Note: There is no check for COND_CHECK_CRC32 because
 ## currently crc32 is always enabled.
 
 EXTRA_DIST += \
 	check/crc32_tablegen.c \
 	check/crc64_tablegen.c
 
 liblzma_la_SOURCES += \
 	check/check.c \
 	check/check.h \
 	check/crc_common.h \
 	check/crc_x86_clmul.h \
-	check/crc32_aarch64.h
+	check/crc32_arm64.h
 
 if COND_SMALL
 liblzma_la_SOURCES += check/crc32_small.c
 else
 liblzma_la_SOURCES += \
 	check/crc32_table.c \
 	check/crc32_table_le.h \
 	check/crc32_table_be.h
 if COND_ASM_X86
 liblzma_la_SOURCES += check/crc32_x86.S
 else
 liblzma_la_SOURCES += check/crc32_fast.c
 endif
 endif
 
 if COND_CHECK_CRC64
 if COND_SMALL
 liblzma_la_SOURCES += check/crc64_small.c
 else
 liblzma_la_SOURCES += \
 	check/crc64_table.c \
 	check/crc64_table_le.h \
 	check/crc64_table_be.h
 if COND_ASM_X86
 liblzma_la_SOURCES += check/crc64_x86.S
 else
 liblzma_la_SOURCES += check/crc64_fast.c
 endif
 endif
 endif
 
 if COND_CHECK_SHA256
 if COND_INTERNAL_SHA256
 liblzma_la_SOURCES += check/sha256.c
 endif
 endif
diff --git a/src/liblzma/check/crc32_aarch64.h b/src/liblzma/check/crc32_aarch64.h
deleted file mode 100644
index 77b14af4..00000000
--- a/src/liblzma/check/crc32_aarch64.h
+++ /dev/null
@@ -1,109 +0,0 @@
-///////////////////////////////////////////////////////////////////////////////
-//
-/// \file       crc32_aarch64.c
-/// \brief      CRC32 calculation with aarch64 optimization
-//
-//  Authors:    Chenxi Mao
-//
-//  This file has been put into the public domain.
-//  You can do whatever you want with this file.
-//
-///////////////////////////////////////////////////////////////////////////////
-#ifdef LZMA_CRC_CRC32_AARCH64_H
-#	error crc_arm64_clmul.h was included twice.
-#endif
-#define LZMA_CRC_CRC32_AARCH64_H
-#include <sys/auxv.h>
-// EDG-based compilers (Intel's classic compiler and compiler for E2K) can
-// define __GNUC__ but the attribute must not be used with them.
-// The new Clang-based ICX needs the attribute.
-//
-// NOTE: Build systems check for this too, keep them in sync with this.
-#if (defined(__GNUC__) || defined(__clang__)) && !defined(__EDG__)
-#	define crc_attr_target \
-        __attribute__((__target__("+crc")))
-#else
-#	define crc_attr_target
-#endif
-#ifdef BUILDING_CRC32_AARCH64
-crc_attr_target
-crc_attr_no_sanitize_address
-static uint32_t
-crc32_arch_optimized(const uint8_t *buf, size_t size, uint32_t crc)
-{
-	crc = ~crc;
-	while ((uintptr_t)(buf) & 7) {
-		crc = __builtin_aarch64_crc32b(crc, *buf);
-		buf++;
-		size--;
-	}
-	for (;size>=8;size-=8,buf+=8) {
-		crc = __builtin_aarch64_crc32x(crc, aligned_read64le(buf));
-	}
-	for (;size>0;size--,buf++)
-		crc = __builtin_aarch64_crc32b(crc, *buf);
-	return ~crc;
-}
-#endif
-#ifdef BUILDING_CRC64_AARCH64
-//FIXME: there is no crc64_arch_optimized implementation,
-// to make compiler happy, add crc64_generic here.
-#ifdef WORDS_BIGENDIAN
-#	define A1(x) ((x) >> 56)
-#else
-#	define A1 A
-#endif
-crc_attr_target
-crc_attr_no_sanitize_address
-static uint64_t
-crc64_arch_optimized(const uint8_t *buf, size_t size, uint64_t crc)
-{
-	crc = ~crc;
-
-#ifdef WORDS_BIGENDIAN
-	crc = bswap64(crc);
-#endif
-
-	if (size > 4) {
-		while ((uintptr_t)(buf) & 3) {
-			crc = lzma_crc64_table[0][*buf++ ^ A1(crc)] ^ S8(crc);
-			--size;
-		}
-
-		const uint8_t *const limit = buf + (size & ~(size_t)(3));
-		size &= (size_t)(3);
-
-		while (buf < limit) {
-#ifdef WORDS_BIGENDIAN
-			const uint32_t tmp = (uint32_t)(crc >> 32)
-					^ aligned_read32ne(buf);
-#else
-			const uint32_t tmp = (uint32_t)crc
-					^ aligned_read32ne(buf);
-#endif
-			buf += 4;
-
-			crc = lzma_crc64_table[3][A(tmp)]
-			    ^ lzma_crc64_table[2][B(tmp)]
-			    ^ S32(crc)
-			    ^ lzma_crc64_table[1][C(tmp)]
-			    ^ lzma_crc64_table[0][D(tmp)];
-		}
-	}
-
-	while (size-- != 0)
-		crc = lzma_crc64_table[0][*buf++ ^ A1(crc)] ^ S8(crc);
-
-#ifdef WORDS_BIGENDIAN
-	crc = bswap64(crc);
-#endif
-
-	return ~crc;
-}
-#endif
-static inline bool
-is_arch_extension_supported(void)
-{
-	return (getauxval(AT_HWCAP) & HWCAP_CRC32)!=0;
-}
-
diff --git a/src/liblzma/check/crc32_arm64.h b/src/liblzma/check/crc32_arm64.h
new file mode 100644
index 00000000..a1888ea7
--- /dev/null
+++ b/src/liblzma/check/crc32_arm64.h
@@ -0,0 +1,119 @@
+///////////////////////////////////////////////////////////////////////////////
+//
+/// \file       crc32_arm64.h
+/// \brief      CRC32 calculation with ARM64 optimization
+//
+//  Authors:    Chenxi Mao
+//              Jia Tan
+//
+//  This file has been put into the public domain.
+//  You can do whatever you want with this file.
+//
+///////////////////////////////////////////////////////////////////////////////
+
+
+#ifndef LZMA_CRC32_ARM64_H
+#define LZMA_CRC32_ARM64_H
+
+// MSVC always has the CRC intrinsics available when building for ARM64
+// there is no need to include any header files.
+#ifndef _MSC_VER
+#	include <arm_acle.h>
+#endif
+
+#if defined(CRC32_GENERIC) && defined(CRC32_ARCH_OPTIMIZED)
+#	if defined(HAVE_GETAUXVAL) || defined(HAVE_ELF_AUX_INFO)
+#		include <sys/auxv.h>
+#	elif defined(_WIN32)
+#		include <processthreadsapi.h>
+#	elif defined(__APPLE__) && defined(HAVE_SYSCTLBYNAME)
+#		include <sys/sysctl.h>
+#	endif
+#endif
+
+// Some EDG-based compilers support ARM64 and define __GNUC__
+// (such as Nvidia's nvcc), but do not support function attributes.
+//
+// NOTE: Build systems check for this too, keep them in sync with this.
+#if (defined(__GNUC__) || defined(__clang__)) && !defined(__EDG__)
+#	define crc_attr_target \
+        __attribute__((__target__("+crc")))
+#else
+#	define crc_attr_target
+#endif
+
+
+crc_attr_target
+static uint32_t
+crc32_arch_optimized(const uint8_t *buf, size_t size, uint32_t crc)
+{
+	crc = ~crc;
+
+	// Align the input buffer because this was shown to be
+	// significantly faster than unaligned accesses.
+	const size_t align_amount = my_min(size, (8 - (uintptr_t)buf) & 7);
+
+	for (const uint8_t *limit = buf + align_amount; buf < limit; ++buf)
+		crc = __crc32b(crc, *buf);
+
+	size -= align_amount;
+
+	// Process 8 bytes at a time. The end point is determined by
+	// ignoring the least significant three bits of size to ensure
+	// we do not process past the bounds of the buffer. This guarentees
+	// that limit is a multiple of 8 and is strictly less than size.
+	for (const uint8_t *limit = buf + (size & ~((size_t)7));
+			buf < limit; buf += 8)
+		crc = __crc32d(crc, aligned_read64le(buf));
+
+	// Process the remaining bytes that are not 8 byte aligned.
+	for (const uint8_t *limit = buf + (size & 7); buf < limit; ++buf)
+		crc = __crc32b(crc, *buf);
+
+	return ~crc;
+}
+
+
+#if defined(CRC32_GENERIC) && defined(CRC32_ARCH_OPTIMIZED)
+static inline bool
+is_arch_extension_supported(void)
+{
+#if defined(HAVE_GETAUXVAL)
+	return (getauxval(AT_HWCAP) & HWCAP_CRC32) != 0;
+
+#elif defined(HAVE_ELF_AUX_INFO)
+	unsigned long feature_flags;
+
+	elf_aux_info(AT_HWCAP, &feature_flags, sizeof(feature_flags));
+	return feature_flags & HWCAP_CRC32 != 0;
+
+#elif defined(_WIN32)
+	return IsProcessorFeaturePresent(
+			PF_ARM_V8_CRC32_INSTRUCTIONS_AVAILABLE);
+
+#elif defined(__APPLE__) && defined(HAVE_SYSCTLBYNAME)
+	int has_crc32 = 0;
+	size_t size = sizeof(has_crc32);
+
+	// The sysctlbyname() function requires a string identifier for the
+	// CPU feature it tests. The Apple documentation lists the string
+	// "hw.optional.armv8_crc32", which can be found here:
+	// (https://developer.apple.com/documentation/kernel/1387446-sysctlbyname/determining_instruction_set_characteristics#3915619)
+	int err = sysctlbyname("hw.optional.armv8_crc32", &has_crc32,
+			&size, NULL, 0);
+
+	return !err && has_crc32;
+
+#else
+	// If a runtime detection method cannot be found, then this must
+	// be a compile time error. The checks in crc_common.h should ensure
+	// a runtime detection method is always found if this function is
+	// built. It would be possible to just return false here, but this
+	// is inefficient for binary size and runtime since only the generic
+	// method could ever be used.
+#	error Runtime detection method unavailable.
+#endif
+}
+#endif
+
+#endif // LZMA_CRC32_ARM64_H
diff --git a/src/liblzma/check/crc32_fast.c b/src/liblzma/check/crc32_fast.c
index be034bdc..0b667d8b 100644
--- a/src/liblzma/check/crc32_fast.c
+++ b/src/liblzma/check/crc32_fast.c
@@ -1,239 +1,238 @@
 ///////////////////////////////////////////////////////////////////////////////
 //
 /// \file       crc32.c
 /// \brief      CRC32 calculation
 //
 //  Authors:    Lasse Collin
 //              Ilya Kurdyukov
 //              Hans Jansen
 //
 //  This file has been put into the public domain.
 //  You can do whatever you want with this file.
 //
 ///////////////////////////////////////////////////////////////////////////////
 
 #include "check.h"
 #include "crc_common.h"
 
 #if defined(CRC_X86_CLMUL)
 #	define BUILDING_CRC32_CLMUL
 #	include "crc_x86_clmul.h"
 #elif defined(CRC32_ARM64)
-#	define BUILDING_CRC32_AARCH64
-#	include "crc32_aarch64.h"
+#	include "crc32_arm64.h"
 #endif
 
 
 #ifdef CRC32_GENERIC
 
 ///////////////////
 // Generic CRC32 //
 ///////////////////
 
 static uint32_t
 crc32_generic(const uint8_t *buf, size_t size, uint32_t crc)
 {
 	crc = ~crc;
 
 #ifdef WORDS_BIGENDIAN
 	crc = bswap32(crc);
 #endif
 
 	if (size > 8) {
 		// Fix the alignment, if needed. The if statement above
 		// ensures that this won't read past the end of buf[].
 		while ((uintptr_t)(buf) & 7) {
 			crc = lzma_crc32_table[0][*buf++ ^ A(crc)] ^ S8(crc);
 			--size;
 		}
 
 		// Calculate the position where to stop.
 		const uint8_t *const limit = buf + (size & ~(size_t)(7));
 
 		// Calculate how many bytes must be calculated separately
 		// before returning the result.
 		size &= (size_t)(7);
 
 		// Calculate the CRC32 using the slice-by-eight algorithm.
 		while (buf < limit) {
 			crc ^= aligned_read32ne(buf);
 			buf += 4;
 
 			crc = lzma_crc32_table[7][A(crc)]
 			    ^ lzma_crc32_table[6][B(crc)]
 			    ^ lzma_crc32_table[5][C(crc)]
 			    ^ lzma_crc32_table[4][D(crc)];
 
 			const uint32_t tmp = aligned_read32ne(buf);
 			buf += 4;
 
 			// At least with some compilers, it is critical for
 			// performance, that the crc variable is XORed
 			// between the two table-lookup pairs.
 			crc = lzma_crc32_table[3][A(tmp)]
 			    ^ lzma_crc32_table[2][B(tmp)]
 			    ^ crc
 			    ^ lzma_crc32_table[1][C(tmp)]
 			    ^ lzma_crc32_table[0][D(tmp)];
 		}
 	}
 
 	while (size-- != 0)
 		crc = lzma_crc32_table[0][*buf++ ^ A(crc)] ^ S8(crc);
 
 #ifdef WORDS_BIGENDIAN
 	crc = bswap32(crc);
 #endif
 
 	return ~crc;
 }
 #endif
 
 
 #if defined(CRC32_GENERIC) && defined(CRC32_ARCH_OPTIMIZED)
 
 //////////////////////////
 // Function dispatching //
 //////////////////////////
 
 // If both the generic and arch-optimized implementations are built, then
 // the function to use is selected at runtime because the system running
 // the binary might not have the arch-specific instruction set extension(s)
 // available. The three dispatch methods in order of priority:
 //
 // 1. Indirect function (ifunc). This method is slightly more efficient
 //    than the constructor method because it will change the entry in the
 //    Procedure Linkage Table (PLT) for the function either at load time or
 //    at the first call. This avoids having to call the function through a
 //    function pointer and will treat the function call like a regular call
 //    through the PLT. ifuncs are created by using
 //    __attribute__((__ifunc__("resolver"))) on a function which has no
 //    body. The "resolver" is the name of the function that chooses at
 //    runtime which implementation to use.
 //
 // 2. Constructor. This method uses __attribute__((__constructor__)) to
 //    set crc32_func at load time. This avoids extra computation (and any
 //    unlikely threading bugs) on the first call to lzma_crc32() to decide
 //    which implementation should be used.
 //
 // 3. First Call Resolution. On the very first call to lzma_crc32(), the
 //    call will be directed to crc32_dispatch() instead. This will set the
 //    appropriate implementation function and will not be called again.
 //    This method does not use any kind of locking but is safe because if
 //    multiple threads run the dispatcher simultaneously then they will all
 //    set crc32_func to the same value.
 
 typedef uint32_t (*crc32_func_type)(
 		const uint8_t *buf, size_t size, uint32_t crc);
 
 // Clang 16.0.0 and older has a bug where it marks the ifunc resolver
 // function as unused since it is static and never used outside of
 // __attribute__((__ifunc__())).
 #if defined(HAVE_FUNC_ATTRIBUTE_IFUNC) && defined(__clang__)
 #	pragma GCC diagnostic push
 #	pragma GCC diagnostic ignored "-Wunused-function"
 #endif
 
 // This resolver is shared between all three dispatch methods. It serves as
 // the ifunc resolver if ifunc is supported, otherwise it is called as a
 // regular function by the constructor or first call resolution methods.
 static crc32_func_type
 crc32_resolve(void)
 {
 	return is_arch_extension_supported()
 			? &crc32_arch_optimized : &crc32_generic;
 }
 
 #if defined(HAVE_FUNC_ATTRIBUTE_IFUNC) && defined(__clang__)
 #	pragma GCC diagnostic pop
 #endif
 
 #ifndef HAVE_FUNC_ATTRIBUTE_IFUNC
 
 #ifdef HAVE_FUNC_ATTRIBUTE_CONSTRUCTOR
 // Constructor method.
 #	define CRC32_SET_FUNC_ATTR __attribute__((__constructor__))
 static crc32_func_type crc32_func;
 #else
 // First Call Resolution method.
 #	define CRC32_SET_FUNC_ATTR
 static uint32_t crc32_dispatch(const uint8_t *buf, size_t size, uint32_t crc);
 static crc32_func_type crc32_func = &crc32_dispatch;
 #endif
 
 CRC32_SET_FUNC_ATTR
 static void
 crc32_set_func(void)
 {
 	crc32_func = crc32_resolve();
 	return;
 }
 
 #ifndef HAVE_FUNC_ATTRIBUTE_CONSTRUCTOR
 static uint32_t
 crc32_dispatch(const uint8_t *buf, size_t size, uint32_t crc)
 {
 	// When __attribute__((__ifunc__(...))) and
 	// __attribute__((__constructor__)) isn't supported, set the
 	// function pointer without any locking. If multiple threads run
 	// the detection code in parallel, they will all end up setting
 	// the pointer to the same value. This avoids the use of
 	// mythread_once() on every call to lzma_crc32() but this likely
 	// isn't strictly standards compliant. Let's change it if it breaks.
 	crc32_set_func();
 	return crc32_func(buf, size, crc);
 }
 
 #endif
 #endif
 #endif
 
 
 #ifdef CRC_USE_IFUNC
 extern LZMA_API(uint32_t)
 lzma_crc32(const uint8_t *buf, size_t size, uint32_t crc)
 		__attribute__((__ifunc__("crc32_resolve")));
 #else
 extern LZMA_API(uint32_t)
 lzma_crc32(const uint8_t *buf, size_t size, uint32_t crc)
 {
 #if defined(CRC32_GENERIC) && defined(CRC32_ARCH_OPTIMIZED)
 	// On x86-64, if CLMUL is available, it is the best for non-tiny
 	// inputs, being over twice as fast as the generic slice-by-four
 	// version. However, for size <= 16 it's different. In the extreme
 	// case of size == 1 the generic version can be five times faster.
 	// At size >= 8 the CLMUL starts to become reasonable. It
 	// varies depending on the alignment of buf too.
 	//
 	// The above doesn't include the overhead of mythread_once().
 	// At least on x86-64 GNU/Linux, pthread_once() is very fast but
 	// it still makes lzma_crc32(buf, 1, crc) 50-100 % slower. When
 	// size reaches 12-16 bytes the overhead becomes negligible.
 	//
 	// So using the generic version for size <= 16 may give better
 	// performance with tiny inputs but if such inputs happen rarely
 	// it's not so obvious because then the lookup table of the
 	// generic version may not be in the processor cache.
 #ifdef CRC_USE_GENERIC_FOR_SMALL_INPUTS
 	if (size <= 16)
 		return crc32_generic(buf, size, crc);
 #endif
 
 /*
 #ifndef HAVE_FUNC_ATTRIBUTE_CONSTRUCTOR
 	// See crc32_dispatch(). This would be the alternative which uses
 	// locking and doesn't use crc32_dispatch(). Note that on Windows
 	// this method needs Vista threads.
 	mythread_once(crc64_set_func);
 #endif
 */
 	return crc32_func(buf, size, crc);
 
 #elif defined(CRC32_ARCH_OPTIMIZED)
 	return crc32_arch_optimized(buf, size, crc);
 
 #else
 	return crc32_generic(buf, size, crc);
 #endif
 }
 #endif
diff --git a/src/liblzma/check/crc64_fast.c b/src/liblzma/check/crc64_fast.c
index 3d94ed3f..d1ab6862 100644
--- a/src/liblzma/check/crc64_fast.c
+++ b/src/liblzma/check/crc64_fast.c
@@ -1,178 +1,175 @@
 ///////////////////////////////////////////////////////////////////////////////
 //
 /// \file       crc64.c
 /// \brief      CRC64 calculation
 //
 //  Authors:    Lasse Collin
 //              Ilya Kurdyukov
 //
 //  This file has been put into the public domain.
 //  You can do whatever you want with this file.
 //
 ///////////////////////////////////////////////////////////////////////////////
 
 #include "check.h"
 #include "crc_common.h"
 
 #if defined(CRC_X86_CLMUL)
 #	define BUILDING_CRC64_CLMUL
 #	include "crc_x86_clmul.h"
-#elif defined(CRC32_ARM64)
-#	define BUILDING_CRC64_AARCH64
-#	include "crc32_aarch64.h"
 #endif
 
 
 #ifdef CRC64_GENERIC
 
 /////////////////////////////////
 // Generic slice-by-four CRC64 //
 /////////////////////////////////
 
 #ifdef WORDS_BIGENDIAN
 #	define A1(x) ((x) >> 56)
 #else
 #	define A1 A
 #endif
 
 
 // See the comments in crc32_fast.c. They aren't duplicated here.
 static uint64_t
 crc64_generic(const uint8_t *buf, size_t size, uint64_t crc)
 {
 	crc = ~crc;
 
 #ifdef WORDS_BIGENDIAN
 	crc = bswap64(crc);
 #endif
 
 	if (size > 4) {
 		while ((uintptr_t)(buf) & 3) {
 			crc = lzma_crc64_table[0][*buf++ ^ A1(crc)] ^ S8(crc);
 			--size;
 		}
 
 		const uint8_t *const limit = buf + (size & ~(size_t)(3));
 		size &= (size_t)(3);
 
 		while (buf < limit) {
 #ifdef WORDS_BIGENDIAN
 			const uint32_t tmp = (uint32_t)(crc >> 32)
 					^ aligned_read32ne(buf);
 #else
 			const uint32_t tmp = (uint32_t)crc
 					^ aligned_read32ne(buf);
 #endif
 			buf += 4;
 
 			crc = lzma_crc64_table[3][A(tmp)]
 			    ^ lzma_crc64_table[2][B(tmp)]
 			    ^ S32(crc)
 			    ^ lzma_crc64_table[1][C(tmp)]
 			    ^ lzma_crc64_table[0][D(tmp)];
 		}
 	}
 
 	while (size-- != 0)
 		crc = lzma_crc64_table[0][*buf++ ^ A1(crc)] ^ S8(crc);
 
 #ifdef WORDS_BIGENDIAN
 	crc = bswap64(crc);
 #endif
 
 	return ~crc;
 }
 #endif
 
 
 #if defined(CRC64_GENERIC) && defined(CRC64_ARCH_OPTIMIZED)
 
 //////////////////////////
 // Function dispatching //
 //////////////////////////
 
 // If both the generic and arch-optimized implementations are usable, then
 // the function that is used is selected at runtime. See crc32_fast.c.
 
 typedef uint64_t (*crc64_func_type)(
 		const uint8_t *buf, size_t size, uint64_t crc);
 
 #if defined(HAVE_FUNC_ATTRIBUTE_IFUNC) && defined(__clang__)
 #	pragma GCC diagnostic push
 #	pragma GCC diagnostic ignored "-Wunused-function"
 #endif
 
 static crc64_func_type
 crc64_resolve(void)
 {
 	return is_arch_extension_supported()
 			? &crc64_arch_optimized : &crc64_generic;
 }
 
 #if defined(HAVE_FUNC_ATTRIBUTE_IFUNC) && defined(__clang__)
 #	pragma GCC diagnostic pop
 #endif
 
 #ifndef HAVE_FUNC_ATTRIBUTE_IFUNC
 
 #ifdef HAVE_FUNC_ATTRIBUTE_CONSTRUCTOR
 #	define CRC64_SET_FUNC_ATTR __attribute__((__constructor__))
 static crc64_func_type crc64_func;
 #else
 #	define CRC64_SET_FUNC_ATTR
 static uint64_t crc64_dispatch(const uint8_t *buf, size_t size, uint64_t crc);
 static crc64_func_type crc64_func = &crc64_dispatch;
 #endif
 
 
 CRC64_SET_FUNC_ATTR
 static void
 crc64_set_func(void)
 {
 	crc64_func = crc64_resolve();
 	return;
 }
 
 
 #ifndef HAVE_FUNC_ATTRIBUTE_CONSTRUCTOR
 static uint64_t
 crc64_dispatch(const uint8_t *buf, size_t size, uint64_t crc)
 {
 	crc64_set_func();
 	return crc64_func(buf, size, crc);
 }
 #endif
 #endif
 #endif
 
 
 #ifdef CRC_USE_IFUNC
 extern LZMA_API(uint64_t)
 lzma_crc64(const uint8_t *buf, size_t size, uint64_t crc)
 		__attribute__((__ifunc__("crc64_resolve")));
 #else
 extern LZMA_API(uint64_t)
 lzma_crc64(const uint8_t *buf, size_t size, uint64_t crc)
 {
 #if defined(CRC64_GENERIC) && defined(CRC64_ARCH_OPTIMIZED)
 
 #ifdef CRC_USE_GENERIC_FOR_SMALL_INPUTS
 	if (size <= 16)
 		return crc64_generic(buf, size, crc);
 #endif
 	return crc64_func(buf, size, crc);
 
 #elif defined(CRC64_ARCH_OPTIMIZED)
 	// If arch-optimized version is used unconditionally without runtime
 	// CPU detection then omitting the generic version and its 8 KiB
 	// lookup table makes the library smaller.
 	//
 	// FIXME: Lookup table isn't currently omitted on 32-bit x86,
 	// see crc64_table.c.
 	return crc64_arch_optimized(buf, size, crc);
 
 #else
 	return crc64_generic(buf, size, crc);
 #endif
 }
 #endif