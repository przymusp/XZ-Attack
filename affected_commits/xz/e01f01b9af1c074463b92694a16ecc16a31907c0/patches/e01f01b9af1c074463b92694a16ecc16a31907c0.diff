commit e01f01b9af1c074463b92694a16ecc16a31907c0
Author: Jia Tan <jiat0218@gmail.com>
Date:   Fri Feb 3 00:32:47 2023 +0800

    Tests: Create test_filter_str.c.
    
    Tests lzma_str_to_filters(), lzma_str_from_filters(), and
    lzma_str_list_filters() API functions.

diff --git a/CMakeLists.txt b/CMakeLists.txt
index e5b4e5b5..cfa0dd6f 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -1,888 +1,889 @@
 #############################################################################
 #
 # Very limited CMake support for building some parts of XZ Utils
 #
 # For now, this is indented to be useful to build static or shared liblzma
 # on Windows with MSVC (to avoid the need to maintain Visual Studio project
 # files). Building liblzma on a few other platforms should work too but it
 # is somewhat experimental and not as portable as using ./configure.
 #
 # On some platforms this builds also xz and xzdec, but these are
 # highly experimental and meant for testing only:
 #   - No large file support on those 32-bit platforms that need it
 #   - No replacement getopt_long(), libc must have it
 #   - No sandboxing support
 #   - No translations
 #
 # Other missing things:
 #   - No xzgrep or other scripts or their symlinks
 #   - No xz tests (liblzma tests only)
 #
 # NOTE: Even if the code compiles without warnings, the end result may be
 # different than via ./configure. Specifically, the list of #defines
 # may be different (if so, probably this CMakeLists.txt got them wrong).
 #
 # This file provides the following installation components (if you only
 # need liblzma, install only its components!):
 #   - liblzma_Runtime
 #   - liblzma_Development
 #   - xz (on some platforms only)
 #   - xzdec (on some platforms only)
 #
 # To find the target liblzma::liblzma from other packages, use the CONFIG
 # option with find_package() to avoid a conflict with the FindLibLZMA module
 # with case-insensitive file systems. For example, to require liblzma 5.2.5
 # or a newer compatible version:
 #
 #     find_package(liblzma 5.2.5 REQUIRED CONFIG)
 #     target_link_libraries(my_application liblzma::liblzma)
 #
 #############################################################################
 #
 # Author: Lasse Collin
 #
 # This file has been put into the public domain.
 # You can do whatever you want with this file.
 #
 #############################################################################
 
 cmake_minimum_required(VERSION 3.13...3.25 FATAL_ERROR)
 
 include(CMakePushCheckState)
 include(CheckIncludeFile)
 include(CheckSymbolExists)
 include(CheckStructHasMember)
 include(CheckCSourceCompiles)
 include(cmake/tuklib_integer.cmake)
 include(cmake/tuklib_cpucores.cmake)
 include(cmake/tuklib_physmem.cmake)
 include(cmake/tuklib_progname.cmake)
 include(cmake/tuklib_mbstr.cmake)
 
 # Get the package version from version.h into XZ_VERSION variable.
 file(READ src/liblzma/api/lzma/version.h XZ_VERSION)
 string(REGEX REPLACE
 "^.*\n\
 #define LZMA_VERSION_MAJOR ([0-9]+)\n\
 #define LZMA_VERSION_MINOR ([0-9]+)\n\
 #define LZMA_VERSION_PATCH ([0-9]+)\n\
 .*$"
        "\\1.\\2.\\3" XZ_VERSION "${XZ_VERSION}")
 
 # Among other things, this gives us variables xz_VERSION and xz_VERSION_MAJOR.
 project(xz VERSION "${XZ_VERSION}" LANGUAGES C)
 
 # On Apple OSes, don't build executables as bundles:
 set(CMAKE_MACOSX_BUNDLE OFF)
 
 # windres from GNU binutils can be tricky with command line arguments
 # that contain spaces or other funny characters. Unfortunately we need
 # a space in PACKAGE_NAME. Using \x20 to encode the US-ASCII space seems
 # to work in both cmd.exe and /bin/sh.
 #
 # However, even \x20 isn't enough in all situations, resulting in
 # "syntax error" from windres. Using --use-temp-file prevents windres
 # from using popen() and this seems to fix the problem.
 #
 # llvm-windres claims to be compatible with GNU windres but with that
 # the \x20 results in "XZx20Utils" in the compiled binary. (At the
 # same time it works correctly with clang (the C compiler).) The option
 # --use-temp-file makes no difference.
 #
 # CMake 3.25 doesn't have CMAKE_RC_COMPILER_ID so we rely on
 # CMAKE_C_COMPILER_ID. If Clang is used together with GNU windres
 # then it will fail, but this way the risk of a bad string in
 # the binary should be fairly low.
 if(WIN32 AND CMAKE_C_COMPILER_ID STREQUAL "GNU")
     # Use workarounds with GNU windres. The \x20 in PACKAGE_NAME works
     # with gcc too so we don't need to worry how to pass different flags
     # to windres and gcc.
     string(APPEND CMAKE_RC_FLAGS " --use-temp-file")
     set(PACKAGE_NAME "XZ\\x20Utils")
 else()
     # Elsewhere a space is safe. This also keeps things compatible with
     # EBCDIC in case CMake-based build is ever done on such a system.
     set(PACKAGE_NAME "XZ Utils")
 endif()
 
 # Definitions common to all targets:
 add_compile_definitions(
     # Package info:
     PACKAGE_NAME="${PACKAGE_NAME}"
     PACKAGE_BUGREPORT="xz@tukaani.org"
     PACKAGE_URL="https://tukaani.org/xz/"
 
     # Features:
     HAVE_CHECK_CRC32
     HAVE_CHECK_CRC64
     HAVE_CHECK_SHA256
     HAVE_DECODERS
     HAVE_DECODER_ARM
     HAVE_DECODER_ARMTHUMB
     HAVE_DECODER_ARM64
     HAVE_DECODER_DELTA
     HAVE_DECODER_IA64
     HAVE_DECODER_LZMA1
     HAVE_DECODER_LZMA2
     HAVE_DECODER_POWERPC
     HAVE_DECODER_SPARC
     HAVE_DECODER_X86
     HAVE_ENCODERS
     HAVE_ENCODER_ARM
     HAVE_ENCODER_ARMTHUMB
     HAVE_ENCODER_ARM64
     HAVE_ENCODER_DELTA
     HAVE_ENCODER_IA64
     HAVE_ENCODER_LZMA1
     HAVE_ENCODER_LZMA2
     HAVE_ENCODER_POWERPC
     HAVE_ENCODER_SPARC
     HAVE_ENCODER_X86
     HAVE_MF_BT2
     HAVE_MF_BT3
     HAVE_MF_BT4
     HAVE_MF_HC3
     HAVE_MF_HC4
     HAVE_LZIP_DECODER
 
     # Standard headers and types are available:
     HAVE_STDBOOL_H
     HAVE__BOOL
     HAVE_STDINT_H
     HAVE_INTTYPES_H
 
     # Disable assert() checks when no build type has been specified. Non-empty
     # build types like "Release" and "Debug" handle this by default.
     $<$<CONFIG:>:NDEBUG>
 )
 
 # _GNU_SOURCE and such definitions. This specific macro is special since
 # it also adds the definitions to CMAKE_REQUIRED_DEFINITIONS.
 tuklib_use_system_extensions(ALL)
 
 # This is needed by liblzma and xz.
 tuklib_integer(ALL)
 
 # Check for clock_gettime(). Do this before checking for threading so
 # that we know there if CLOCK_MONOTONIC is available.
 if(NOT WIN32 AND NOT DEFINED HAVE_CLOCK_GETTIME)
     check_symbol_exists(clock_gettime time.h HAVE_CLOCK_GETTIME)
     if(NOT HAVE_CLOCK_GETTIME)
         # With glibc <= 2.17 or Solaris 10 this needs librt.
         unset(HAVE_CLOCK_GETTIME CACHE)
 
         list(INSERT CMAKE_REQUIRED_LIBRARIES 0 rt)
         check_symbol_exists(clock_gettime time.h HAVE_CLOCK_GETTIME)
 
         # If it was found now, add it to all targets and keep it
         # in CMAKE_REQUIRED_LIBRARIES for further tests too.
         if(HAVE_CLOCK_GETTIME)
             link_libraries(rt)
         else()
             list(REMOVE_AT CMAKE_REQUIRED_LIBRARIES 0)
         endif()
     endif()
     if(HAVE_CLOCK_GETTIME)
         # Check if CLOCK_MONOTONIC is available for clock_gettime().
         check_symbol_exists(CLOCK_MONOTONIC time.h HAVE_CLOCK_MONOTONIC)
 
         add_compile_definitions(
             HAVE_CLOCK_GETTIME
             HAVE_CLOCK_MONOTONIC
         )
     endif()
 endif()
 
 # Threading support:
 set(THREADS_PREFER_PTHREAD_FLAG TRUE)
 find_package(Threads REQUIRED)
 if(CMAKE_USE_WIN32_THREADS_INIT)
     if(CMAKE_SIZEOF_VOID_P EQUAL 4)
         # Define to 1 when using Windows 95 (and thus XP) compatible threads. This
         # avoids use of features that were added in Windows Vista.
         # This is used for 32-bit x86 builds for compatibility reasons since it
         # makes no measurable difference in performance compared to Vista threads.
         add_compile_definitions(MYTHREAD_WIN95)
     else()
         # Define to 1 when using Windows Vista compatible threads. This uses features
         # that are not available on Windows XP.
         add_compile_definitions(MYTHREAD_VISTA)
     endif()
 else()
     add_compile_definitions(MYTHREAD_POSIX)
 
     # Check if pthread_condattr_setclock() exists to use CLOCK_MONOTONIC.
     if(HAVE_CLOCK_MONOTONIC)
         list(INSERT CMAKE_REQUIRED_LIBRARIES 0 "${CMAKE_THREAD_LIBS_INIT}")
         check_symbol_exists(pthread_condattr_setclock pthread.h
                             HAVE_PTHREAD_CONDATTR_SETCLOCK)
         tuklib_add_definition_if(ALL HAVE_PTHREAD_CONDATTR_SETCLOCK)
     endif()
 endif()
 
 # Options for new enough GCC or Clang on any arch or operating system:
 if(CMAKE_C_COMPILER_ID MATCHES GNU|Clang)
     # configure.ac has a long list but it won't be copied here:
     add_compile_options(-Wall -Wextra)
 endif()
 
 
 #############################################################################
 # liblzma
 #############################################################################
 
 option(BUILD_SHARED_LIBS "Build liblzma as a shared library instead of static")
 
 add_library(liblzma
     src/common/mythread.h
     src/common/sysdefs.h
     src/common/tuklib_common.h
     src/common/tuklib_config.h
     src/common/tuklib_cpucores.c
     src/common/tuklib_cpucores.h
     src/common/tuklib_integer.h
     src/common/tuklib_physmem.c
     src/common/tuklib_physmem.h
     src/liblzma/api/lzma.h
     src/liblzma/api/lzma/base.h
     src/liblzma/api/lzma/bcj.h
     src/liblzma/api/lzma/block.h
     src/liblzma/api/lzma/check.h
     src/liblzma/api/lzma/container.h
     src/liblzma/api/lzma/delta.h
     src/liblzma/api/lzma/filter.h
     src/liblzma/api/lzma/hardware.h
     src/liblzma/api/lzma/index.h
     src/liblzma/api/lzma/index_hash.h
     src/liblzma/api/lzma/lzma12.h
     src/liblzma/api/lzma/stream_flags.h
     src/liblzma/api/lzma/version.h
     src/liblzma/api/lzma/vli.h
     src/liblzma/check/check.c
     src/liblzma/check/check.h
     src/liblzma/check/crc32_fast.c
     src/liblzma/check/crc32_table.c
     src/liblzma/check/crc32_table_be.h
     src/liblzma/check/crc32_table_le.h
     src/liblzma/check/crc64_fast.c
     src/liblzma/check/crc64_table.c
     src/liblzma/check/crc64_table_be.h
     src/liblzma/check/crc64_table_le.h
     src/liblzma/check/crc_macros.h
     src/liblzma/check/sha256.c
     src/liblzma/common/alone_decoder.c
     src/liblzma/common/alone_decoder.h
     src/liblzma/common/alone_encoder.c
     src/liblzma/common/auto_decoder.c
     src/liblzma/common/block_buffer_decoder.c
     src/liblzma/common/block_buffer_encoder.c
     src/liblzma/common/block_buffer_encoder.h
     src/liblzma/common/block_decoder.c
     src/liblzma/common/block_decoder.h
     src/liblzma/common/block_encoder.c
     src/liblzma/common/block_encoder.h
     src/liblzma/common/block_header_decoder.c
     src/liblzma/common/block_header_encoder.c
     src/liblzma/common/block_util.c
     src/liblzma/common/common.c
     src/liblzma/common/common.h
     src/liblzma/common/easy_buffer_encoder.c
     src/liblzma/common/easy_decoder_memusage.c
     src/liblzma/common/easy_encoder.c
     src/liblzma/common/easy_encoder_memusage.c
     src/liblzma/common/easy_preset.c
     src/liblzma/common/easy_preset.h
     src/liblzma/common/file_info.c
     src/liblzma/common/filter_buffer_decoder.c
     src/liblzma/common/filter_buffer_encoder.c
     src/liblzma/common/filter_common.c
     src/liblzma/common/filter_common.h
     src/liblzma/common/filter_decoder.c
     src/liblzma/common/filter_decoder.h
     src/liblzma/common/filter_encoder.c
     src/liblzma/common/filter_encoder.h
     src/liblzma/common/filter_flags_decoder.c
     src/liblzma/common/filter_flags_encoder.c
     src/liblzma/common/hardware_cputhreads.c
     src/liblzma/common/hardware_physmem.c
     src/liblzma/common/index.c
     src/liblzma/common/index.h
     src/liblzma/common/index_decoder.c
     src/liblzma/common/index_decoder.h
     src/liblzma/common/index_encoder.c
     src/liblzma/common/index_encoder.h
     src/liblzma/common/index_hash.c
     src/liblzma/common/lzip_decoder.c
     src/liblzma/common/lzip_decoder.h
     src/liblzma/common/memcmplen.h
     src/liblzma/common/outqueue.c
     src/liblzma/common/outqueue.h
     src/liblzma/common/stream_buffer_decoder.c
     src/liblzma/common/stream_buffer_encoder.c
     src/liblzma/common/stream_decoder.c
     src/liblzma/common/stream_decoder_mt.c
     src/liblzma/common/stream_decoder.h
     src/liblzma/common/stream_encoder.c
     src/liblzma/common/stream_encoder_mt.c
     src/liblzma/common/stream_flags_common.c
     src/liblzma/common/stream_flags_common.h
     src/liblzma/common/stream_flags_decoder.c
     src/liblzma/common/stream_flags_encoder.c
     src/liblzma/common/string_conversion.c
     src/liblzma/common/vli_decoder.c
     src/liblzma/common/vli_encoder.c
     src/liblzma/common/vli_size.c
     src/liblzma/delta/delta_common.c
     src/liblzma/delta/delta_common.h
     src/liblzma/delta/delta_decoder.c
     src/liblzma/delta/delta_decoder.h
     src/liblzma/delta/delta_encoder.c
     src/liblzma/delta/delta_encoder.h
     src/liblzma/delta/delta_private.h
     src/liblzma/lz/lz_decoder.c
     src/liblzma/lz/lz_decoder.h
     src/liblzma/lz/lz_encoder.c
     src/liblzma/lz/lz_encoder.h
     src/liblzma/lz/lz_encoder_hash.h
     src/liblzma/lz/lz_encoder_hash_table.h
     src/liblzma/lz/lz_encoder_mf.c
     src/liblzma/lzma/fastpos.h
     src/liblzma/lzma/fastpos_table.c
     src/liblzma/lzma/lzma2_decoder.c
     src/liblzma/lzma/lzma2_decoder.h
     src/liblzma/lzma/lzma2_encoder.c
     src/liblzma/lzma/lzma2_encoder.h
     src/liblzma/lzma/lzma_common.h
     src/liblzma/lzma/lzma_decoder.c
     src/liblzma/lzma/lzma_decoder.h
     src/liblzma/lzma/lzma_encoder.c
     src/liblzma/lzma/lzma_encoder.h
     src/liblzma/lzma/lzma_encoder_optimum_fast.c
     src/liblzma/lzma/lzma_encoder_optimum_normal.c
     src/liblzma/lzma/lzma_encoder_presets.c
     src/liblzma/lzma/lzma_encoder_private.h
     src/liblzma/rangecoder/price.h
     src/liblzma/rangecoder/price_table.c
     src/liblzma/rangecoder/range_common.h
     src/liblzma/rangecoder/range_decoder.h
     src/liblzma/rangecoder/range_encoder.h
     src/liblzma/simple/arm.c
     src/liblzma/simple/armthumb.c
     src/liblzma/simple/arm64.c
     src/liblzma/simple/ia64.c
     src/liblzma/simple/powerpc.c
     src/liblzma/simple/simple_coder.c
     src/liblzma/simple/simple_coder.h
     src/liblzma/simple/simple_decoder.c
     src/liblzma/simple/simple_decoder.h
     src/liblzma/simple/simple_encoder.c
     src/liblzma/simple/simple_encoder.h
     src/liblzma/simple/simple_private.h
     src/liblzma/simple/sparc.c
     src/liblzma/simple/x86.c
 )
 
 target_include_directories(liblzma PRIVATE
     src/liblzma/api
     src/liblzma/common
     src/liblzma/check
     src/liblzma/lz
     src/liblzma/rangecoder
     src/liblzma/lzma
     src/liblzma/delta
     src/liblzma/simple
     src/common
 )
 
 target_link_libraries(liblzma Threads::Threads)
 
 # Put the tuklib functions under the lzma_ namespace.
 target_compile_definitions(liblzma PRIVATE TUKLIB_SYMBOL_PREFIX=lzma_)
 tuklib_cpucores(liblzma)
 tuklib_physmem(liblzma)
 
 # While liblzma can be built without tuklib_cpucores or tuklib_physmem
 # modules, the liblzma API functions lzma_cputhreads() and lzma_physmem()
 # will then be useless (which isn't too bad but still unfortunate). Since
 # I expect the CMake-based builds to be only used on systems that are
 # supported by these tuklib modules, problems with these tuklib modules
 # are considered a hard error for now. This hopefully helps to catch bugs
 # in the CMake versions of the tuklib checks.
 if(NOT TUKLIB_CPUCORES_FOUND OR NOT TUKLIB_PHYSMEM_FOUND)
     # Use SEND_ERROR instead of FATAL_ERROR. If someone reports a bug,
     # seeing the results of the remaining checks can be useful too.
     message(SEND_ERROR
             "tuklib_cpucores() or tuklib_physmem() failed. "
             "Unless you really are building for a system where these "
             "modules are not supported (unlikely), this is a bug in the "
             "included cmake/tuklib_*.cmake files that should be fixed. "
             "To build anyway, edit this CMakeLists.txt to ignore this error.")
 endif()
 
 # Check for __attribute__((__constructor__)) support.
 # This needs -Werror because some compilers just warn
 # about this being unsupported.
 cmake_push_check_state()
 set(CMAKE_REQUIRED_FLAGS "-Werror")
 check_c_source_compiles("
         __attribute__((__constructor__))
         static void my_constructor_func(void) { return; }
         int main(void) { return 0; }
     "
     HAVE_FUNC_ATTRIBUTE_CONSTRUCTOR)
 cmake_pop_check_state()
 tuklib_add_definition_if(liblzma HAVE_FUNC_ATTRIBUTE_CONSTRUCTOR)
 
 # cpuid.h
 check_include_file(cpuid.h HAVE_CPUID_H)
 tuklib_add_definition_if(liblzma HAVE_CPUID_H)
 
 # immintrin.h:
 check_include_file(immintrin.h HAVE_IMMINTRIN_H)
 if(HAVE_IMMINTRIN_H)
     target_compile_definitions(liblzma PRIVATE HAVE_IMMINTRIN_H)
 
     # SSE2 intrinsics:
     check_c_source_compiles("
             #include <immintrin.h>
             int main(void)
             {
                 __m128i x = { 0 };
                 _mm_movemask_epi8(x);
                 return 0;
             }
         "
         HAVE__MM_MOVEMASK_EPI8)
     tuklib_add_definition_if(liblzma HAVE__MM_MOVEMASK_EPI8)
 
     # CLMUL intrinsic:
     check_c_source_compiles("
             #include <immintrin.h>
             #if defined(__e2k__) && __iset__ < 6
             #   error
             #endif
             #if (defined(__GNUC__) || defined(__clang__)) && !defined(__EDG__)
             __attribute__((__target__(\"ssse3,sse4.1,pclmul\")))
             #endif
             __m128i my_clmul(__m128i a)
             {
                 const __m128i b = _mm_set_epi64x(1, 2);
                 return _mm_clmulepi64_si128(a, b, 0);
             }
             int main(void) { return 0; }
     "
     HAVE_USABLE_CLMUL)
     tuklib_add_definition_if(liblzma HAVE_USABLE_CLMUL)
 endif()
 
 # Support -fvisiblity=hidden when building shared liblzma.
 # These lines do nothing on Windows (even under Cygwin).
 # HAVE_VISIBILITY should always be defined to 0 or 1.
 if(BUILD_SHARED_LIBS)
     set_target_properties(liblzma PROPERTIES C_VISIBILITY_PRESET hidden)
     target_compile_definitions(liblzma PRIVATE HAVE_VISIBILITY=1)
 else()
     target_compile_definitions(liblzma PRIVATE HAVE_VISIBILITY=0)
 endif()
 
 if(WIN32)
     if(BUILD_SHARED_LIBS)
         # Add the Windows resource file for liblzma.dll.
         target_sources(liblzma PRIVATE src/liblzma/liblzma_w32res.rc)
 
         set_target_properties(liblzma PROPERTIES
             LINK_DEPENDS "${CMAKE_CURRENT_SOURCE_DIR}/src/common/common_w32res.rc"
         )
 
         # Export the public API symbols with __declspec(dllexport).
         target_compile_definitions(liblzma PRIVATE DLL_EXPORT)
     else()
         # Disable __declspec(dllimport) when linking against static liblzma.
         target_compile_definitions(liblzma INTERFACE LZMA_API_STATIC)
     endif()
 elseif(BUILD_SHARED_LIBS AND CMAKE_SYSTEM_NAME STREQUAL "Linux")
     # GNU/Linux-specific symbol versioning for shared liblzma.
     # Note that adding link options doesn't affect static builds
     # but HAVE_SYMBOL_VERSIONS_LINUX must not be used with static builds
     # because it would put symbol versions into the static library which
     # can cause problems. It's clearer if all symver related things are
     # omitted when not building a shared library.
     #
     # NOTE: Set it explicitly to 1 to make it clear that versioning is
     # done unconditionally in the C files.
     target_compile_definitions(liblzma PRIVATE HAVE_SYMBOL_VERSIONS_LINUX=1)
     target_link_options(liblzma PRIVATE
         "-Wl,--version-script=${CMAKE_CURRENT_SOURCE_DIR}/src/liblzma/liblzma_linux.map"
     )
     set_target_properties(liblzma PROPERTIES
         LINK_DEPENDS "${CMAKE_CURRENT_SOURCE_DIR}/src/liblzma/liblzma_linux.map"
     )
 elseif(BUILD_SHARED_LIBS AND CMAKE_SYSTEM_NAME STREQUAL "FreeBSD")
     # Symbol versioning for shared liblzma for non-GNU/Linux.
     # FIXME? What about Solaris?
     target_link_options(liblzma PRIVATE
         "-Wl,--version-script=${CMAKE_CURRENT_SOURCE_DIR}/src/liblzma/liblzma_generic.map"
     )
     set_target_properties(liblzma PROPERTIES
         LINK_DEPENDS "${CMAKE_CURRENT_SOURCE_DIR}/src/liblzma/liblzma_generic.map"
     )
 endif()
 
 set_target_properties(liblzma PROPERTIES
     # At least for now the package versioning matches the rules used for
     # shared library versioning (excluding development releases) so it is
     # fine to use the package version here.
     SOVERSION "${xz_VERSION_MAJOR}"
     VERSION "${xz_VERSION}"
 
     # It's liblzma.so or liblzma.dll, not libliblzma.so or lzma.dll.
     # Avoid the name lzma.dll because it would conflict with LZMA SDK.
     PREFIX ""
 )
 
 # Create liblzma-config-version.cmake. We use this spelling instead of
 # liblzmaConfig.cmake to make find_package work in case insensitive manner
 # even with case sensitive file systems. This gives more consistent behavior
 # between operating systems.
 #
 # FIXME: SameMajorVersion is correct for stable releases but it is wrong
 # for development releases where each release may have incompatible changes.
 include(CMakePackageConfigHelpers)
 write_basic_package_version_file(
     "${CMAKE_CURRENT_BINARY_DIR}/liblzma-config-version.cmake"
     VERSION "${liblzma_VERSION}"
     COMPATIBILITY SameMajorVersion)
 
 # Create liblzma-config.cmake.
 file(WRITE "${CMAKE_CURRENT_BINARY_DIR}/liblzma-config.cmake"
 "include(CMakeFindDependencyMacro)
 set(THREADS_PREFER_PTHREAD_FLAG TRUE)
 find_dependency(Threads)
 
 include(\"\${CMAKE_CURRENT_LIST_DIR}/liblzma-targets.cmake\")
 
 # Be compatible with the spelling used by the FindLibLZMA module. This
 # doesn't use ALIAS because it would make CMake resolve LibLZMA::LibLZMA
 # to liblzma::liblzma instead of keeping the original spelling. Keeping
 # the original spelling is important for good FindLibLZMA compatibility.
 add_library(LibLZMA::LibLZMA INTERFACE IMPORTED)
 set_target_properties(LibLZMA::LibLZMA PROPERTIES
                       INTERFACE_LINK_LIBRARIES liblzma::liblzma)
 ")
 
 # Set CMAKE_INSTALL_LIBDIR and friends.
 include(GNUInstallDirs)
 
 # Install the library binary. The INCLUDES specifies the include path that
 # is exported for other projects to use but it doesn't install any files.
 install(TARGETS liblzma EXPORT liblzmaTargets
         RUNTIME  DESTINATION "${CMAKE_INSTALL_BINDIR}"
                  COMPONENT liblzma_Runtime
         LIBRARY  DESTINATION "${CMAKE_INSTALL_LIBDIR}"
                  COMPONENT liblzma_Runtime
                  NAMELINK_COMPONENT liblzma_Development
         ARCHIVE  DESTINATION "${CMAKE_INSTALL_LIBDIR}"
                  COMPONENT liblzma_Development
         INCLUDES DESTINATION "${CMAKE_INSTALL_INCLUDEDIR}")
 
 # Install the liblzma API headers. These use a subdirectory so
 # this has to be done as a separate step.
 install(DIRECTORY src/liblzma/api/
         COMPONENT liblzma_Development
         DESTINATION "${CMAKE_INSTALL_INCLUDEDIR}"
         FILES_MATCHING PATTERN "*.h")
 
 # Install the CMake files that other packages can use to find liblzma.
 set(liblzma_INSTALL_CMAKEDIR
     "${CMAKE_INSTALL_LIBDIR}/cmake/liblzma"
     CACHE STRING "Path to liblzma's .cmake files")
 
 install(EXPORT liblzmaTargets
         NAMESPACE liblzma::
         FILE liblzma-targets.cmake
         DESTINATION "${liblzma_INSTALL_CMAKEDIR}"
         COMPONENT liblzma_Development)
 
 install(FILES "${CMAKE_CURRENT_BINARY_DIR}/liblzma-config.cmake"
               "${CMAKE_CURRENT_BINARY_DIR}/liblzma-config-version.cmake"
         DESTINATION "${liblzma_INSTALL_CMAKEDIR}"
         COMPONENT liblzma_Development)
 
 
 #############################################################################
 # getopt_long
 #############################################################################
 
 # The command line tools needs this.
 check_symbol_exists(getopt_long getopt.h HAVE_GETOPT_LONG)
 
 
 #############################################################################
 # xzdec
 #############################################################################
 
 if(HAVE_GETOPT_LONG)
     add_executable(xzdec
         src/common/sysdefs.h
         src/common/tuklib_common.h
         src/common/tuklib_config.h
         src/common/tuklib_exit.c
         src/common/tuklib_exit.h
         src/common/tuklib_gettext.h
         src/common/tuklib_progname.c
         src/common/tuklib_progname.h
         src/xzdec/xzdec.c
     )
 
     target_include_directories(xzdec PRIVATE
         src/common
         src/liblzma/api
     )
 
     target_link_libraries(xzdec PRIVATE liblzma)
 
     if(WIN32)
         # Add the Windows resource file for xzdec.exe.
         target_sources(xzdec PRIVATE src/xzdec/xzdec_w32res.rc)
         set_target_properties(xzdec PROPERTIES
             LINK_DEPENDS "${CMAKE_CURRENT_SOURCE_DIR}/src/common/common_w32res.rc"
         )
     endif()
 
     tuklib_progname(xzdec)
 
     install(TARGETS xzdec
             RUNTIME DESTINATION "${CMAKE_INSTALL_BINDIR}"
                     COMPONENT xzdec)
 
     if(UNIX)
         install(FILES src/xzdec/xzdec.1
                 DESTINATION "${CMAKE_INSTALL_MANDIR}/man1"
                 COMPONENT xzdec)
     endif()
 endif()
 
 
 #############################################################################
 # xz
 #############################################################################
 
 if(NOT MSVC AND HAVE_GETOPT_LONG)
     add_executable(xz
         src/common/mythread.h
         src/common/sysdefs.h
         src/common/tuklib_common.h
         src/common/tuklib_config.h
         src/common/tuklib_exit.c
         src/common/tuklib_exit.h
         src/common/tuklib_gettext.h
         src/common/tuklib_integer.h
         src/common/tuklib_mbstr.h
         src/common/tuklib_mbstr_fw.c
         src/common/tuklib_mbstr_width.c
         src/common/tuklib_open_stdxxx.c
         src/common/tuklib_open_stdxxx.h
         src/common/tuklib_progname.c
         src/common/tuklib_progname.h
         src/xz/args.c
         src/xz/args.h
         src/xz/coder.c
         src/xz/coder.h
         src/xz/file_io.c
         src/xz/file_io.h
         src/xz/hardware.c
         src/xz/hardware.h
         src/xz/list.c
         src/xz/list.h
         src/xz/main.c
         src/xz/main.h
         src/xz/message.c
         src/xz/message.h
         src/xz/mytime.c
         src/xz/mytime.h
         src/xz/options.c
         src/xz/options.h
         src/xz/private.h
         src/xz/signals.c
         src/xz/signals.h
         src/xz/suffix.c
         src/xz/suffix.h
         src/xz/util.c
         src/xz/util.h
     )
 
     target_include_directories(xz PRIVATE
         src/common
         src/liblzma/api
     )
 
     target_link_libraries(xz PRIVATE liblzma)
 
     target_compile_definitions(xz PRIVATE ASSUME_RAM=128)
 
     if(WIN32)
         # Add the Windows resource file for xz.exe.
         target_sources(xz PRIVATE src/xz/xz_w32res.rc)
         set_target_properties(xz PROPERTIES
             LINK_DEPENDS "${CMAKE_CURRENT_SOURCE_DIR}/src/common/common_w32res.rc"
         )
     endif()
 
     tuklib_progname(xz)
     tuklib_mbstr(xz)
 
     check_symbol_exists(optreset getopt.h HAVE_OPTRESET)
     tuklib_add_definition_if(xz HAVE_OPTRESET)
 
     check_symbol_exists(posix_fadvise fcntl.h HAVE_POSIX_FADVISE)
     tuklib_add_definition_if(xz HAVE_POSIX_FADVISE)
 
     # How to get file time:
     check_struct_has_member("struct stat" st_atim.tv_nsec
                             "sys/types.h;sys/stat.h"
                             HAVE_STRUCT_STAT_ST_ATIM_TV_NSEC)
     if(HAVE_STRUCT_STAT_ST_ATIM_TV_NSEC)
         tuklib_add_definitions(xz HAVE_STRUCT_STAT_ST_ATIM_TV_NSEC)
     else()
         check_struct_has_member("struct stat" st_atimespec.tv_nsec
                                 "sys/types.h;sys/stat.h"
                                 HAVE_STRUCT_STAT_ST_ATIMESPEC_TV_NSEC)
         if(HAVE_STRUCT_STAT_ST_ATIMESPEC_TV_NSEC)
             tuklib_add_definitions(xz HAVE_STRUCT_STAT_ST_ATIMESPEC_TV_NSEC)
         else()
             check_struct_has_member("struct stat" st_atimensec
                                     "sys/types.h;sys/stat.h"
                                     HAVE_STRUCT_STAT_ST_ATIMENSEC)
             tuklib_add_definition_if(xz HAVE_STRUCT_STAT_ST_ATIMENSEC)
         endif()
     endif()
 
     # How to set file time:
     check_symbol_exists(futimens "sys/types.h;sys/stat.h" HAVE_FUTIMENS)
     if(HAVE_FUTIMENS)
         tuklib_add_definitions(xz HAVE_FUTIMENS)
     else()
         check_symbol_exists(futimes "sys/time.h" HAVE_FUTIMES)
         if(HAVE_FUTIMES)
             tuklib_add_definitions(xz HAVE_FUTIMES)
         else()
             check_symbol_exists(futimesat "sys/time.h" HAVE_FUTIMESAT)
             if(HAVE_FUTIMESAT)
                 tuklib_add_definitions(xz HAVE_FUTIMESAT)
             else()
                 check_symbol_exists(utimes "sys/time.h" HAVE_UTIMES)
                 if(HAVE_UTIMES)
                     tuklib_add_definitions(xz HAVE_UTIMES)
                 else()
                     check_symbol_exists(_futime "sys/utime.h" HAVE__FUTIME)
                     if(HAVE__FUTIME)
                         tuklib_add_definitions(xz HAVE__FUTIME)
                     else()
                         check_symbol_exists(utime "utime.h" HAVE_UTIME)
                         tuklib_add_definition_if(xz HAVE_UTIME)
                     endif()
                 endif()
             endif()
         endif()
     endif()
 
     install(TARGETS xz
             RUNTIME DESTINATION "${CMAKE_INSTALL_BINDIR}"
                     COMPONENT xz)
 
     if(UNIX)
         install(FILES src/xz/xz.1
                 DESTINATION "${CMAKE_INSTALL_MANDIR}/man1"
                 COMPONENT xz)
 
         option(CREATE_XZ_SYMLINKS "Create unxz and xzcat symlinks" ON)
         option(CREATE_LZMA_SYMLINKS "Create lzma, unlzma, and lzcat symlinks"
                ON)
         set(XZ_LINKS)
 
         if(CREATE_XZ_SYMLINKS)
             list(APPEND XZ_LINKS "unxz" "xzcat")
         endif()
 
         if(CREATE_LZMA_SYMLINKS)
             list(APPEND XZ_LINKS "lzma" "unlzma" "lzcat")
         endif()
 
         # Create symlinks in the build directory and then install them.
         #
         # The symlinks do not likely need any special extension since
         # even on Windows the symlink can still be executed without
         # the .exe extension.
         foreach(LINK IN LISTS XZ_LINKS)
             add_custom_target("${LINK}" ALL
                 "${CMAKE_COMMAND}" -E create_symlink
                     "$<TARGET_FILE_NAME:xz>" "${LINK}"
                 BYPRODUCTS "${LINK}"
                 VERBATIM)
             install(FILES "${CMAKE_CURRENT_BINARY_DIR}/${LINK}"
                     DESTINATION "${CMAKE_INSTALL_BINDIR}"
                     COMPONENT xz)
             add_custom_target("${LINK}.1" ALL
                 "${CMAKE_COMMAND}" -E create_symlink "xz.1" "${LINK}.1"
                 BYPRODUCTS "${LINK}.1"
                 VERBATIM)
             install(FILES "${CMAKE_CURRENT_BINARY_DIR}/${LINK}.1"
                     DESTINATION "${CMAKE_INSTALL_MANDIR}/man1"
                     COMPONENT xz)
         endforeach()
     endif()
 endif()
 
 
 #############################################################################
 # Tests
 #############################################################################
 
 include(CTest)
 
 if(BUILD_TESTING)
     set(LIBLZMA_TESTS
         test_bcj_exact_size
         test_block_header
         test_check
         test_filter_flags
+        test_filter_str
         test_hardware
         test_index
         test_index_hash
         test_memlimit
         test_stream_flags
         test_vli
     )
 
     foreach(TEST IN LISTS LIBLZMA_TESTS)
         add_executable("${TEST}" "tests/${TEST}.c")
 
         target_include_directories("${TEST}" PRIVATE
             src/common
             src/liblzma/api
             src/liblzma
             lib
         )
 
         target_link_libraries("${TEST}" PRIVATE liblzma)
 
         # Put the test programs into their own subdirectory so they don't
         # pollute the top-level dir which might contain xz and xzdec.
         set_target_properties("${TEST}" PROPERTIES
             RUNTIME_OUTPUT_DIRECTORY "${CMAKE_CURRENT_BINARY_DIR}/tests_bin"
         )
 
         add_test(NAME "${TEST}"
                  COMMAND "${CMAKE_CURRENT_BINARY_DIR}/tests_bin/${TEST}"
         )
 
         # Set srcdir environment variable so that the tests find their
         # input files from the source tree.
         #
         # Set the return code for skipped tests to match Automake convention.
         set_tests_properties("${TEST}" PROPERTIES
             ENVIRONMENT "srcdir=${CMAKE_CURRENT_LIST_DIR}/tests"
             SKIP_RETURN_CODE 77
         )
     endforeach()
 endif()
diff --git a/tests/Makefile.am b/tests/Makefile.am
index b1a2378a..0523191d 100644
--- a/tests/Makefile.am
+++ b/tests/Makefile.am
@@ -1,79 +1,81 @@
 ##
 ## Author: Lasse Collin
 ##
 ## This file has been put into the public domain.
 ## You can do whatever you want with this file.
 ##
 
 EXTRA_DIST = \
 	files \
 	ossfuzz \
 	tuktest.h \
 	tests.h \
 	test_files.sh \
 	test_compress.sh \
 	test_compress_prepared_bcj_sparc \
 	test_compress_prepared_bcj_x86 \
 	test_compress_generated_abc \
 	test_compress_generated_random \
 	test_compress_generated_text \
 	test_scripts.sh \
 	bcj_test.c \
 	compress_prepared_bcj_sparc \
 	compress_prepared_bcj_x86 \
 	xzgrep_expected_output
 
 AM_CPPFLAGS = \
 	-I$(top_srcdir)/src/common \
 	-I$(top_srcdir)/src/liblzma/api \
 	-I$(top_srcdir)/src/liblzma \
 	-I$(top_builddir)/lib
 
 LDADD = $(top_builddir)/src/liblzma/liblzma.la
 
 if COND_GNULIB
 LDADD += $(top_builddir)/lib/libgnu.a
 endif
 
 LDADD += $(LTLIBINTL)
 
 check_PROGRAMS = \
 	create_compress_files \
 	test_check \
 	test_hardware \
 	test_stream_flags \
 	test_filter_flags \
+	test_filter_str \
 	test_block_header \
 	test_index \
 	test_index_hash \
 	test_bcj_exact_size \
 	test_memlimit \
 	test_lzip_decoder \
 	test_vli
 
 TESTS = \
 	test_check \
 	test_hardware \
 	test_stream_flags \
 	test_filter_flags \
+	test_filter_str \
 	test_block_header \
 	test_index \
 	test_index_hash \
 	test_bcj_exact_size \
 	test_memlimit \
 	test_lzip_decoder \
 	test_vli \
 	test_files.sh \
 	test_compress_prepared_bcj_sparc \
 	test_compress_prepared_bcj_x86 \
 	test_compress_generated_abc \
 	test_compress_generated_random \
 	test_compress_generated_text
 
 if COND_SCRIPTS
 TESTS += test_scripts.sh
 endif
 
 clean-local:
 	-rm -f compress_generated_* \
 		xzgrep_test_output xzgrep_test_1.xz xzgrep_test_2.xz
diff --git a/tests/test_filter_str.c b/tests/test_filter_str.c
new file mode 100644
index 00000000..15aee55a
--- /dev/null
+++ b/tests/test_filter_str.c
@@ -0,0 +1,593 @@
+///////////////////////////////////////////////////////////////////////////////
+//
+/// \file       test_filter_str.c
+/// \brief      Tests Filter string functions
+//
+//  Author:    Jia Tan
+//
+//  This file has been put into the public domain.
+//  You can do whatever you want with this file.
+//
+///////////////////////////////////////////////////////////////////////////////
+
+#include "tests.h"
+
+
+static void
+test_lzma_str_to_filters(void)
+{
+	lzma_filter filters[LZMA_FILTERS_MAX + 1];
+	int error_pos;
+
+	// Test with NULL string.
+	assert_true(lzma_str_to_filters(NULL, &error_pos, filters, 0,
+			NULL) != NULL);
+
+	// Test with NULL filter array.
+	assert_true(lzma_str_to_filters("lzma2", &error_pos, NULL, 0,
+			NULL) != NULL);
+
+	// Test with unsupported flags.
+	assert_true(lzma_str_to_filters("lzma2", &error_pos, filters,
+			UINT32_MAX, NULL) != NULL);
+
+	assert_true(lzma_str_to_filters("lzma2", &error_pos, filters,
+			LZMA_STR_NO_SPACES << 1, NULL) != NULL);
+
+	assert_true(lzma_str_to_filters("lzma2", &error_pos, filters,
+			LZMA_STR_NO_SPACES, NULL) != NULL);
+
+	// Test with empty string.
+	assert_true(lzma_str_to_filters("", &error_pos,
+			filters, 0, NULL) != NULL);
+	assert_int_eq(error_pos, 0);
+
+	// Test with invalid filter name and missing filter name.
+	assert_true(lzma_str_to_filters("lzma2 abcd", &error_pos,
+			filters, 0, NULL) != NULL);
+	assert_int_eq(error_pos, 6);
+
+	assert_true(lzma_str_to_filters("lzma2--abcd", &error_pos,
+			filters, 0, NULL) != NULL);
+	assert_int_eq(error_pos, 7);
+
+	assert_true(lzma_str_to_filters("lzma2--", &error_pos,
+			filters, 0, NULL) != NULL);
+	assert_int_eq(error_pos, 7);
+
+	// Test LZMA_STR_ALL_FILTERS flag (should work with LZMA1 if built).
+#if defined(HAVE_ENCODER_LZMA1) || defined(HAVE_DECODER_LZMA1)
+	// Using LZMA1 as a Filter should fail without LZMA_STR_ALL_FILTERS.
+	assert_true(lzma_str_to_filters("lzma1", &error_pos, filters,
+			0, NULL) != NULL);
+	assert_int_eq(error_pos, 0);
+
+	assert_true(lzma_str_to_filters("lzma1", &error_pos, filters,
+			LZMA_STR_ALL_FILTERS, NULL) == NULL);
+
+	// Verify Filters array IDs are correct. The array should contain
+	// only two elements:
+	// 1. LZMA1 Filter
+	// 2. LZMA_VLI_UNKNOWN filter array terminator
+	assert_uint_eq(filters[0].id, LZMA_FILTER_LZMA1);
+	assert_uint_eq(filters[1].id, LZMA_VLI_UNKNOWN);
+
+	lzma_filters_free(filters, NULL);
+#endif
+
+	// Test LZMA_STR_NO_VALIDATION flag. This should allow having the
+	// same Filter multiple times in the chain and having a non-last
+	// Filter like lzma2 appear before another Filter.
+	// Without the flag, "lzma2 lzma2" must fail.
+	assert_true(lzma_str_to_filters("lzma2 lzma2", &error_pos, filters,
+			0, NULL) != NULL);
+
+	assert_true(lzma_str_to_filters("lzma2 lzma2", &error_pos, filters,
+			LZMA_STR_NO_VALIDATION, NULL) == NULL);
+
+	assert_uint_eq(filters[0].id, LZMA_FILTER_LZMA2);
+	assert_uint_eq(filters[1].id, LZMA_FILTER_LZMA2);
+	assert_uint_eq(filters[2].id, LZMA_VLI_UNKNOWN);
+
+	lzma_filters_free(filters, NULL);
+
+	// Should fail with invalid Filter options (lc + lp must be <= 4).
+	assert_true(lzma_str_to_filters("lzma2:lc=3,lp=3", &error_pos, filters,
+			LZMA_STR_NO_VALIDATION, NULL) != NULL);
+
+	// Test invalid option name.
+	assert_true(lzma_str_to_filters("lzma2:foo=1,bar=2", &error_pos,
+			filters, 0, NULL) != NULL);
+	assert_int_eq(error_pos, 6);
+
+	// Test missing option value.
+	assert_true(lzma_str_to_filters("lzma2:lc=", &error_pos,
+			filters, 0, NULL) != NULL);
+	assert_int_eq(error_pos, 9);
+
+	assert_true(lzma_str_to_filters("lzma2:=,pb=1", &error_pos,
+			filters, 0, NULL) != NULL);
+	assert_int_eq(error_pos, 6);
+
+	// Test unsupported preset value.
+	assert_true(lzma_str_to_filters("-10", &error_pos,
+			filters, 0, NULL) != NULL);
+	assert_int_eq(error_pos, 2);
+
+	assert_true(lzma_str_to_filters("-5f", &error_pos,
+			filters, 0, NULL) != NULL);
+	assert_int_eq(error_pos, 2);
+
+	// Test filter chain too long.
+	assert_true(lzma_str_to_filters("lzma2 lzma2 lzma2 lzma2 lzma2",
+			&error_pos, filters, LZMA_STR_NO_VALIDATION,
+			NULL) != NULL);
+	assert_int_eq(error_pos, 24);
+
+#if defined(HAVE_ENCODER_LZMA1) || defined(HAVE_DECODER_LZMA1)
+	// Should fail with a Filter not supported in the .xz format (lzma1).
+	assert_true(lzma_str_to_filters("lzma1", &error_pos, filters,
+			LZMA_STR_NO_VALIDATION, NULL) != NULL);
+#endif
+
+	// Test setting options with the "=" format.
+	assert_true(lzma_str_to_filters("lzma2=dict=4096,lc=2,lp=2,pb=1,"
+			"mode=fast,nice=3,mf=hc3,depth=10", &error_pos,
+			filters, 0, NULL) == NULL);
+	assert_uint_eq(filters[0].id, LZMA_FILTER_LZMA2);
+	assert_uint_eq(filters[1].id, LZMA_VLI_UNKNOWN);
+
+	lzma_options_lzma *opts = filters[0].options;
+	assert_uint_eq(opts->dict_size, 4096);
+	assert_uint_eq(opts->lc, 2);
+	assert_uint_eq(opts->lp, 2);
+	assert_uint_eq(opts->pb, 1);
+	assert_uint_eq(opts->mode, LZMA_MODE_FAST);
+	assert_uint_eq(opts->nice_len, 3);
+	assert_uint_eq(opts->mf, LZMA_MF_HC3);
+	assert_uint_eq(opts->depth, 10);
+
+	lzma_filters_free(filters, NULL);
+
+#if defined(HAVE_ENCODER_X86) || defined(HAVE_DECODER_X86)
+	// Test BCJ Filter options.
+	assert_true(lzma_str_to_filters("x86:start=16", &error_pos, filters,
+			LZMA_STR_NO_VALIDATION, NULL) == NULL);
+
+	assert_uint_eq(filters[0].id, LZMA_FILTER_X86);
+	assert_uint_eq(filters[1].id, LZMA_VLI_UNKNOWN);
+
+	lzma_options_bcj *bcj_opts = filters[0].options;
+	assert_uint_eq(bcj_opts->start_offset, 16);
+
+	lzma_filters_free(filters, NULL);
+#endif
+
+#if defined(HAVE_ENCODER_DELTA) || defined(HAVE_DECODER_DELTA)
+	// Test Delta Filter options.
+	assert_true(lzma_str_to_filters("delta:dist=20", &error_pos, filters,
+			LZMA_STR_NO_VALIDATION, NULL) == NULL);
+
+	assert_uint_eq(filters[0].id, LZMA_FILTER_DELTA);
+	assert_uint_eq(filters[1].id, LZMA_VLI_UNKNOWN);
+
+	lzma_options_delta *delta_opts = filters[0].options;
+	assert_uint_eq(delta_opts->dist, 20);
+
+	lzma_filters_free(filters, NULL);
+#endif
+
+	// Test skipping leading spaces.
+	assert_true(lzma_str_to_filters("    lzma2", &error_pos, filters,
+			0, NULL) == NULL);
+
+	assert_uint_eq(filters[0].id, LZMA_FILTER_LZMA2);
+	assert_uint_eq(filters[1].id, LZMA_VLI_UNKNOWN);
+
+	lzma_filters_free(filters, NULL);
+
+	// Test skipping trailing spaces.
+	assert_true(lzma_str_to_filters("lzma2    ", &error_pos, filters,
+			0, NULL) == NULL);
+
+	assert_uint_eq(filters[0].id, LZMA_FILTER_LZMA2);
+	assert_uint_eq(filters[1].id, LZMA_VLI_UNKNOWN);
+
+	lzma_filters_free(filters, NULL);
+
+	// Test with "--" instead of space separating.
+	assert_true(lzma_str_to_filters("lzma2--lzma2", &error_pos, filters,
+			LZMA_STR_NO_VALIDATION, NULL) == NULL);
+
+	assert_uint_eq(filters[0].id, LZMA_FILTER_LZMA2);
+	assert_uint_eq(filters[1].id, LZMA_FILTER_LZMA2);
+	assert_uint_eq(filters[2].id, LZMA_VLI_UNKNOWN);
+
+	lzma_filters_free(filters, NULL);
+
+	// Test preset with and without leading "-", and with "e".
+	assert_true(lzma_str_to_filters("-3", &error_pos, filters,
+			0, NULL) == NULL);
+
+	assert_uint_eq(filters[0].id, LZMA_FILTER_LZMA2);
+	assert_uint_eq(filters[1].id, LZMA_VLI_UNKNOWN);
+
+	lzma_filters_free(filters, NULL);
+
+	assert_true(lzma_str_to_filters("4", &error_pos, filters,
+			0, NULL) == NULL);
+
+	assert_uint_eq(filters[0].id, LZMA_FILTER_LZMA2);
+	assert_uint_eq(filters[1].id, LZMA_VLI_UNKNOWN);
+
+	lzma_filters_free(filters, NULL);
+
+	assert_true(lzma_str_to_filters("9e", &error_pos, filters,
+			0, NULL) == NULL);
+
+	assert_uint_eq(filters[0].id, LZMA_FILTER_LZMA2);
+	assert_uint_eq(filters[1].id, LZMA_VLI_UNKNOWN);
+
+	lzma_filters_free(filters, NULL);
+
+	// Test using a preset as an lzma2 option.
+	assert_true(lzma_str_to_filters("lzma2:preset=9e", &error_pos, filters,
+			0, NULL) == NULL);
+
+	assert_uint_eq(filters[0].id, LZMA_FILTER_LZMA2);
+	assert_uint_eq(filters[1].id, LZMA_VLI_UNKNOWN);
+
+	lzma_filters_free(filters, NULL);
+
+	// Test setting dictionary size with invalid modifier suffix.
+	assert_true(lzma_str_to_filters("lzma2:dict=4096ZiB", &error_pos, filters,
+			0, NULL) != NULL);
+
+	assert_true(lzma_str_to_filters("lzma2:dict=4096KiBs", &error_pos, filters,
+			0, NULL) != NULL);
+
+	// Test option that cannot have multiplier modifier.
+	assert_true(lzma_str_to_filters("lzma2:pb=1k", &error_pos, filters,
+			0, NULL) != NULL);
+
+	// Test option value too large.
+	assert_true(lzma_str_to_filters("lzma2:dict=4096GiB", &error_pos, filters,
+			0, NULL) != NULL);
+
+	// Test valid uses of multiplier modifiers (k,m,g).
+	assert_true(lzma_str_to_filters("lzma2:dict=4096KiB", &error_pos, filters,
+			0, NULL) == NULL);
+
+	assert_uint_eq(filters[0].id, LZMA_FILTER_LZMA2);
+	assert_uint_eq(filters[1].id, LZMA_VLI_UNKNOWN);
+
+	opts = filters[0].options;
+	assert_uint_eq(opts->dict_size, 4096 << 10);
+
+	lzma_filters_free(filters, NULL);
+
+	assert_true(lzma_str_to_filters("lzma2:dict=40Mi", &error_pos, filters,
+			0, NULL) == NULL);
+
+	assert_uint_eq(filters[0].id, LZMA_FILTER_LZMA2);
+	assert_uint_eq(filters[1].id, LZMA_VLI_UNKNOWN);
+
+	opts = filters[0].options;
+	assert_uint_eq(opts->dict_size, 40 << 20);
+
+	lzma_filters_free(filters, NULL);
+
+	assert_true(lzma_str_to_filters("lzma2:dict=1g", &error_pos, filters,
+			0, NULL) == NULL);
+
+	assert_uint_eq(filters[0].id, LZMA_FILTER_LZMA2);
+	assert_uint_eq(filters[1].id, LZMA_VLI_UNKNOWN);
+
+	opts = filters[0].options;
+	assert_uint_eq(opts->dict_size, 1 << 30);
+
+	lzma_filters_free(filters, NULL);
+}
+
+
+static void
+test_lzma_str_from_filters(void)
+{
+	lzma_filter filters[LZMA_FILTERS_MAX];
+	filters[0].id = LZMA_VLI_UNKNOWN;
+
+	char *output_str = NULL;
+
+	// Test basic NULL inputs.
+	assert_lzma_ret(lzma_str_from_filters(NULL, filters, 0, NULL),
+			LZMA_PROG_ERROR);
+
+	assert_lzma_ret(lzma_str_from_filters(&output_str, NULL, 0, NULL),
+			LZMA_PROG_ERROR);
+
+	// Test with empty filters array.
+	assert_lzma_ret(lzma_str_from_filters(&output_str, filters, 0, NULL),
+			LZMA_OPTIONS_ERROR);
+
+	// Create a simple filter array only containing an LZMA2 Filter.
+	assert_true(lzma_str_to_filters("lzma2", NULL, filters, 0, NULL)
+			== NULL);
+
+	// Test with bad flags.
+	assert_lzma_ret(lzma_str_from_filters(&output_str, filters,
+			LZMA_STR_ALL_FILTERS, NULL), LZMA_OPTIONS_ERROR);
+
+	assert_lzma_ret(lzma_str_from_filters(&output_str, filters,
+			LZMA_STR_NO_VALIDATION, NULL), LZMA_OPTIONS_ERROR);
+
+	// Test with no flags.
+	assert_lzma_ret(lzma_str_from_filters(&output_str, filters, 0, NULL),
+			LZMA_OK);
+
+	assert_str_eq(output_str, "lzma2");
+	free(output_str);
+
+	// Test LZMA_STR_ENCODER flag.
+	// Only the the return value is checked since the actual string
+	// may change in the future (even though it is unlikely).
+	// The order of options or the inclusion of new options could
+	// cause a change in output, so we will avoid hardcoding an
+	// expected result.
+	assert_lzma_ret(lzma_str_from_filters(&output_str, filters,
+			LZMA_STR_ENCODER, NULL), LZMA_OK);
+	free(output_str);
+
+	// Test LZMA_STR_DECODER flag.
+	assert_lzma_ret(lzma_str_from_filters(&output_str, filters,
+			LZMA_STR_DECODER, NULL), LZMA_OK);
+	free(output_str);
+
+	// Test LZMA_STR_GETOPT_LONG flag.
+	assert_lzma_ret(lzma_str_from_filters(&output_str, filters,
+			LZMA_STR_GETOPT_LONG, NULL), LZMA_OK);
+	free(output_str);
+
+	// Test LZMA_STR_NO_SPACES flag.
+	assert_lzma_ret(lzma_str_from_filters(&output_str, filters,
+			LZMA_STR_NO_SPACES, NULL), LZMA_OK);
+
+	// Check to be sure there are no spaces.
+	assert_true(strchr(output_str, ' ') == NULL);
+
+	free(output_str);
+
+	lzma_filters_free(filters, NULL);
+
+#if defined(HAVE_ENCODER_X86) || defined(HAVE_DECODER_X86)
+	assert_true(lzma_str_to_filters("x86 lzma2", NULL, filters, 0, NULL)
+			== NULL);
+
+	assert_lzma_ret(lzma_str_from_filters(&output_str, filters, 0, NULL),
+			LZMA_OK);
+
+	assert_str_eq(output_str, "x86 lzma2");
+
+	free(output_str);
+
+	// Test setting BCJ option to NULL.
+	assert_false(filters[0].options == NULL);
+	free(filters[0].options);
+
+	filters[0].options = NULL;
+
+	assert_lzma_ret(lzma_str_from_filters(&output_str, filters, 0, NULL),
+			LZMA_OK);
+
+	assert_str_eq(output_str, "x86 lzma2");
+
+	lzma_filters_free(filters, NULL);
+	free(output_str);
+#endif
+
+	lzma_options_lzma opts;
+	assert_false(lzma_lzma_preset(&opts, LZMA_PRESET_DEFAULT));
+	// Test with too many Filters (array terminated after 4+ filters).
+	lzma_filter oversized_filters[LZMA_FILTERS_MAX + 2];
+
+	for (uint32_t i = 0; i < ARRAY_SIZE(oversized_filters) - 1; i++) {
+		oversized_filters[i].id = LZMA_FILTER_LZMA2;
+		oversized_filters[i].options = &opts;
+	}
+
+	oversized_filters[LZMA_FILTERS_MAX + 1].id = LZMA_VLI_UNKNOWN;
+	oversized_filters[LZMA_FILTERS_MAX + 1].options = NULL;
+
+	assert_lzma_ret(lzma_str_from_filters(&output_str, oversized_filters,
+			0, NULL), LZMA_OPTIONS_ERROR);
+
+	// Test with NULL filter options (when they cannot be NULL).
+	filters[0].id = LZMA_FILTER_LZMA2;
+	filters[0].options = NULL;
+	filters[1].id = LZMA_VLI_UNKNOWN;
+
+	assert_lzma_ret(lzma_str_from_filters(&output_str, filters,
+			LZMA_STR_ENCODER, NULL), LZMA_OPTIONS_ERROR);
+
+	// Test with bad Filter ID.
+	filters[0].id = LZMA_VLI_UNKNOWN - 1;
+	assert_lzma_ret(lzma_str_from_filters(&output_str, filters,
+			LZMA_STR_ENCODER, NULL), LZMA_OPTIONS_ERROR);
+}
+
+
+static const char supported_encoders[][9] = {
+	"lzma2",
+#ifdef HAVE_ENCODER_X86
+	"x86",
+#endif
+#ifdef HAVE_ENCODER_POWERPC
+	"powerpc",
+#endif
+#ifdef HAVE_ENCODER_IA64
+	"ia64",
+#endif
+#ifdef HAVE_ENCODER_ARM
+	"arm",
+#endif
+#ifdef HAVE_ENCODER_ARMTHUMB
+	"armthumb",
+#endif
+#ifdef HAVE_ENCODER_SPARC
+	"sparc",
+#endif
+#ifdef HAVE_ENCODER_ARM64
+	"arm64",
+#endif
+#ifdef HAVE_ENCODER_DELTA
+	"delta",
+#endif
+};
+
+static const char supported_decoders[][9] = {
+	"lzma2",
+#ifdef HAVE_DECODER_X86
+	"x86",
+#endif
+#ifdef HAVE_DECODER_POWERPC
+	"powerpc",
+#endif
+#ifdef HAVE_DECODER_IA64
+	"ia64",
+#endif
+#ifdef HAVE_DECODER_ARM
+	"arm",
+#endif
+#ifdef HAVE_DECODER_ARMTHUMB
+	"armthumb",
+#endif
+#ifdef HAVE_DECODER_SPARC
+	"sparc",
+#endif
+#ifdef HAVE_DECODER_ARM64
+	"arm64",
+#endif
+#ifdef HAVE_DECODER_DELTA
+	"delta",
+#endif
+};
+
+static const char supported_filters[][9] = {
+	"lzma2",
+#if defined(HAVE_ENCODER_X86) || defined(HAVE_DECODER_X86)
+	"x86",
+#endif
+#if defined(HAVE_ENCODER_POWERPC) || defined(HAVE_DECODER_POWERPC)
+	"powerpc",
+#endif
+#if defined(HAVE_ENCODER_IA64) || defined(HAVE_DECODER_IA64)
+	"ia64",
+#endif
+#if defined(HAVE_ENCODER_ARM) || defined(HAVE_DECODER_ARM)
+	"arm",
+#endif
+#if defined(HAVE_ENCODER_ARMTHUMB) || defined(HAVE_DECODER_ARMTHUMB)
+	"armthumb",
+#endif
+#if defined(HAVE_ENCODER_SPARC) || defined(HAVE_DECODER_SPARC)
+	"sparc",
+#endif
+#if defined(HAVE_ENCODER_ARM64) || defined(HAVE_DECODER_ARM64)
+	"arm64",
+#endif
+#if defined(HAVE_ENCODER_DELTA) || defined(HAVE_DECODER_DELTA)
+	"delta",
+#endif
+};
+
+
+static void
+test_lzma_str_list_filters(void)
+{
+	// Test with basic NULL inputs.
+	assert_lzma_ret(lzma_str_list_filters(NULL, LZMA_VLI_UNKNOWN, 0,
+			NULL), LZMA_PROG_ERROR);
+
+	char *str = NULL;
+
+	// Test with bad flags.
+	assert_lzma_ret(lzma_str_list_filters(&str, LZMA_VLI_UNKNOWN,
+			LZMA_STR_NO_VALIDATION , NULL), LZMA_OPTIONS_ERROR);
+
+	assert_lzma_ret(lzma_str_list_filters(&str, LZMA_VLI_UNKNOWN,
+			LZMA_STR_NO_SPACES, NULL), LZMA_OPTIONS_ERROR);
+
+	// Test with bad Filter ID.
+	assert_lzma_ret(lzma_str_list_filters(&str, LZMA_VLI_UNKNOWN - 1,
+			0, NULL), LZMA_OPTIONS_ERROR);
+
+	// Test LZMA_STR_ENCODER flag.
+	assert_lzma_ret(lzma_str_list_filters(&str, LZMA_VLI_UNKNOWN,
+			LZMA_STR_ENCODER, NULL), LZMA_OK);
+
+	for (uint32_t i = 0; i < ARRAY_SIZE(supported_encoders); i++)
+		assert_str_contains(str, supported_encoders[i]);
+
+	free(str);
+
+	// Test LZMA_STR_DECODER flag.
+	assert_lzma_ret(lzma_str_list_filters(&str, LZMA_VLI_UNKNOWN,
+			LZMA_STR_DECODER, NULL), LZMA_OK);
+
+	for (uint32_t i = 0; i < ARRAY_SIZE(supported_decoders); i++)
+		assert_str_contains(str, supported_decoders[i]);
+
+	free(str);
+
+	// Test LZMA_STR_GETOPT_LONG flag.
+	assert_lzma_ret(lzma_str_list_filters(&str, LZMA_VLI_UNKNOWN,
+			LZMA_STR_GETOPT_LONG, NULL), LZMA_OK);
+
+	free(str);
+
+	// Test LZMA_STR_ALL_FILTERS flag.
+	assert_lzma_ret(lzma_str_list_filters(&str, LZMA_VLI_UNKNOWN,
+			LZMA_STR_ALL_FILTERS, NULL), LZMA_OK);
+#if defined(HAVE_ENCODER_LZMA1) || defined(HAVE_DECODER_LZMA1)
+	// With the flag, the string should contain the LZMA1 Filter.
+	assert_str_contains(str, "lzma1");
+
+	free(str);
+
+	// If a non .xz filter is specified, it should still list the Filter.
+	assert_lzma_ret(lzma_str_list_filters(&str, LZMA_FILTER_LZMA1,
+			0, NULL), LZMA_OK);
+	assert_str_eq(str, "lzma1");
+#endif
+	free(str);
+
+	// Test with no flags.
+	assert_lzma_ret(lzma_str_list_filters(&str, LZMA_VLI_UNKNOWN,
+			0, NULL), LZMA_OK);
+
+	for (uint32_t i = 0; i < ARRAY_SIZE(supported_filters); i++)
+		assert_str_contains(str, supported_filters[i]);
+
+	assert_str_doesnt_contain(str, "lzma1");
+
+	free(str);
+
+	// Test providing a Filter ID.
+	assert_lzma_ret(lzma_str_list_filters(&str, LZMA_FILTER_LZMA2,
+			LZMA_STR_ALL_FILTERS, NULL), LZMA_OK);
+	assert_str_eq(str, "lzma2");
+
+	free(str);
+}
+
+
+extern int
+main(int argc, char **argv)
+{
+	tuktest_start(argc, argv);
+
+	tuktest_run(test_lzma_str_to_filters);
+	tuktest_run(test_lzma_str_from_filters);
+	tuktest_run(test_lzma_str_list_filters);
+
+	return tuktest_end();
+}