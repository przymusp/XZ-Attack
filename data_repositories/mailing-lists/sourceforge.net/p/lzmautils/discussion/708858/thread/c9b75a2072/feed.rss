<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Recent posts to Integration of xz-embedded librabry on RH850F1L</title><link>https://sourceforge.net/p/lzmautils/discussion/708858/thread/c9b75a2072/</link><description>Recent posts to Integration of xz-embedded librabry on RH850F1L</description><language>en</language><lastBuildDate>Wed, 25 Dec 2019 19:13:35 -0000</lastBuildDate><atom:link href="https://sourceforge.net/p/lzmautils/discussion/708858/thread/c9b75a2072/feed.rss" rel="self" type="application/rss+xml"></atom:link><item><title>Integration of xz-embedded librabry on RH850F1L</title><link>https://sourceforge.net/p/lzmautils/discussion/708858/thread/c9b75a2072/?limit=25#0c33</link><description>&lt;div class="markdown_content"&gt;&lt;p&gt;I'm not sure if I understand your question. It would help if you could explain what you are trying to achieve in your project.&lt;/p&gt;
&lt;p&gt;Conversion between a binary file and its hex representation isn't related to any XZ compression library. If you need both the uncompressed binary and its hexdump, I suggest you compress the binary to output.bin.xz and when you need output.hex you write some code to do the conversion to output.hex since going from bin to hex should be simpler than hex to bin. Perhaps this wasn't what you were asking though.&lt;/p&gt;
&lt;p&gt;If you wish to include output.xz as part of the firmware image to be stored in the flash memory (not RAM), you could, for example, convert output.xz to C code (or whatever programming language you use) and then you would have output.xz available in some flash memory address (so it wouldn't use any RAM). Perhaps this wasn't your question either.&lt;/p&gt;&lt;/div&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Lasse Collin</dc:creator><pubDate>Wed, 25 Dec 2019 19:13:35 -0000</pubDate><guid isPermaLink="false">https://sourceforge.net055aeb3ed2a752e7e6e025f3a57c95bdb1054624</guid></item><item><title>Integration of xz-embedded librabry on RH850F1L</title><link>https://sourceforge.net/p/lzmautils/discussion/708858/thread/c9b75a2072/?limit=25#c159</link><description>&lt;div class="markdown_content"&gt;&lt;p&gt;Hello Lasse ,&lt;/p&gt;
&lt;p&gt;Many thanks for your reply.&lt;/p&gt;
&lt;p&gt;I request you to answer the following queries :&lt;/p&gt;
&lt;p&gt;Given information : &lt;br/&gt;
For the same file &lt;strong&gt;&lt;em&gt;output&lt;/em&gt;&lt;/strong&gt; the following formats and respective sizes are mentioned&lt;br/&gt;
    Hex File Size : 361 KiB&lt;br/&gt;
    Bin File Size : 128 KiB&lt;br/&gt;
    XZ File size : 51 KiB&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Can I change the format of output.xz to output.hex or output.bin maintaining the compressed size and data and then decompress it back to the original file subsequently using the xz-embedded library.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;I want to change the format to output.hex or output.bin from output.xz(after compression done using the suggested options) as placing the compressed output.xz in the RAM is pretty tricky. If you have some suggestion please let me know.&lt;/p&gt;&lt;/div&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Shrikant Lahane</dc:creator><pubDate>Tue, 10 Dec 2019 09:18:06 -0000</pubDate><guid isPermaLink="false">https://sourceforge.net31999d443eeaa104ac65aa3b72c3a0db29bc1cf4</guid></item><item><title>Integration of xz-embedded librabry on RH850F1L</title><link>https://sourceforge.net/p/lzmautils/discussion/708858/thread/c9b75a2072/?limit=25#83c1</link><description>&lt;div class="markdown_content"&gt;&lt;p&gt;Sorry for the delay. I'm replying to both of your messages in this thread.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;I compressed a hex file using the following command on the terminal(PC : Windows 10) : xz -9 -e Filename.hex&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;The &lt;code&gt;-9&lt;/code&gt; means that the file is compressed using a 64 MiB dictionary. It also uses CRC64 for integrity checking while the basic config of XZ Embedded enables only CRC32. So you should add &lt;code&gt;-Ccrc32&lt;/code&gt; to your &lt;code&gt;xz&lt;/code&gt; command line.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;In addition to above file i copied the xzminidec.c to the same directory and compiled it with some changes made to it.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;The (the original or your modified) xzminidec.c uses &lt;code&gt;XZ_DYNALLOC&lt;/code&gt; as the operation mode. This means that it will dynamically allocate the dictionary when decompressing the file. Since the input file has been created with 64 MiB dictionary, it will try to allocate 64 MiB using &lt;code&gt;vmalloc&lt;/code&gt; which in xz_config.h is #defined as &lt;code&gt;malloc&lt;/code&gt;. In the other thread you said that you have 64 &lt;strong&gt;KiB&lt;/strong&gt; of RAM, so a 64 &lt;strong&gt;MiB&lt;/strong&gt; allocation obviously cannot work.&lt;/p&gt;
&lt;p&gt;However, the following indicates that the problem occurs before the dictionary allocation:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;In function "xz_dec_lzma2_create" in file xz_dec_lzma2.c&lt;br/&gt;
"struct xz_dec_lzma2 s = kmalloc(sizeof(s), GFP_KERNEL);"&lt;/p&gt;
&lt;p&gt;kmalloc returns NULL causing a goto error_lzma2&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;The xz_dec_lzma2 structure is about 28 KiB. If you cannot malloc that amount of memory, there are some alternatives depending on what exactly your use case is.&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;Can you please tell me how to integrate XZ-embedded withouth using the heap memory for malloc and free call made in the library ?&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;Assuming that you need only one decoder instance at a time, you can have a static &lt;code&gt;xz_dec&lt;/code&gt; and &lt;code&gt;xz_dec_lzma2&lt;/code&gt; structures and replace the matching &lt;code&gt;kmalloc&lt;/code&gt; calls with the addresses of these static structures. The obvious downside with this is that the statically-allocated memory isn't available for any other use, and I guess this might be unacceptable at least as long as &lt;code&gt;struct xz_dec_lzma2&lt;/code&gt; is 28 KiB.&lt;/p&gt;
&lt;p&gt;I have to know more details to help. Can you decompress the whole file at once, that is, is the file small enough to fit into RAM? If yes, use &lt;code&gt;XZ_SINGLE&lt;/code&gt; instead of &lt;code&gt;XZ_DYNALLOC&lt;/code&gt;. In single-call mode a separate dictionary buffer isn't needed and it's enough to figure out how to fit &lt;code&gt;struct xz_dec_lzma2&lt;/code&gt; into RAM. That is, in single-call mode it is fine to use a big dictionary like 64 MiB at compression time.&lt;/p&gt;
&lt;p&gt;If the file is too big to fit into RAM at once, then one must use multi-call decompressiong and small enough dictionary at compression time. The dictionary is allocated with &lt;code&gt;vmalloc&lt;/code&gt; which is also #defined as &lt;code&gt;malloc&lt;/code&gt; in xz_config.h. To avoid &lt;code&gt;malloc&lt;/code&gt;, this could be converted to static allocation too, but again I suspect it's not acceptable in practice. To use a small dictionary, compress with something like this:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;xz -Ccrc32 --lzma2=preset=9e,dict=16KiB Filename.hex&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Back to the size of &lt;code&gt;struct xz_dec_lzma2&lt;/code&gt;. It can be made smaller by restricting which LZMA2 options are supported. In xz_dec_lzma2.c there is a line:&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="ss"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;s&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="nv"&gt;lzma&lt;/span&gt;.&lt;span class="nv"&gt;lc&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="nv"&gt;s&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="nv"&gt;lzma&lt;/span&gt;.&lt;span class="nv"&gt;literal_pos_mask&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="ss"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Change it to test for 3 instead of 4. Then in xz_lzma2.h change &lt;code&gt;LITERAL_CODERS_MAX&lt;/code&gt; from &lt;code&gt;(1 &amp;lt;&amp;lt; 4)&lt;/code&gt; to &lt;code&gt;(1 &amp;lt;&amp;lt; 3)&lt;/code&gt;. These changes will reduce the memory usage by 12 KiB. However, if the input file was compressed with lc=4 (or the sum of lc + lp &amp;gt; 3; but often lp is 0), the decoder will think the file is corrupt. In &lt;code&gt;xz&lt;/code&gt; the default is lc=3 so most files will still decompress after this change.&lt;/p&gt;
&lt;p&gt;If you wish, you can use a smaller number than 3 to save more memory possibly at expense of compression ratio. Going to 2 would save 6 KiB more, making &lt;code&gt;xz_dec_lzma2&lt;/code&gt; about 10 KiB. With 1 you save 3 KiB (21 KiB total) and 0 1.5 KiB more (22.5 KiB total). But compressing with lc=0 results in bigger files. You need to test it with your files. For example, for lc=2:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;xz -Ccrc32 --lzma2=preset=9e,lc=2 Filename.hex&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Or with lc=2 and 16 KiB dictionary:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;xz -Ccrc32 --lzma2=preset=9e,dict=16KiB,lc=2 Filename.hex&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;As a bonus, assuming your files aren't huge, you can save 48 bytes of RAM (if I counted correctly) and also a tiny bit in code size by changing &lt;code&gt;vli_type&lt;/code&gt; from &lt;code&gt;uint64_t&lt;/code&gt; to &lt;code&gt;uint32_t&lt;/code&gt; in xz_stream.h. &lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;What are the various formats other than .xz that can be used by the decompression library. I have a hex file compressed to .xz file. I want to convert this .xz file again to hex file and then decompress it using the decompression library. How can this be done ?&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;XZ Embedded supports only a subset of .xz files. You can compress any binary data into .xz format. If a hex file means plain US-ASCII text file that contains hexdump of a binary file, it might compress slightly better if you could compress the binary file itself instead of its hexdump.&lt;/p&gt;&lt;/div&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Lasse Collin</dc:creator><pubDate>Mon, 02 Dec 2019 18:33:02 -0000</pubDate><guid isPermaLink="false">https://sourceforge.net3f0e08045bef40edbc9d73f40f7d799e6ff91be1</guid></item><item><title>Integration of xz-embedded librabry on RH850F1L</title><link>https://sourceforge.net/p/lzmautils/discussion/708858/thread/c9b75a2072/?limit=25#07cd</link><description>&lt;div class="markdown_content"&gt;&lt;p&gt;Hello Lasse Collin ,&lt;/p&gt;
&lt;p&gt;I would like to get support regarding the integration of xz-embedded librabry on RH850F1L. &lt;br/&gt;
I compressed a hex file using the following command on the terminal(PC : Windows 10) : &lt;br/&gt;
xz -9 -e &amp;lt;filename.hex&amp;gt;&amp;lt;/filename.hex&amp;gt;&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;I have followed the following steps : &lt;br/&gt;
Step 1 : &lt;br/&gt;
To embed the XZ decoder, copy the following files into a single&lt;br/&gt;
    directory in your source code tree:&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="nv"&gt;linux&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="k"&gt;include&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="nv"&gt;linux&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="nv"&gt;xz&lt;/span&gt;.&lt;span class="nv"&gt;h&lt;/span&gt;
    &lt;span class="nv"&gt;linux&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="nv"&gt;lib&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="nv"&gt;xz&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="nv"&gt;xz_crc32&lt;/span&gt;.&lt;span class="nv"&gt;c&lt;/span&gt;
    &lt;span class="nv"&gt;linux&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="nv"&gt;lib&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="nv"&gt;xz&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="nv"&gt;xz_dec_lzma2&lt;/span&gt;.&lt;span class="nv"&gt;c&lt;/span&gt;
    &lt;span class="nv"&gt;linux&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="nv"&gt;lib&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="nv"&gt;xz&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="nv"&gt;xz_dec_stream&lt;/span&gt;.&lt;span class="nv"&gt;c&lt;/span&gt;
    &lt;span class="nv"&gt;linux&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="nv"&gt;lib&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="nv"&gt;xz&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="nv"&gt;xz_lzma2&lt;/span&gt;.&lt;span class="nv"&gt;h&lt;/span&gt;
    &lt;span class="nv"&gt;linux&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="nv"&gt;lib&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="nv"&gt;xz&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="nv"&gt;xz_private&lt;/span&gt;.&lt;span class="nv"&gt;h&lt;/span&gt;
    &lt;span class="nv"&gt;linux&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="nv"&gt;lib&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="nv"&gt;xz&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="nv"&gt;xz_stream&lt;/span&gt;.&lt;span class="nv"&gt;h&lt;/span&gt;
    &lt;span class="nv"&gt;userspace&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="nv"&gt;xz_config&lt;/span&gt;.&lt;span class="nv"&gt;h&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;I have made a folder xz-embedded in which i pasted all the above mentioned files.&lt;br/&gt;
I have compiled them without defining CPPFLAGS and BCJ_CPPFLAGS .&lt;/p&gt;
&lt;p&gt;Step 2 : &lt;br/&gt;
In addition to above file i copied the xzminidec.c to the same directory and compiled it with some changes made to it. The file is attached for your kind perusal. &lt;br/&gt;
Basically, instead of using the standard I/O, I have used 2 file pointers fpin(points to  filename.hex.xz ) and fpout(points to filename.hex ).&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;Error observed : &lt;br/&gt;
&lt;strong&gt;xz_dec_init&lt;/strong&gt; returns a NULL causing &lt;strong&gt;memory allocation failed&lt;/strong&gt; error.&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;Root Cause :&lt;br/&gt;
In function &lt;strong&gt;"xz_dec_lzma2_create"&lt;/strong&gt; in file&lt;strong&gt; xz_dec_lzma2.c  &lt;/strong&gt;&lt;br/&gt;
&lt;strong&gt;"struct xz_dec_lzma2 &lt;em&gt;s = kmalloc(sizeof(&lt;/em&gt;s), GFP_KERNEL);"&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;kmalloc returns NULL causing a goto error_lzma2&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;I request you to give me a workaround.&lt;/p&gt;&lt;/div&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Shrikant Lahane</dc:creator><pubDate>Fri, 15 Nov 2019 06:58:05 -0000</pubDate><guid isPermaLink="false">https://sourceforge.net34329399cd46344daa44dc8eb88be05a8f14d2ce</guid></item></channel></rss>