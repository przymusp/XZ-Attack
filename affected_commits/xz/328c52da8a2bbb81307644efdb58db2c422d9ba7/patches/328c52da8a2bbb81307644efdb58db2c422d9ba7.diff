commit 328c52da8a2bbb81307644efdb58db2c422d9ba7
Author: Jia Tan <jiat0218@gmail.com>
Date:   Mon Feb 26 23:02:06 2024 +0800

    Build: Fix Linux Landlock feature test in Autotools and CMake builds.
    
    The previous Linux Landlock feature test assumed that having the
    linux/landlock.h header file was enough. The new feature tests also
    requires that prctl() and the required Landlock system calls are
    supported.

diff --git a/CMakeLists.txt b/CMakeLists.txt
index 76700591..d2b1af7a 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -1,2036 +1,2055 @@
 # SPDX-License-Identifier: 0BSD
 
 #############################################################################
 #
 # CMake support for building XZ Utils
 #
 # The complete CMake-based build hasn't been tested much yet and
 # thus it's still slightly experimental. Testing this especially
 # outside GNU/Linux and Windows would be great now.
 #
 # A few things are still missing compared to the Autotools-based build:
 #
 #   - A few tests aren't CMake compatible yet and thus aren't run!
 #
 #   - 32-bit x86 assembly code for CRC32 and CRC64 isn't used.
 #
 #   - External SHA-256 code isn't supported but it's disabled by
 #     default in the Autotools build too (--enable-external-sha256).
 #
 #   - Extra compiler warning flags aren't added by default.
 #
 # About CMAKE_BUILD_TYPE:
 #
 #   - CMake's standard choices are fine to use for production builds,
 #     including "Release" and "RelWithDebInfo".
 #
 #     NOTE: While "Release" uses -O3 by default with some compilers,
 #     this file overrides -O3 to -O2 for "Release" builds if
 #     CMAKE_C_FLAGS_RELEASE is not defined by the user. At least
 #     with GCC and Clang/LLVM, -O3 doesn't seem useful for this
 #     package as it can result in bigger binaries without any
 #     improvement in speed compared to -O2.
 #
 #   - Empty value (the default) is handled slightly specially: It
 #     adds -DNDEBUG to disable debugging code (assert() and a few
 #     other things). No optimization flags are added so an empty
 #     CMAKE_BUILD_TYPE is an easy way to build with whatever
 #     optimization flags one wants, and so this method is also
 #     suitable for production builds.
 #
 #     If debugging is wanted when using empty CMAKE_BUILD_TYPE,
 #     include -UNDEBUG in the CFLAGS environment variable or
 #     in the CMAKE_C_FLAGS CMake variable to override -DNDEBUG.
 #     With empty CMAKE_BUILD_TYPE, the -UNDEBUG option will go
 #     after the -DNDEBUG option on the compiler command line and
 #     thus NDEBUG will be undefined.
 #
 #   - Non-standard build types like "None" aren't treated specially
 #     and thus won't have -DNEBUG. Such non-standard build types
 #     SHOULD BE AVOIDED FOR PRODUCTION BUILDS. Or at least one
 #     should remember to add -DNDEBUG.
 #
 # If building from xz.git instead of a release tarball, consider
 # the following *before* running cmake:
 #
 #   - To get translated messages, install GNU gettext tools (the
 #     command msgfmt is needed). Alternatively disable translations
 #     by setting ENABLE_NLS=OFF.
 #
 #   - To get translated man pages, run po4a/update-po which requires
 #     the po4a tool. The build works without this step too.
 #
 #   - To get Doxygen-generated liblzma API docs in HTML format,
 #     run doxygen/update-doxygen which requires the doxygen tool.
 #     The build works without this step too.
 #
 # This file provides the following installation components (if you only
 # need liblzma, install only its components!):
 #   - liblzma_Runtime (shared library only)
 #   - liblzma_Development
 #   - liblzma_Documentation (examples and Doxygen-generated API docs as HTML)
 #   - xz_Runtime (xz, the symlinks, and possibly translation files)
 #   - xz_Documentation (xz man pages and the symlinks)
 #   - xzdec_Runtime
 #   - xzdec_Documentation (xzdec *and* lzmadec man pages)
 #   - lzmadec_Runtime
 #   - lzmainfo_Runtime
 #   - lzmainfo_Documentation (lzmainfo man pages)
 #   - scripts_Runtime (xzdiff, xzgrep, xzless, xzmore)
 #   - scripts_Documentation (their man pages)
 #   - Documentation (generic docs like README and licenses)
 #
 # To find the target liblzma::liblzma from other packages, use the CONFIG
 # option with find_package() to avoid a conflict with the FindLibLZMA module
 # with case-insensitive file systems. For example, to require liblzma 5.2.5
 # or a newer compatible version:
 #
 #     find_package(liblzma 5.2.5 REQUIRED CONFIG)
 #     target_link_libraries(my_application liblzma::liblzma)
 #
 #############################################################################
 #
 # Author: Lasse Collin
 #
 #############################################################################
 
 # NOTE: Translation support is disabled with CMake older than 3.20.
 cmake_minimum_required(VERSION 3.14...3.28 FATAL_ERROR)
 
 include(CMakePushCheckState)
 include(CheckIncludeFile)
 include(CheckSymbolExists)
 include(CheckStructHasMember)
 include(CheckCSourceCompiles)
 include(cmake/tuklib_large_file_support.cmake)
 include(cmake/tuklib_integer.cmake)
 include(cmake/tuklib_cpucores.cmake)
 include(cmake/tuklib_physmem.cmake)
 include(cmake/tuklib_progname.cmake)
 include(cmake/tuklib_mbstr.cmake)
 
 set(PACKAGE_NAME "XZ Utils")
 set(PACKAGE_BUGREPORT "xz@tukaani.org")
 set(PACKAGE_URL "https://xz.tukaani.org/xz-utils/")
 
 # Get the package version from version.h into PACKAGE_VERSION variable.
 file(READ src/liblzma/api/lzma/version.h PACKAGE_VERSION)
 string(REGEX REPLACE
 "^.*\n\
 #define LZMA_VERSION_MAJOR ([0-9]+)\n\
 .*\
 #define LZMA_VERSION_MINOR ([0-9]+)\n\
 .*\
 #define LZMA_VERSION_PATCH ([0-9]+)\n\
 .*$"
        "\\1.\\2.\\3" PACKAGE_VERSION "${PACKAGE_VERSION}")
 
 # With several compilers, CMAKE_BUILD_TYPE=Release uses -O3 optimization
 # which results in bigger code without a clear difference in speed. If
 # no user-defined CMAKE_C_FLAGS_RELEASE is present, override -O3 to -O2
 # to make it possible to recommend CMAKE_BUILD_TYPE=Release.
 if(NOT DEFINED CMAKE_C_FLAGS_RELEASE)
     set(OVERRIDE_O3_IN_C_FLAGS_RELEASE ON)
 endif()
 
 # Among other things, this gives us variables xz_VERSION and xz_VERSION_MAJOR.
 project(xz VERSION "${PACKAGE_VERSION}" LANGUAGES C)
 
 if(OVERRIDE_O3_IN_C_FLAGS_RELEASE)
     # Looking at CMake's source, there aren't any _FLAGS_RELEASE_INIT
     # entries where "-O3" would appear as part of some other option,
     # thus a simple search and replace should be fine.
     string(REPLACE -O3 -O2 CMAKE_C_FLAGS_RELEASE "${CMAKE_C_FLAGS_RELEASE}")
 
     # Update the cache value while keeping its docstring unchanged.
     set_property(CACHE CMAKE_C_FLAGS_RELEASE
                  PROPERTY VALUE "${CMAKE_C_FLAGS_RELEASE}")
 endif()
 
 # We need a compiler that supports enough C99 or newer (variable-length arrays
 # aren't needed, those are optional in C17). Setting CMAKE_C_STANDARD here
 # makes it the default for all targets. It doesn't affect the INTERFACE so
 # liblzma::liblzma won't end up with INTERFACE_COMPILE_FEATURES "c_std_99"
 # (the API headers are C89 and C++ compatible).
 set(CMAKE_C_STANDARD 99)
 set(CMAKE_C_STANDARD_REQUIRED ON)
 
 # On Apple OSes, don't build executables as bundles:
 set(CMAKE_MACOSX_BUNDLE OFF)
 
 # Set CMAKE_INSTALL_LIBDIR and friends. This needs to be done before
 # the LOCALEDIR_DEFINITION workaround below.
 include(GNUInstallDirs)
 
 # windres from GNU binutils can be tricky with command line arguments
 # that contain spaces or other funny characters. Unfortunately we need
 # a space in PACKAGE_NAME. Using \x20 to encode the US-ASCII space seems
 # to work in both cmd.exe and /bin/sh.
 #
 # However, even \x20 isn't enough in all situations, resulting in
 # "syntax error" from windres. Using --use-temp-file prevents windres
 # from using popen() and this seems to fix the problem.
 #
 # llvm-windres from Clang/LLVM 16.0.6 and older: The \x20 results
 # in "XZx20Utils" in the compiled binary. The option --use-temp-file
 # makes no difference.
 #
 # llvm-windres 17.0.0 and later: It emulates GNU windres more accurately, so
 # the workarounds used with GNU windres must be used with llvm-windres too.
 #
 # CMake 3.27 doesn't have CMAKE_RC_COMPILER_ID so we rely on
 # CMAKE_C_COMPILER_ID.
 if((MINGW OR CYGWIN OR MSYS) AND (
         NOT CMAKE_C_COMPILER_ID STREQUAL "Clang" OR
         CMAKE_C_COMPILER_VERSION VERSION_GREATER_EQUAL "17"))
     # Use workarounds with GNU windres and llvm-windres >= 17.0.0. The \x20
     # in PACKAGE_NAME_DEFINITION works with gcc and clang too so we don't need
     # to worry how to pass different flags to windres and the C compiler.
     # Keep the original PACKAGE_NAME intact for generation of liblzma.pc.
     string(APPEND CMAKE_RC_FLAGS " --use-temp-file")
     string(REPLACE " " "\\x20" PACKAGE_NAME_DEFINITION "${PACKAGE_NAME}")
 
     # Use octal because "Program Files" would become \x20F.
     string(REPLACE " " "\\040" LOCALEDIR_DEFINITION
            "${CMAKE_INSTALL_FULL_LOCALEDIR}")
 else()
     # Elsewhere a space is safe. This also keeps things compatible with
     # EBCDIC in case CMake-based build is ever done on such a system.
     set(PACKAGE_NAME_DEFINITION "${PACKAGE_NAME}")
     set(LOCALEDIR_DEFINITION "${CMAKE_INSTALL_FULL_LOCALEDIR}")
 endif()
 
 # Definitions common to all targets:
 add_compile_definitions(
     # Package info:
     PACKAGE_NAME="${PACKAGE_NAME_DEFINITION}"
     PACKAGE_BUGREPORT="${PACKAGE_BUGREPORT}"
     PACKAGE_URL="${PACKAGE_URL}"
 
     # Standard headers and types are available:
     HAVE_STDBOOL_H
     HAVE__BOOL
     HAVE_STDINT_H
     HAVE_INTTYPES_H
 
     # Always enable CRC32 since liblzma should never build without it.
     HAVE_CHECK_CRC32
 
     # Disable assert() checks when no build type has been specified. Non-empty
     # build types like "Release" and "Debug" handle this by default.
     $<$<CONFIG:>:NDEBUG>
 )
 
 
 ######################
 # System definitions #
 ######################
 
 # _GNU_SOURCE and such definitions. This specific macro is special since
 # it also adds the definitions to CMAKE_REQUIRED_DEFINITIONS.
 tuklib_use_system_extensions(ALL)
 
 # Check for large file support. It's required on some 32-bit platforms and
 # even on 64-bit MinGW-w64 to get 64-bit off_t. This can be forced off on
 # the CMake command line if needed: -DLARGE_FILE_SUPPORT=OFF
 tuklib_large_file_support(ALL)
 
 # This is needed by liblzma and xz.
 tuklib_integer(ALL)
 
 # This is used for liblzma.pc generation to add -lrt if needed.
 set(LIBS)
 
 # Check for clock_gettime(). Do this before checking for threading so
 # that we know there if CLOCK_MONOTONIC is available.
 check_symbol_exists(clock_gettime time.h HAVE_CLOCK_GETTIME)
 
 if(NOT HAVE_CLOCK_GETTIME)
     # With glibc <= 2.17 or Solaris 10 this needs librt.
     # Add librt for the next check for HAVE_CLOCK_GETTIME. If it is
     # found after including the library, we know that librt is required.
     list(INSERT CMAKE_REQUIRED_LIBRARIES 0 rt)
     check_symbol_exists(clock_gettime time.h HAVE_CLOCK_GETTIME_LIBRT)
 
     # If it was found now, add librt to all targets and keep it in
     # CMAKE_REQUIRED_LIBRARIES for further tests too.
     if(HAVE_CLOCK_GETTIME_LIBRT)
         link_libraries(rt)
         set(LIBS "-lrt") # For liblzma.pc
     else()
         list(REMOVE_AT CMAKE_REQUIRED_LIBRARIES 0)
     endif()
 endif()
 
 if(HAVE_CLOCK_GETTIME OR HAVE_CLOCK_GETTIME_LIBRT)
     add_compile_definitions(HAVE_CLOCK_GETTIME)
 
     # Check if CLOCK_MONOTONIC is available for clock_gettime().
     check_symbol_exists(CLOCK_MONOTONIC time.h HAVE_CLOCK_MONOTONIC)
     tuklib_add_definition_if(ALL HAVE_CLOCK_MONOTONIC)
 endif()
 
 # Translation support requires CMake 3.20 because it added the Intl::Intl
 # target so we don't need to play with the individual variables.
 #
 # The definition ENABLE_NLS is added only to those targets that use it, thus
 # it's not done here. (xz has translations, xzdec doesn't.)
 if(CMAKE_VERSION VERSION_GREATER_EQUAL "3.20")
     find_package(Intl)
     find_package(Gettext)
     if(Intl_FOUND)
         option(ENABLE_NLS "Native Language Support (translated messages)" ON)
 
         # The *installed* name of the translation files is "xz.mo".
         set(TRANSLATION_DOMAIN "xz")
     endif()
 endif()
 
 # Options for new enough GCC or Clang on any arch or operating system:
 if(CMAKE_C_COMPILER_ID MATCHES GNU|Clang)
     # configure.ac has a long list but it won't be copied here:
     add_compile_options(-Wall -Wextra)
 endif()
 
 
 #############################################################################
 # liblzma
 #############################################################################
 
 option(BUILD_SHARED_LIBS "Build liblzma as a shared library instead of static")
 
 add_library(liblzma
     src/common/mythread.h
     src/common/sysdefs.h
     src/common/tuklib_common.h
     src/common/tuklib_config.h
     src/common/tuklib_integer.h
     src/common/tuklib_physmem.c
     src/common/tuklib_physmem.h
     src/liblzma/api/lzma.h
     src/liblzma/api/lzma/base.h
     src/liblzma/api/lzma/bcj.h
     src/liblzma/api/lzma/block.h
     src/liblzma/api/lzma/check.h
     src/liblzma/api/lzma/container.h
     src/liblzma/api/lzma/delta.h
     src/liblzma/api/lzma/filter.h
     src/liblzma/api/lzma/hardware.h
     src/liblzma/api/lzma/index.h
     src/liblzma/api/lzma/index_hash.h
     src/liblzma/api/lzma/lzma12.h
     src/liblzma/api/lzma/stream_flags.h
     src/liblzma/api/lzma/version.h
     src/liblzma/api/lzma/vli.h
     src/liblzma/check/check.c
     src/liblzma/check/check.h
     src/liblzma/check/crc_common.h
     src/liblzma/check/crc_x86_clmul.h
     src/liblzma/check/crc32_arm64.h
     src/liblzma/common/block_util.c
     src/liblzma/common/common.c
     src/liblzma/common/common.h
     src/liblzma/common/easy_preset.c
     src/liblzma/common/easy_preset.h
     src/liblzma/common/filter_common.c
     src/liblzma/common/filter_common.h
     src/liblzma/common/hardware_physmem.c
     src/liblzma/common/index.c
     src/liblzma/common/index.h
     src/liblzma/common/memcmplen.h
     src/liblzma/common/stream_flags_common.c
     src/liblzma/common/stream_flags_common.h
     src/liblzma/common/string_conversion.c
     src/liblzma/common/vli_size.c
 )
 
 target_include_directories(liblzma PRIVATE
     src/liblzma/api
     src/liblzma/common
     src/liblzma/check
     src/liblzma/lz
     src/liblzma/rangecoder
     src/liblzma/lzma
     src/liblzma/delta
     src/liblzma/simple
     src/common
 )
 
 
 ######################
 # Size optimizations #
 ######################
 
 option(ENABLE_SMALL "Reduce code size at expense of speed. \
 This may be useful together with CMAKE_BUILD_TYPE=MinSizeRel.")
 
 if(ENABLE_SMALL)
     add_compile_definitions(HAVE_SMALL)
 endif()
 
 
 ##########
 # Checks #
 ##########
 
 set(ADDITIONAL_SUPPORTED_CHECKS crc64 sha256)
 
 set(ADDITIONAL_CHECK_TYPES "${ADDITIONAL_SUPPORTED_CHECKS}" CACHE STRING
     "Additional check types to support (crc32 is always built)")
 
 foreach(CHECK IN LISTS ADDITIONAL_CHECK_TYPES)
     if(NOT CHECK IN_LIST ADDITIONAL_SUPPORTED_CHECKS)
         message(FATAL_ERROR "'${CHECK}' is not a supported check type")
     endif()
 endforeach()
 
 if(ENABLE_SMALL)
     target_sources(liblzma PRIVATE src/liblzma/check/crc32_small.c)
 else()
     target_sources(liblzma PRIVATE
         src/liblzma/check/crc32_fast.c
         src/liblzma/check/crc32_table.c
         src/liblzma/check/crc32_table_be.h
         src/liblzma/check/crc32_table_le.h
     )
 endif()
 
 if("crc64" IN_LIST ADDITIONAL_CHECK_TYPES)
     add_compile_definitions("HAVE_CHECK_CRC64")
 
     if(ENABLE_SMALL)
         target_sources(liblzma PRIVATE src/liblzma/check/crc64_small.c)
     else()
         target_sources(liblzma PRIVATE
             src/liblzma/check/crc64_fast.c
             src/liblzma/check/crc64_table.c
             src/liblzma/check/crc64_table_be.h
             src/liblzma/check/crc64_table_le.h
         )
     endif()
 endif()
 
 if("sha256" IN_LIST ADDITIONAL_CHECK_TYPES)
     add_compile_definitions("HAVE_CHECK_SHA256")
     target_sources(liblzma PRIVATE src/liblzma/check/sha256.c)
 endif()
 
 
 #################
 # Match finders #
 #################
 
 set(SUPPORTED_MATCH_FINDERS hc3 hc4 bt2 bt3 bt4)
 
 set(MATCH_FINDERS "${SUPPORTED_MATCH_FINDERS}" CACHE STRING
     "Match finders to support (at least one is required for LZMA1 or LZMA2)")
 
 foreach(MF IN LISTS MATCH_FINDERS)
     if(MF IN_LIST SUPPORTED_MATCH_FINDERS)
         string(TOUPPER "${MF}" MF_UPPER)
         add_compile_definitions("HAVE_MF_${MF_UPPER}")
     else()
         message(FATAL_ERROR "'${MF}' is not a supported match finder")
     endif()
 endforeach()
 
 
 #############
 # Threading #
 #############
 
 # Supported threading methods:
 # ON    - autodetect the best threading method. The autodetection will
 #         prefer Windows threading (win95 or vista) over posix if both are
 #         available. vista threads will be used over win95 unless it is a
 #         32-bit build.
 # OFF   - Disable threading.
 # posix - Use posix threading (pthreads), or throw an error if not available.
 # win95 - Use Windows win95 threading, or throw an error if not available.
 # vista - Use Windows vista threading, or throw an error if not available.
 set(SUPPORTED_THREADING_METHODS ON OFF posix win95 vista)
 
 set(ENABLE_THREADS ON CACHE STRING
     "Threading method: Set to 'ON' to autodetect, 'OFF' to disable threading.")
 
 # Create dropdown in CMake GUI since only 1 threading method is possible
 # to select in a build.
 set_property(CACHE ENABLE_THREADS
              PROPERTY STRINGS "${SUPPORTED_THREADING_METHODS}")
 
 # This is a flag variable set when win95 threads are used. We must ensure
 # the combination of enable_small and win95 threads is not used without a
 # compiler supporting attribute __constructor__.
 set(USE_WIN95_THREADS OFF)
 
 # This is a flag variable set when posix threads (pthreads) are used.
 # It's needed when creating liblzma-config.cmake where dependency on
 # Threads::Threads is only needed with pthreads.
 set(USE_POSIX_THREADS OFF)
 
 if(NOT ENABLE_THREADS IN_LIST SUPPORTED_THREADING_METHODS)
     message(FATAL_ERROR "'${ENABLE_THREADS}' is not a supported "
                         "threading method")
 endif()
 
 if(ENABLE_THREADS)
     # Also set THREADS_PREFER_PTHREAD_FLAG since the flag has no effect
     # for Windows threading.
     set(THREADS_PREFER_PTHREAD_FLAG TRUE)
     find_package(Threads REQUIRED)
 
     # If both Windows and posix threading are available, prefer Windows.
     # Note that on Cygwin CMAKE_USE_WIN32_THREADS_INIT is false.
     if(CMAKE_USE_WIN32_THREADS_INIT AND NOT ENABLE_THREADS STREQUAL "posix")
         if(ENABLE_THREADS STREQUAL "win95"
                 OR (ENABLE_THREADS STREQUAL "ON"
                     AND CMAKE_SIZEOF_VOID_P EQUAL 4))
             # Use Windows 95 (and thus XP) compatible threads.
             # This avoids use of features that were added in
             # Windows Vista. This is used for 32-bit x86 builds for
             # compatibility reasons since it makes no measurable difference
             # in performance compared to Vista threads.
             set(USE_WIN95_THREADS ON)
             add_compile_definitions(MYTHREAD_WIN95)
         else()
             add_compile_definitions(MYTHREAD_VISTA)
         endif()
     elseif(CMAKE_USE_PTHREADS_INIT)
         if(ENABLE_THREADS STREQUAL "posix" OR ENABLE_THREADS STREQUAL "ON")
             # The threading library only needs to be explicitly linked
             # for posix threads, so this is needed for creating
             # liblzma-config.cmake later.
             set(USE_POSIX_THREADS ON)
 
             target_link_libraries(liblzma Threads::Threads)
             add_compile_definitions(MYTHREAD_POSIX)
 
             # Check if pthread_condattr_setclock() exists to
             # use CLOCK_MONOTONIC.
             if(HAVE_CLOCK_MONOTONIC)
                 list(INSERT CMAKE_REQUIRED_LIBRARIES 0
                      "${CMAKE_THREAD_LIBS_INIT}")
                 check_symbol_exists(pthread_condattr_setclock pthread.h
                                     HAVE_PTHREAD_CONDATTR_SETCLOCK)
                 tuklib_add_definition_if(ALL HAVE_PTHREAD_CONDATTR_SETCLOCK)
             endif()
         else()
             message(SEND_ERROR
                     "Windows threading method was requested but a compatible "
                     "library could not be found")
         endif()
     else()
         message(SEND_ERROR "No supported threading library found")
     endif()
 
     target_sources(liblzma PRIVATE
         src/common/tuklib_cpucores.c
         src/common/tuklib_cpucores.h
         src/liblzma/common/hardware_cputhreads.c
         src/liblzma/common/outqueue.c
         src/liblzma/common/outqueue.h
     )
 endif()
 
 
 ############
 # Encoders #
 ############
 
 set(SIMPLE_FILTERS
     x86
     arm
     armthumb
     arm64
     powerpc
     ia64
     sparc
     riscv
 )
 
 # The SUPPORTED_FILTERS are shared between Encoders and Decoders
 # since only lzip does not appear in both lists. lzip is a special
 # case anyway, so it is handled separately in the Decoders section.
 set(SUPPORTED_FILTERS
     lzma1
     lzma2
     delta
     "${SIMPLE_FILTERS}"
 )
 
 set(ENCODERS "${SUPPORTED_FILTERS}" CACHE STRING "Encoders to support")
 
 # If LZMA2 is enabled, then LZMA1 must also be enabled.
 if(NOT "lzma1" IN_LIST ENCODERS AND "lzma2" IN_LIST ENCODERS)
     message(FATAL_ERROR "LZMA2 encoder requires that LZMA1 is also enabled")
 endif()
 
 # If LZMA1 is enabled, then at least one match finder must be enabled.
 if(MATCH_FINDERS STREQUAL "" AND "lzma1" IN_LIST ENCODERS)
     message(FATAL_ERROR "At least 1 match finder is required for an "
                         "LZ-based encoder")
 endif()
 
 set(HAVE_DELTA_CODER OFF)
 set(SIMPLE_ENCODERS OFF)
 set(HAVE_ENCODERS OFF)
 
 foreach(ENCODER IN LISTS ENCODERS)
     if(ENCODER IN_LIST SUPPORTED_FILTERS)
         set(HAVE_ENCODERS ON)
 
         if(NOT SIMPLE_ENCODERS AND ENCODER IN_LIST SIMPLE_FILTERS)
             set(SIMPLE_ENCODERS ON)
         endif()
 
         string(TOUPPER "${ENCODER}" ENCODER_UPPER)
         add_compile_definitions("HAVE_ENCODER_${ENCODER_UPPER}")
     else()
         message(FATAL_ERROR "'${ENCODER}' is not a supported encoder")
     endif()
 endforeach()
 
 if(HAVE_ENCODERS)
     add_compile_definitions(HAVE_ENCODERS)
 
     target_sources(liblzma PRIVATE
         src/liblzma/common/alone_encoder.c
         src/liblzma/common/block_buffer_encoder.c
         src/liblzma/common/block_buffer_encoder.h
         src/liblzma/common/block_encoder.c
         src/liblzma/common/block_encoder.h
         src/liblzma/common/block_header_encoder.c
         src/liblzma/common/easy_buffer_encoder.c
         src/liblzma/common/easy_encoder.c
         src/liblzma/common/easy_encoder_memusage.c
         src/liblzma/common/filter_buffer_encoder.c
         src/liblzma/common/filter_encoder.c
         src/liblzma/common/filter_encoder.h
         src/liblzma/common/filter_flags_encoder.c
         src/liblzma/common/index_encoder.c
         src/liblzma/common/index_encoder.h
         src/liblzma/common/stream_buffer_encoder.c
         src/liblzma/common/stream_encoder.c
         src/liblzma/common/stream_flags_encoder.c
         src/liblzma/common/vli_encoder.c
     )
 
     if(ENABLE_THREADS)
         target_sources(liblzma PRIVATE
             src/liblzma/common/stream_encoder_mt.c
         )
     endif()
 
     if(SIMPLE_ENCODERS)
         target_sources(liblzma PRIVATE
             src/liblzma/simple/simple_encoder.c
             src/liblzma/simple/simple_encoder.h
         )
     endif()
 
     if("lzma1" IN_LIST ENCODERS)
         target_sources(liblzma PRIVATE
             src/liblzma/lzma/lzma_encoder.c
             src/liblzma/lzma/lzma_encoder.h
             src/liblzma/lzma/lzma_encoder_optimum_fast.c
             src/liblzma/lzma/lzma_encoder_optimum_normal.c
             src/liblzma/lzma/lzma_encoder_private.h
             src/liblzma/lzma/fastpos.h
             src/liblzma/lz/lz_encoder.c
             src/liblzma/lz/lz_encoder.h
             src/liblzma/lz/lz_encoder_hash.h
             src/liblzma/lz/lz_encoder_hash_table.h
             src/liblzma/lz/lz_encoder_mf.c
             src/liblzma/rangecoder/price.h
             src/liblzma/rangecoder/price_table.c
             src/liblzma/rangecoder/range_encoder.h
         )
 
         if(NOT ENABLE_SMALL)
             target_sources(liblzma PRIVATE src/liblzma/lzma/fastpos_table.c)
         endif()
     endif()
 
     if("lzma2" IN_LIST ENCODERS)
         target_sources(liblzma PRIVATE
             src/liblzma/lzma/lzma2_encoder.c
             src/liblzma/lzma/lzma2_encoder.h
         )
     endif()
 
     if("delta" IN_LIST ENCODERS)
         set(HAVE_DELTA_CODER ON)
         target_sources(liblzma PRIVATE
             src/liblzma/delta/delta_encoder.c
             src/liblzma/delta/delta_encoder.h
         )
     endif()
 endif()
 
 
 ############
 # Decoders #
 ############
 
 set(DECODERS "${SUPPORTED_FILTERS}" CACHE STRING "Decoders to support")
 
 set(SIMPLE_DECODERS OFF)
 set(HAVE_DECODERS OFF)
 
 foreach(DECODER IN LISTS DECODERS)
     if(DECODER IN_LIST SUPPORTED_FILTERS)
         set(HAVE_DECODERS ON)
 
         if(NOT SIMPLE_DECODERS AND DECODER IN_LIST SIMPLE_FILTERS)
             set(SIMPLE_DECODERS ON)
         endif()
 
         string(TOUPPER "${DECODER}" DECODER_UPPER)
         add_compile_definitions("HAVE_DECODER_${DECODER_UPPER}")
     else()
         message(FATAL_ERROR "'${DECODER}' is not a supported decoder")
     endif()
 endforeach()
 
 if(HAVE_DECODERS)
     add_compile_definitions(HAVE_DECODERS)
 
     target_sources(liblzma PRIVATE
         src/liblzma/common/alone_decoder.c
         src/liblzma/common/alone_decoder.h
         src/liblzma/common/auto_decoder.c
         src/liblzma/common/block_buffer_decoder.c
         src/liblzma/common/block_decoder.c
         src/liblzma/common/block_decoder.h
         src/liblzma/common/block_header_decoder.c
         src/liblzma/common/easy_decoder_memusage.c
         src/liblzma/common/file_info.c
         src/liblzma/common/filter_buffer_decoder.c
         src/liblzma/common/filter_decoder.c
         src/liblzma/common/filter_decoder.h
         src/liblzma/common/filter_flags_decoder.c
         src/liblzma/common/index_decoder.c
         src/liblzma/common/index_decoder.h
         src/liblzma/common/index_hash.c
         src/liblzma/common/stream_buffer_decoder.c
         src/liblzma/common/stream_decoder.c
         src/liblzma/common/stream_flags_decoder.c
         src/liblzma/common/stream_decoder.h
         src/liblzma/common/vli_decoder.c
     )
 
     if(ENABLE_THREADS)
         target_sources(liblzma PRIVATE
             src/liblzma/common/stream_decoder_mt.c
         )
     endif()
 
     if(SIMPLE_DECODERS)
         target_sources(liblzma PRIVATE
             src/liblzma/simple/simple_decoder.c
             src/liblzma/simple/simple_decoder.h
         )
     endif()
 
     if("lzma1" IN_LIST DECODERS)
         target_sources(liblzma PRIVATE
             src/liblzma/lzma/lzma_decoder.c
             src/liblzma/lzma/lzma_decoder.h
             src/liblzma/rangecoder/range_decoder.h
             src/liblzma/lz/lz_decoder.c
             src/liblzma/lz/lz_decoder.h
         )
     endif()
 
     if("lzma2" IN_LIST DECODERS)
         target_sources(liblzma PRIVATE
             src/liblzma/lzma/lzma2_decoder.c
             src/liblzma/lzma/lzma2_decoder.h
         )
     endif()
 
     if("delta" IN_LIST DECODERS)
         set(HAVE_DELTA_CODER ON)
         target_sources(liblzma PRIVATE
             src/liblzma/delta/delta_decoder.c
             src/liblzma/delta/delta_decoder.h
         )
     endif()
 endif()
 
 # Some sources must appear if the filter is configured as either
 # an encoder or decoder.
 if("lzma1" IN_LIST ENCODERS OR "lzma1" IN_LIST DECODERS)
     target_sources(liblzma PRIVATE
         src/liblzma/rangecoder/range_common.h
         src/liblzma/lzma/lzma_encoder_presets.c
         src/liblzma/lzma/lzma_common.h
     )
 endif()
 
 if(HAVE_DELTA_CODER)
     target_sources(liblzma PRIVATE
         src/liblzma/delta/delta_common.c
         src/liblzma/delta/delta_common.h
         src/liblzma/delta/delta_private.h
     )
 endif()
 
 if(SIMPLE_ENCODERS OR SIMPLE_DECODERS)
     target_sources(liblzma PRIVATE
         src/liblzma/simple/simple_coder.c
         src/liblzma/simple/simple_coder.h
         src/liblzma/simple/simple_private.h
     )
 endif()
 
 foreach(SIMPLE_CODER IN LISTS SIMPLE_FILTERS)
     if(SIMPLE_CODER IN_LIST ENCODERS OR SIMPLE_CODER IN_LIST DECODERS)
         target_sources(liblzma PRIVATE "src/liblzma/simple/${SIMPLE_CODER}.c")
     endif()
 endforeach()
 
 
 #############
 # MicroLZMA #
 #############
 
 option(MICROLZMA_ENCODER
        "MicroLZMA encoder (needed by specific applications only)" ON)
 
 option(MICROLZMA_DECODER
        "MicroLZMA decoder (needed by specific applications only)" ON)
 
 if(MICROLZMA_ENCODER)
     if(NOT "lzma1" IN_LIST ENCODERS)
         message(FATAL_ERROR "The LZMA1 encoder is required to support the "
                             "MicroLZMA encoder")
     endif()
 
     target_sources(liblzma PRIVATE src/liblzma/common/microlzma_encoder.c)
 endif()
 
 if(MICROLZMA_DECODER)
     if(NOT "lzma1" IN_LIST DECODERS)
         message(FATAL_ERROR "The LZMA1 decoder is required to support the "
                             "MicroLZMA decoder")
     endif()
 
     target_sources(liblzma PRIVATE src/liblzma/common/microlzma_decoder.c)
 endif()
 
 if (MICROLZMA_ENCODER OR MICROLZMA_DECODER)
     add_compile_definitions(HAVE_MICROLZMA)
 endif()
 
 
 #############################
 # lzip (.lz) format support #
 #############################
 
 option(LZIP_DECODER "Support lzip decoder" ON)
 
 if(LZIP_DECODER)
     # If lzip decoder support is requested, make sure LZMA1 decoder is enabled.
     if(NOT "lzma1" IN_LIST DECODERS)
         message(FATAL_ERROR "The LZMA1 decoder is required to support the "
                             "lzip decoder")
     endif()
 
     add_compile_definitions(HAVE_LZIP_DECODER)
 
     target_sources(liblzma PRIVATE
         src/liblzma/common/lzip_decoder.c
         src/liblzma/common/lzip_decoder.h
     )
 endif()
 
 
 ##############
 # Sandboxing #
 ##############
 
 # ON        Use sandboxing if a supported method is available in the OS.
 # OFF       Disable sandboxing.
 # capsicum  Require Capsicum (FreeBSD >= 10.2) and fail if not found.
 # pledge    Require pledge(2) (OpenBSD >= 5.9) and fail if not found.
 # landlock  Require Landlock (Linux >= 5.13) and fail if not found.
 set(SUPPORTED_SANDBOX_METHODS ON OFF capsicum pledge landlock)
 
 set(ENABLE_SANDBOX ON CACHE STRING
     "Sandboxing method to use in 'xz', 'xzdec', and 'lzmadec'")
 
 set_property(CACHE ENABLE_SANDBOX
                 PROPERTY STRINGS "${SUPPORTED_SANDBOX_METHODS}")
 
 if(NOT ENABLE_SANDBOX IN_LIST SUPPORTED_SANDBOX_METHODS)
     message(FATAL_ERROR "'${ENABLE_SANDBOX}' is not a supported "
                         "sandboxing method")
 endif()
 
 # When autodetecting, the search order is fixed and we must not find
 # more than one method.
 if(ENABLE_SANDBOX STREQUAL "OFF")
     set(SANDBOX_FOUND ON)
 else()
     set(SANDBOX_FOUND OFF)
 endif()
 
 # Since xz and xzdec can both use sandboxing, the compile definition needed
 # to use the sandbox must be added to both targets.
 set(SANDBOX_COMPILE_DEFINITION OFF)
 
 # Sandboxing: Capsicum
 if(NOT SANDBOX_FOUND AND ENABLE_SANDBOX MATCHES "^ON$|^capsicum$")
     check_symbol_exists(cap_rights_limit sys/capsicum.h
                         HAVE_CAP_RIGHTS_LIMIT)
     if(HAVE_CAP_RIGHTS_LIMIT)
         set(SANDBOX_COMPILE_DEFINITION "HAVE_CAP_RIGHTS_LIMIT")
         set(SANDBOX_FOUND ON)
     endif()
 endif()
 
 # Sandboxing: pledge(2)
 if(NOT SANDBOX_FOUND AND ENABLE_SANDBOX MATCHES "^ON$|^pledge$")
     check_symbol_exists(pledge unistd.h HAVE_PLEDGE)
     if(HAVE_PLEDGE)
         set(SANDBOX_COMPILE_DEFINITION "HAVE_PLEDGE")
         set(SANDBOX_FOUND ON)
     endif()
 endif()
 
 # Sandboxing: Landlock
 if(NOT SANDBOX_FOUND AND ENABLE_SANDBOX MATCHES "^ON$|^landlock$")
-    check_include_file(linux/landlock.h HAVE_LINUX_LANDLOCK_H)
+    # A compile check is done here because some systems have
+    # linux/landlock.h, but do not have the syscalls defined
+    # in order to actually use Linux Landlock.
+    check_c_source_compiles("
+        #include <linux/landlock.h>
+        #include <sys/syscall.h>
+        #include <sys/prctl.h>
+.
+        void my_sandbox(void)
+        {
+            (void)prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0);
+            (void)SYS_landlock_create_ruleset;
+            (void)SYS_landlock_restrict_self;
+            (void)LANDLOCK_CREATE_RULESET_VERSION;
+            return;
+        }
+
+        int main(void) { return 0; }
+        "
+    HAVE_LINUX_LANDLOCK)
 
-    if(HAVE_LINUX_LANDLOCK_H)
-        set(SANDBOX_COMPILE_DEFINITION "HAVE_LINUX_LANDLOCK_H")
+    if(HAVE_LINUX_LANDLOCK)
+        set(SANDBOX_COMPILE_DEFINITION "HAVE_LINUX_LANDLOCK")
         set(SANDBOX_FOUND ON)
 
         # Of our three sandbox methods, only Landlock is incompatible
         # with -fsanitize. FreeBSD 13.2 with Capsicum was tested with
         # -fsanitize=address,undefined and had no issues. OpenBSD (as
         # of version 7.4) has minimal support for process instrumentation.
         # OpenBSD does not distribute the additional libraries needed
         # (libasan, libubsan, etc.) with GCC or Clang needed for runtime
         # sanitization support and instead only support
         # -fsanitize-minimal-runtime for minimal undefined behavior
         # sanitization. This minimal support is compatible with our use
         # of the Pledge sandbox. So only Landlock will result in a
         # build that cannot compress or decompress a single file to
         # standard out.
         if(CMAKE_C_FLAGS MATCHES "-fsanitize=")
             message(SEND_ERROR
                     "CMAKE_C_FLAGS or the environment variable CFLAGS "
                     "contains '-fsanitize=' which is incompatible "
                     "with Landlock sandboxing. Use -DENABLE_SANDBOX=OFF "
                     "as an argument to 'cmake' when using '-fsanitize'.")
         endif()
     endif()
 endif()
 
 if(NOT SANDBOX_FOUND AND NOT ENABLE_SANDBOX MATCHES "^ON$|^OFF$")
     message(SEND_ERROR "ENABLE_SANDBOX=${ENABLE_SANDBOX} was used but "
                         "support for the sandboxing method wasn't found.")
 endif()
 
 ###
 
 # Put the tuklib functions under the lzma_ namespace.
 target_compile_definitions(liblzma PRIVATE TUKLIB_SYMBOL_PREFIX=lzma_)
 tuklib_cpucores(liblzma)
 tuklib_physmem(liblzma)
 
 # While liblzma can be built without tuklib_cpucores or tuklib_physmem
 # modules, the liblzma API functions lzma_cputhreads() and lzma_physmem()
 # will then be useless (which isn't too bad but still unfortunate). Since
 # I expect the CMake-based builds to be only used on systems that are
 # supported by these tuklib modules, problems with these tuklib modules
 # are considered a hard error for now. This hopefully helps to catch bugs
 # in the CMake versions of the tuklib checks.
 if(NOT TUKLIB_CPUCORES_FOUND OR NOT TUKLIB_PHYSMEM_FOUND)
     # Use SEND_ERROR instead of FATAL_ERROR. If someone reports a bug,
     # seeing the results of the remaining checks can be useful too.
     message(SEND_ERROR
             "tuklib_cpucores() or tuklib_physmem() failed. "
             "Unless you really are building for a system where these "
             "modules are not supported (unlikely), this is a bug in the "
             "included cmake/tuklib_*.cmake files that should be fixed. "
             "To build anyway, edit this CMakeLists.txt to ignore this error.")
 endif()
 
 # Check for __attribute__((__constructor__)) support.
 # This needs -Werror because some compilers just warn
 # about this being unsupported.
 cmake_push_check_state()
 set(CMAKE_REQUIRED_FLAGS "-Werror")
 check_c_source_compiles("
         __attribute__((__constructor__))
         static void my_constructor_func(void) { return; }
         int main(void) { return 0; }
     "
     HAVE_FUNC_ATTRIBUTE_CONSTRUCTOR)
 cmake_pop_check_state()
 tuklib_add_definition_if(liblzma HAVE_FUNC_ATTRIBUTE_CONSTRUCTOR)
 
 # The Win95 threading lacks a thread-safe one-time initialization function.
 # The one-time initialization is needed for crc32_small.c and crc64_small.c
 # create the CRC tables. So if small mode is enabled, the threading mode is
 # win95, and the compiler does not support attribute constructor, then we
 # would end up with a multithreaded build that is thread-unsafe. As a
 # result this configuration is not allowed.
 if(USE_WIN95_THREADS AND ENABLE_SMALL AND NOT HAVE_FUNC_ATTRIBUTE_CONSTRUCTOR)
     message(SEND_ERROR "Threading method win95 and ENABLE_SMALL "
                         "cannot be used at the same time with a compiler "
                         "that doesn't support "
                         "__attribute__((__constructor__))")
 endif()
 
 
 # Check for __attribute__((__ifunc__())) support.
 # Supported values for USE_ATTR_IFUNC:
 #
 # auto (default) - Detect ifunc support with a compile test.
 # ON             - Always enable ifunc.
 # OFF            - Disable ifunc usage.
 set(USE_ATTR_IFUNC "auto" CACHE STRING "Use __attribute__((__ifunc__())).")
 
 set(SUPPORTED_USE_ATTR_IFUNC auto ON OFF)
 
 if(NOT USE_ATTR_IFUNC IN_LIST SUPPORTED_USE_ATTR_IFUNC)
     message(FATAL_ERROR "'${USE_ATTR_IFUNC}' is not a supported value for"
                         "USE_ATTR_IFUNC")
 endif()
 
 # When USE_ATTR_IFUNC is 'auto', allow the use of __attribute__((__ifunc__()))
 # if compiler support is detected and we are building for GNU/Linux (glibc)
 # or FreeBSD. uClibc and musl don't support ifunc in their dynamic linkers
 # but some compilers still accept the attribute when compiling for these
 # C libraries, which results in broken binaries. That's why we need to
 # check which libc is being used.
 if(USE_ATTR_IFUNC STREQUAL "auto")
     cmake_push_check_state()
     set(CMAKE_REQUIRED_FLAGS "-Werror")
 
     check_c_source_compiles("
             /*
              * Force a compilation error when not using glibc on Linux
              * or if we are not using FreeBSD. uClibc will define
              * __GLIBC__ but does not support ifunc, so we must have
              * an extra check to disable with uClibc.
              */
             #if defined(__linux__)
             #   include <features.h>
             #   if !defined(__GLIBC__) || defined(__UCLIBC__)
             compile error
             #   endif
             #elif !defined(__FreeBSD__)
             compile error
             #endif
 
             static void func(void) { return; }
             static void (*resolve_func(void)) (void) { return func; }
             void func_ifunc(void)
                     __attribute__((__ifunc__(\"resolve_func\")));
             int main(void) { return 0; }
             /*
              * 'clang -Wall' incorrectly warns that resolve_func is
              * unused (-Wunused-function). Correct assembly output is
              * still produced. This problem exists at least in Clang
              * versions 4 to 17. The following silences the bogus warning:
              */
             void make_clang_quiet(void);
             void make_clang_quiet(void) { resolve_func()(); }
         "
         SYSTEM_SUPPORTS_IFUNC)
 
         cmake_pop_check_state()
 endif()
 
 if(USE_ATTR_IFUNC STREQUAL "ON" OR SYSTEM_SUPPORTS_IFUNC)
     tuklib_add_definitions(liblzma HAVE_FUNC_ATTRIBUTE_IFUNC)
 
     if(CMAKE_C_FLAGS MATCHES "-fsanitize=")
         message(SEND_ERROR
                 "CMAKE_C_FLAGS or the environment variable CFLAGS "
                 "contains '-fsanitize=' which is incompatible "
                 "with ifunc. Use -DUSE_ATTR_IFUNC=OFF "
                 "as an argument to 'cmake' when using '-fsanitize'.")
     endif()
 endif()
 
 # cpuid.h
 check_include_file(cpuid.h HAVE_CPUID_H)
 tuklib_add_definition_if(liblzma HAVE_CPUID_H)
 
 # immintrin.h:
 check_include_file(immintrin.h HAVE_IMMINTRIN_H)
 if(HAVE_IMMINTRIN_H)
     target_compile_definitions(liblzma PRIVATE HAVE_IMMINTRIN_H)
 
     # SSE2 intrinsics:
     check_c_source_compiles("
             #include <immintrin.h>
             int main(void)
             {
                 __m128i x = { 0 };
                 _mm_movemask_epi8(x);
                 return 0;
             }
         "
         HAVE__MM_MOVEMASK_EPI8)
     tuklib_add_definition_if(liblzma HAVE__MM_MOVEMASK_EPI8)
 
     # CLMUL intrinsic:
     option(ALLOW_CLMUL_CRC "Allow carryless multiplication for CRC \
 calculation if supported by the system" ON)
 
     if(ALLOW_CLMUL_CRC)
         check_c_source_compiles("
                 #include <immintrin.h>
                 #if defined(__e2k__) && __iset__ < 6
                 #   error
                 #endif
                 #if (defined(__GNUC__) || defined(__clang__)) \
                         && !defined(__EDG__)
                 __attribute__((__target__(\"ssse3,sse4.1,pclmul\")))
                 #endif
                 __m128i my_clmul(__m128i a)
                 {
                     const __m128i b = _mm_set_epi64x(1, 2);
                     return _mm_clmulepi64_si128(a, b, 0);
                 }
                 int main(void) { return 0; }
             "
             HAVE_USABLE_CLMUL)
         tuklib_add_definition_if(liblzma HAVE_USABLE_CLMUL)
     endif()
 endif()
 
 # ARM64 C Language Extensions define CRC32 functions in arm_acle.h.
 # These are supported by at least GCC and Clang which both need
 # __attribute__((__target__("+crc"))), unless the needed compiler flags
 # are used to support the CRC instruction.
 option(ALLOW_ARM64_CRC32 "Allow ARM64 CRC32 instruction if supported by \
 the system" ON)
 
 if(ALLOW_ARM64_CRC32)
     check_c_source_compiles("
             #include <stdint.h>
 
             #ifndef _MSC_VER
             #include <arm_acle.h>
             #endif
 
             #if (defined(__GNUC__) || defined(__clang__)) && !defined(__EDG__)
             __attribute__((__target__(\"+crc\")))
             #endif
             uint32_t my_crc(uint32_t a, uint64_t b)
             {
                 return __crc32d(a, b);
             }
             int main(void) { return 0; }
         "
         HAVE_ARM64_CRC32)
 
     if(HAVE_ARM64_CRC32)
         target_compile_definitions(liblzma PRIVATE HAVE_ARM64_CRC32)
 
         # Check for ARM64 CRC32 instruction runtime detection.
         # getauxval() is supported on Linux.
         check_symbol_exists(getauxval sys/auxv.h HAVE_GETAUXVAL)
         tuklib_add_definition_if(liblzma HAVE_GETAUXVAL)
 
         # elf_aux_info() is supported on FreeBSD.
         check_symbol_exists(elf_aux_info sys/auxv.h HAVE_ELF_AUX_INFO)
         tuklib_add_definition_if(liblzma HAVE_ELF_AUX_INFO)
 
         # sysctlbyname("hw.optional.armv8_crc32", ...) is supported on Darwin
         # (macOS, iOS, etc.). Note that sysctlbyname() is supported on FreeBSD,
         # NetBSD, and possibly others too but the string is specific to
         # Apple OSes. The C code is responsible for checking
         # defined(__APPLE__) before using
         # sysctlbyname("hw.optional.armv8_crc32", ...).
         check_symbol_exists(sysctlbyname sys/sysctl.h HAVE_SYSCTLBYNAME)
         tuklib_add_definition_if(liblzma HAVE_SYSCTLBYNAME)
     endif()
 endif()
 
 
 # Symbol visibility support:
 #
 # The C_VISIBILITY_PRESET property takes care of adding the compiler
 # option -fvisibility=hidden (or equivalent) if and only if it is supported.
 #
 # HAVE_VISIBILITY should always be defined to 0 or 1. It tells liblzma
 # if __attribute__((__visibility__("default")))
 # and __attribute__((__visibility__("hidden"))) are supported.
 # Those are useful only when the compiler supports -fvisibility=hidden
 # or such option so HAVE_VISIBILITY should be 1 only when both option and
 # the attribute support are present. HAVE_VISIBILITY is ignored on Windows
 # and Cygwin by the liblzma C code; __declspec(dllexport) is used instead.
 #
 # CMake's GenerateExportHeader module is too fancy since liblzma already
 # has the necessary macros. Instead, check CMake's internal variable
 # CMAKE_C_COMPILE_OPTIONS_VISIBILITY (it's the C-specific variant of
 # CMAKE_<LANG>_COMPILE_OPTIONS_VISIBILITY) which contains the compiler
 # command line option for visibility support. It's empty or unset when
 # visibility isn't supported. (It was added to CMake 2.8.12 in the commit
 # 0e9f4bc00c6b26f254e74063e4026ac33b786513 in 2013.) This way we don't
 # set HAVE_VISIBILITY to 1 when visibility isn't actually supported.
 if(BUILD_SHARED_LIBS AND CMAKE_C_COMPILE_OPTIONS_VISIBILITY)
     set_target_properties(liblzma PROPERTIES C_VISIBILITY_PRESET hidden)
     target_compile_definitions(liblzma PRIVATE HAVE_VISIBILITY=1)
 else()
     target_compile_definitions(liblzma PRIVATE HAVE_VISIBILITY=0)
 endif()
 
 if(WIN32)
     if(BUILD_SHARED_LIBS)
         # Add the Windows resource file for liblzma.dll.
         target_sources(liblzma PRIVATE src/liblzma/liblzma_w32res.rc)
 
         set_target_properties(liblzma PROPERTIES
             LINK_DEPENDS "${CMAKE_CURRENT_SOURCE_DIR}/src/common/common_w32res.rc"
         )
 
         # Export the public API symbols with __declspec(dllexport).
         target_compile_definitions(liblzma PRIVATE DLL_EXPORT)
 
         if(NOT MSVC)
             # Create a DEF file. The linker puts the ordinal numbers there
             # too so the output from the linker isn't our final file.
             target_link_options(liblzma PRIVATE
                                 "-Wl,--output-def,liblzma.def.in")
 
             # Remove the ordinal numbers from the DEF file so that
             # no one will create an import library that links by ordinal
             # instead of by name. We don't maintain a DEF file so the
             # ordinal numbers aren't stable.
             add_custom_command(TARGET liblzma POST_BUILD
                 COMMAND "${CMAKE_COMMAND}"
                     -DINPUT_FILE=liblzma.def.in
                     -DOUTPUT_FILE=liblzma.def
                     -P
                     "${CMAKE_CURRENT_SOURCE_DIR}/cmake/remove-ordinals.cmake"
                 BYPRODUCTS "liblzma.def"
                 VERBATIM)
         endif()
     else()
         # Disable __declspec(dllimport) when linking against static liblzma.
         target_compile_definitions(liblzma INTERFACE LZMA_API_STATIC)
     endif()
 elseif(BUILD_SHARED_LIBS AND CMAKE_SYSTEM_NAME STREQUAL "Linux" AND
        NOT CMAKE_SYSTEM_PROCESSOR MATCHES "[Mm]icro[Bb]laze")
     # GNU/Linux-specific symbol versioning for shared liblzma.
     # This includes a few extra compatibility symbols for RHEL/CentOS 7
     # which are pointless on non-glibc non-Linux systems.
     #
     # As a special case, GNU/Linux on MicroBlaze gets the generic
     # symbol versioning because GCC 12 doesn't support the __symver__
     # attribute on MicroBlaze. On Linux, CMAKE_SYSTEM_PROCESSOR comes
     # from "uname -m" for native builds (should be "microblaze") or from
     # the CMake toolchain file (not perfectly standardized but it very
     # likely has "microblaze" in lower case or mixed case somewhere in
     # the string).
     #
     # FIXME? Avoid symvers on Linux with non-glibc like musl?
     #
     # Note that adding link options doesn't affect static builds
     # but HAVE_SYMBOL_VERSIONS_LINUX must not be used with static builds
     # because it would put symbol versions into the static library which
     # can cause problems. It's clearer if all symver related things are
     # omitted when not building a shared library.
     #
     # NOTE: Set it explicitly to 1 to make it clear that versioning is
     # done unconditionally in the C files.
     target_compile_definitions(liblzma PRIVATE HAVE_SYMBOL_VERSIONS_LINUX=1)
     target_link_options(liblzma PRIVATE
         "-Wl,--version-script=${CMAKE_CURRENT_SOURCE_DIR}/src/liblzma/liblzma_linux.map"
     )
     set_target_properties(liblzma PROPERTIES
         LINK_DEPENDS "${CMAKE_CURRENT_SOURCE_DIR}/src/liblzma/liblzma_linux.map"
     )
 elseif(BUILD_SHARED_LIBS AND (CMAKE_SYSTEM_NAME STREQUAL "FreeBSD" OR
                               CMAKE_SYSTEM_NAME STREQUAL "Linux"))
     # Generic symbol versioning for shared liblzma is used on FreeBSD and
     # also on GNU/Linux on MicroBlaze.
     target_link_options(liblzma PRIVATE
         "-Wl,--version-script=${CMAKE_CURRENT_SOURCE_DIR}/src/liblzma/liblzma_generic.map"
     )
     set_target_properties(liblzma PROPERTIES
         LINK_DEPENDS "${CMAKE_CURRENT_SOURCE_DIR}/src/liblzma/liblzma_generic.map"
     )
 endif()
 
 set_target_properties(liblzma PROPERTIES
     # At least for now the package versioning matches the rules used for
     # shared library versioning (excluding development releases) so it is
     # fine to use the package version here.
     SOVERSION "${xz_VERSION_MAJOR}"
     VERSION "${xz_VERSION}"
 
     # It's liblzma.so or liblzma.dll, not libliblzma.so or lzma.dll.
     # Avoid the name lzma.dll because it would conflict with LZMA SDK.
     PREFIX ""
     IMPORT_PREFIX ""
 )
 
 # Create liblzma-config-version.cmake.
 #
 # FIXME: SameMajorVersion is correct for stable releases but it is wrong
 # for development releases where each release may have incompatible changes.
 include(CMakePackageConfigHelpers)
 write_basic_package_version_file(
     "${CMAKE_CURRENT_BINARY_DIR}/liblzma-config-version.cmake"
     VERSION "${liblzma_VERSION}"
     COMPATIBILITY SameMajorVersion)
 
 # Create liblzma-config.cmake. We use this spelling instead of
 # liblzmaConfig.cmake to make find_package work in case insensitive
 # manner even with case sensitive file systems. This gives more consistent
 # behavior between operating systems. This optionally includes a dependency
 # on a threading library, so the contents are created in two separate parts.
 # The "second half" is always needed, so create it first.
 set(LZMA_CONFIG_CONTENTS
 "include(\"\${CMAKE_CURRENT_LIST_DIR}/liblzma-targets.cmake\")
 
 if(NOT TARGET LibLZMA::LibLZMA)
     # Be compatible with the spelling used by the FindLibLZMA module. This
     # doesn't use ALIAS because it would make CMake resolve LibLZMA::LibLZMA
     # to liblzma::liblzma instead of keeping the original spelling. Keeping
     # the original spelling is important for good FindLibLZMA compatibility.
     add_library(LibLZMA::LibLZMA INTERFACE IMPORTED)
     set_target_properties(LibLZMA::LibLZMA PROPERTIES
                           INTERFACE_LINK_LIBRARIES liblzma::liblzma)
 endif()
 ")
 
 if(USE_POSIX_THREADS)
     set(LZMA_CONFIG_CONTENTS
 "include(CMakeFindDependencyMacro)
 set(THREADS_PREFER_PTHREAD_FLAG TRUE)
 find_dependency(Threads)
 
 ${LZMA_CONFIG_CONTENTS}
 ")
 endif()
 
 file(WRITE "${CMAKE_CURRENT_BINARY_DIR}/liblzma-config.cmake"
         "${LZMA_CONFIG_CONTENTS}")
 
 # Create liblzma.pc.
 set(prefix "${CMAKE_INSTALL_PREFIX}")
 set(exec_prefix "${CMAKE_INSTALL_PREFIX}")
 set(libdir "${CMAKE_INSTALL_FULL_LIBDIR}")
 set(includedir "${CMAKE_INSTALL_FULL_INCLUDEDIR}")
 set(PTHREAD_CFLAGS "${CMAKE_THREAD_LIBS_INIT}")
 configure_file(src/liblzma/liblzma.pc.in liblzma.pc
                @ONLY
                NEWLINE_STYLE LF)
 
 # Install the library binary. The INCLUDES specifies the include path that
 # is exported for other projects to use but it doesn't install any files.
 install(TARGETS liblzma EXPORT liblzmaTargets
         RUNTIME  DESTINATION "${CMAKE_INSTALL_BINDIR}"
                  COMPONENT liblzma_Runtime
         LIBRARY  DESTINATION "${CMAKE_INSTALL_LIBDIR}"
                  COMPONENT liblzma_Runtime
                  NAMELINK_COMPONENT liblzma_Development
         ARCHIVE  DESTINATION "${CMAKE_INSTALL_LIBDIR}"
                  COMPONENT liblzma_Development
         INCLUDES DESTINATION "${CMAKE_INSTALL_INCLUDEDIR}")
 
 # Install the liblzma API headers. These use a subdirectory so
 # this has to be done as a separate step.
 install(DIRECTORY src/liblzma/api/
         COMPONENT liblzma_Development
         DESTINATION "${CMAKE_INSTALL_INCLUDEDIR}"
         FILES_MATCHING PATTERN "*.h")
 
 # Install the CMake files that other packages can use to find liblzma.
 set(liblzma_INSTALL_CMAKEDIR
     "${CMAKE_INSTALL_LIBDIR}/cmake/liblzma"
     CACHE STRING "Path to liblzma's .cmake files")
 
 install(EXPORT liblzmaTargets
         NAMESPACE liblzma::
         FILE liblzma-targets.cmake
         DESTINATION "${liblzma_INSTALL_CMAKEDIR}"
         COMPONENT liblzma_Development)
 
 install(FILES "${CMAKE_CURRENT_BINARY_DIR}/liblzma-config.cmake"
               "${CMAKE_CURRENT_BINARY_DIR}/liblzma-config-version.cmake"
         DESTINATION "${liblzma_INSTALL_CMAKEDIR}"
         COMPONENT liblzma_Development)
 
 if(NOT MSVC)
     install(FILES "${CMAKE_CURRENT_BINARY_DIR}/liblzma.pc"
             DESTINATION "${CMAKE_INSTALL_LIBDIR}/pkgconfig"
             COMPONENT liblzma_Development)
 endif()
 
 
 #############################################################################
 # Helper functions for installing files
 #############################################################################
 
 # For each non-empty element in the list LINK_NAMES, creates symbolic links
 # ${LINK_NAME}${LINK_SUFFIX} -> ${TARGET_NAME} in the directory ${DIR}.
 # The target file should exist because on Cygwin and MSYS2 symlink creation
 # can fail under certain conditions if the target doesn't exist.
 function(my_install_symlinks COMPONENT DIR TARGET_NAME LINK_SUFFIX LINK_NAMES)
     install(CODE "set(D \"\$ENV{DESTDIR}\${CMAKE_INSTALL_PREFIX}/${DIR}\")
                  foreach(L ${LINK_NAMES})
                      file(CREATE_LINK \"${TARGET_NAME}\"
                                       \"\${D}/\${L}${LINK_SUFFIX}\"
                                       SYMBOLIC)
                  endforeach()"
             COMPONENT "${COMPONENT}")
 endfunction()
 
 # Installs a man page file of a given language ("" for the untranslated file)
 # and optionally its alternative names as symlinks. This is a helper function
 # for my_install_man() below.
 function(my_install_man_lang COMPONENT SRC_FILE MAN_LANG LINK_NAMES)
     # Get the man page section from the filename suffix.
     string(REGEX REPLACE "^.*\.([^/.]+)$" "\\1" MAN_SECTION "${SRC_FILE}")
 
     # A few man pages might be missing from translations.
     # Don't attempt to install them or create the related symlinks.
     if(NOT MAN_LANG STREQUAL "" AND NOT EXISTS "${SRC_FILE}")
         return()
     endif()
 
     # Installing the file must be done before creating the symlinks
     # due to Cygwin and MSYS2.
     install(FILES "${SRC_FILE}"
             DESTINATION "${CMAKE_INSTALL_MANDIR}/${MAN_LANG}/man${MAN_SECTION}"
             COMPONENT "${COMPONENT}")
 
     # Get the basename of the file to be used as the symlink target.
     get_filename_component(BASENAME "${SRC_FILE}" NAME)
 
     # LINK_NAMES don't contain the man page filename suffix (like ".1")
     # so it needs to be told to my_install_symlinks.
     my_install_symlinks("${COMPONENT}"
                         "${CMAKE_INSTALL_MANDIR}/${MAN_LANG}/man${MAN_SECTION}"
                         "${BASENAME}" ".${MAN_SECTION}" "${LINK_NAMES}")
 endfunction()
 
 # Installs a man page file and optionally its alternative names as symlinks.
 # Does the same for translations if ENABLE_NLS.
 function(my_install_man COMPONENT SRC_FILE LINK_NAMES)
     my_install_man_lang("${COMPONENT}" "${SRC_FILE}" "" "${LINK_NAMES}")
 
     if(ENABLE_NLS)
         # Find the translated versions of this man page.
         get_filename_component(BASENAME "${SRC_FILE}" NAME)
         file(GLOB MAN_FILES "po4a/man/*/${BASENAME}")
 
         foreach(F ${MAN_FILES})
             get_filename_component(MAN_LANG "${F}" DIRECTORY)
             get_filename_component(MAN_LANG "${MAN_LANG}" NAME)
             my_install_man_lang("${COMPONENT}" "${F}" "${MAN_LANG}"
                                 "${LINK_NAMES}")
         endforeach()
     endif()
 endfunction()
 
 
 #############################################################################
 # libgnu (getopt_long)
 #############################################################################
 
 # This mirrors how the Autotools build system handles the getopt_long
 # replacement, calling the object library libgnu since the replacement
 # version comes from Gnulib.
 add_library(libgnu OBJECT)
 
 # CMake requires that even an object library must have at least once source
 # file. So we give it a header file that results in no output files.
 #
 # NOTE: Using a file outside the lib directory makes it possible to
 # delete lib/*.h and lib/*.c and still keep the build working if
 # getopt_long replacement isn't needed. It's convenient if one wishes
 # to be certain that no GNU LGPL code gets included in the binaries.
 target_sources(libgnu PRIVATE src/common/sysdefs.h)
 
 # The Ninja Generator requires setting the linker language since it cannot
 # guess the programming language of just a header file. Setting this
 # property avoids needing an empty .c file or an non-empty unnecessary .c
 # file.
 set_target_properties(libgnu PROPERTIES LINKER_LANGUAGE C)
 
 # Create /lib directory in the build directory and add it to the include path.
 file(MAKE_DIRECTORY "${CMAKE_CURRENT_BINARY_DIR}/lib")
 target_include_directories(libgnu PUBLIC "${CMAKE_CURRENT_BINARY_DIR}/lib")
 
 # Include /lib from the source directory. It does no harm even if none of
 # the Gnulib replacements are used.
 target_include_directories(libgnu PUBLIC lib)
 
 # The command line tools need getopt_long in order to parse arguments. If
 # the system does not have a getopt_long implementation we can use the one
 # from Gnulib instead.
 check_symbol_exists(getopt_long getopt.h HAVE_GETOPT_LONG)
 
 if(NOT HAVE_GETOPT_LONG)
     # Set the __GETOPT_PREFIX definition to "rpl_" (replacement) to avoid
     # name conflicts with libc symbols. The same prefix is set if using
     # the Autotools build (m4/getopt.m4).
     target_compile_definitions(libgnu PUBLIC "__GETOPT_PREFIX=rpl_")
 
     # Create a custom copy command to copy the getopt header to the build
     # directory and re-copy it if it is updated. (Gnulib does it this way
     # because it allows choosing which .in.h files to actually use in the
     # build. We need just getopt.h so this is a bit overcomplicated for
     # a single header file only.)
     add_custom_command(OUTPUT "${CMAKE_CURRENT_BINARY_DIR}/lib/getopt.h"
         COMMAND "${CMAKE_COMMAND}" -E copy
             "${CMAKE_CURRENT_SOURCE_DIR}/lib/getopt.in.h"
             "${CMAKE_CURRENT_BINARY_DIR}/lib/getopt.h"
         MAIN_DEPENDENCY "${CMAKE_CURRENT_SOURCE_DIR}/lib/getopt.in.h"
         VERBATIM)
 
     target_sources(libgnu PRIVATE
         lib/getopt1.c
         lib/getopt.c
         lib/getopt_int.h
         lib/getopt-cdefs.h
         lib/getopt-core.h
         lib/getopt-ext.h
         lib/getopt-pfx-core.h
         lib/getopt-pfx-ext.h
         "${CMAKE_CURRENT_BINARY_DIR}/lib/getopt.h"
     )
 endif()
 
 
 #############################################################################
 # xzdec and lzmadec
 #############################################################################
 
 if(HAVE_DECODERS AND (NOT MSVC OR MSVC_VERSION GREATER_EQUAL 1900))
     foreach(XZDEC xzdec lzmadec)
         add_executable("${XZDEC}"
             src/common/sysdefs.h
             src/common/tuklib_common.h
             src/common/tuklib_config.h
             src/common/tuklib_exit.c
             src/common/tuklib_exit.h
             src/common/tuklib_gettext.h
             src/common/tuklib_progname.c
             src/common/tuklib_progname.h
             src/xzdec/xzdec.c
         )
 
         target_include_directories("${XZDEC}" PRIVATE
             src/common
             src/liblzma/api
         )
 
         target_link_libraries("${XZDEC}" PRIVATE liblzma libgnu)
 
         if(WIN32)
             # Add the Windows resource file for xzdec.exe or lzmadec.exe.
             target_sources("${XZDEC}" PRIVATE src/xzdec/xzdec_w32res.rc)
             set_target_properties("${XZDEC}" PROPERTIES
                 LINK_DEPENDS "${CMAKE_CURRENT_SOURCE_DIR}/src/common/common_w32res.rc"
             )
         endif()
 
         if(SANDBOX_COMPILE_DEFINITION)
             target_compile_definitions("${XZDEC}" PRIVATE
                                     "${SANDBOX_COMPILE_DEFINITION}")
         endif()
 
         tuklib_progname("${XZDEC}")
 
         install(TARGETS "${XZDEC}"
                 RUNTIME DESTINATION "${CMAKE_INSTALL_BINDIR}"
                         COMPONENT "${XZDEC}_Runtime")
     endforeach()
 
     # This is the only build-time difference with lzmadec.
     target_compile_definitions(lzmadec PRIVATE "LZMADEC")
 
     if(UNIX)
         # NOTE: This puts the lzmadec.1 symlinks into xzdec_Documentation.
         # This isn't great but doing them separately with translated
         # man pages would require extra code. So this has to suffice for now.
         my_install_man(xzdec_Documentation src/xzdec/xzdec.1 lzmadec)
     endif()
 endif()
 
 
 #############################################################################
 # lzmainfo
 #############################################################################
 
 if(HAVE_DECODERS AND (NOT MSVC OR MSVC_VERSION GREATER_EQUAL 1900))
     add_executable(lzmainfo
         src/common/sysdefs.h
         src/common/tuklib_common.h
         src/common/tuklib_config.h
         src/common/tuklib_exit.c
         src/common/tuklib_exit.h
         src/common/tuklib_gettext.h
         src/common/tuklib_progname.c
         src/common/tuklib_progname.h
         src/lzmainfo/lzmainfo.c
     )
 
     target_include_directories(lzmainfo PRIVATE
         src/common
         src/liblzma/api
     )
 
     target_link_libraries(lzmainfo PRIVATE liblzma libgnu)
 
     if(WIN32)
         # Add the Windows resource file for lzmainfo.exe.
         target_sources(lzmainfo PRIVATE src/lzmainfo/lzmainfo_w32res.rc)
         set_target_properties(lzmainfo PROPERTIES
             LINK_DEPENDS "${CMAKE_CURRENT_SOURCE_DIR}/src/common/common_w32res.rc"
         )
     endif()
 
     tuklib_progname(lzmainfo)
 
     # NOTE: The translations are in the "xz" domain and the .mo files are
     # installed as part of the "xz" target.
     if(ENABLE_NLS)
         target_link_libraries(lzmainfo PRIVATE Intl::Intl)
 
         target_compile_definitions(lzmainfo PRIVATE
                 ENABLE_NLS
                 PACKAGE="${TRANSLATION_DOMAIN}"
                 LOCALEDIR="${LOCALEDIR_DEFINITION}"
         )
     endif()
 
     install(TARGETS lzmainfo
             RUNTIME DESTINATION "${CMAKE_INSTALL_BINDIR}"
                     COMPONENT lzmainfo_Runtime)
 
     if(UNIX)
         my_install_man(lzmainfo_Documentation src/lzmainfo/lzmainfo.1 "")
     endif()
 endif()
 
 
 #############################################################################
 # xz
 #############################################################################
 
 if(NOT MSVC OR MSVC_VERSION GREATER_EQUAL 1900)
     add_executable(xz
         src/common/mythread.h
         src/common/sysdefs.h
         src/common/tuklib_common.h
         src/common/tuklib_config.h
         src/common/tuklib_exit.c
         src/common/tuklib_exit.h
         src/common/tuklib_gettext.h
         src/common/tuklib_integer.h
         src/common/tuklib_mbstr.h
         src/common/tuklib_mbstr_fw.c
         src/common/tuklib_mbstr_width.c
         src/common/tuklib_open_stdxxx.c
         src/common/tuklib_open_stdxxx.h
         src/common/tuklib_progname.c
         src/common/tuklib_progname.h
         src/xz/args.c
         src/xz/args.h
         src/xz/coder.c
         src/xz/coder.h
         src/xz/file_io.c
         src/xz/file_io.h
         src/xz/hardware.c
         src/xz/hardware.h
         src/xz/main.c
         src/xz/main.h
         src/xz/message.c
         src/xz/message.h
         src/xz/mytime.c
         src/xz/mytime.h
         src/xz/options.c
         src/xz/options.h
         src/xz/private.h
         src/xz/sandbox.c
         src/xz/sandbox.h
         src/xz/signals.c
         src/xz/signals.h
         src/xz/suffix.c
         src/xz/suffix.h
         src/xz/util.c
         src/xz/util.h
     )
 
     target_include_directories(xz PRIVATE
         src/common
         src/liblzma/api
     )
 
     if(HAVE_DECODERS)
         target_sources(xz PRIVATE
             src/xz/list.c
             src/xz/list.h
         )
     endif()
 
     target_link_libraries(xz PRIVATE liblzma libgnu)
 
     target_compile_definitions(xz PRIVATE ASSUME_RAM=128)
 
     if(WIN32)
         # Add the Windows resource file for xz.exe.
         target_sources(xz PRIVATE src/xz/xz_w32res.rc)
         set_target_properties(xz PROPERTIES
             LINK_DEPENDS "${CMAKE_CURRENT_SOURCE_DIR}/src/common/common_w32res.rc"
         )
     endif()
 
     if(SANDBOX_COMPILE_DEFINITION)
         target_compile_definitions(xz PRIVATE "${SANDBOX_COMPILE_DEFINITION}")
     endif()
 
     tuklib_progname(xz)
     tuklib_mbstr(xz)
 
     check_symbol_exists(optreset getopt.h HAVE_OPTRESET)
     tuklib_add_definition_if(xz HAVE_OPTRESET)
 
     check_symbol_exists(posix_fadvise fcntl.h HAVE_POSIX_FADVISE)
     tuklib_add_definition_if(xz HAVE_POSIX_FADVISE)
 
     # How to get file time:
     check_struct_has_member("struct stat" st_atim.tv_nsec
                             "sys/types.h;sys/stat.h"
                             HAVE_STRUCT_STAT_ST_ATIM_TV_NSEC)
     if(HAVE_STRUCT_STAT_ST_ATIM_TV_NSEC)
         tuklib_add_definitions(xz HAVE_STRUCT_STAT_ST_ATIM_TV_NSEC)
     else()
         check_struct_has_member("struct stat" st_atimespec.tv_nsec
                                 "sys/types.h;sys/stat.h"
                                 HAVE_STRUCT_STAT_ST_ATIMESPEC_TV_NSEC)
         if(HAVE_STRUCT_STAT_ST_ATIMESPEC_TV_NSEC)
             tuklib_add_definitions(xz HAVE_STRUCT_STAT_ST_ATIMESPEC_TV_NSEC)
         else()
             check_struct_has_member("struct stat" st_atimensec
                                     "sys/types.h;sys/stat.h"
                                     HAVE_STRUCT_STAT_ST_ATIMENSEC)
             tuklib_add_definition_if(xz HAVE_STRUCT_STAT_ST_ATIMENSEC)
         endif()
     endif()
 
     # How to set file time:
     check_symbol_exists(futimens "sys/types.h;sys/stat.h" HAVE_FUTIMENS)
     if(HAVE_FUTIMENS)
         tuklib_add_definitions(xz HAVE_FUTIMENS)
     else()
         check_symbol_exists(futimes "sys/time.h" HAVE_FUTIMES)
         if(HAVE_FUTIMES)
             tuklib_add_definitions(xz HAVE_FUTIMES)
         else()
             check_symbol_exists(futimesat "sys/time.h" HAVE_FUTIMESAT)
             if(HAVE_FUTIMESAT)
                 tuklib_add_definitions(xz HAVE_FUTIMESAT)
             else()
                 check_symbol_exists(utimes "sys/time.h" HAVE_UTIMES)
                 if(HAVE_UTIMES)
                     tuklib_add_definitions(xz HAVE_UTIMES)
                 else()
                     check_symbol_exists(_futime "sys/utime.h" HAVE__FUTIME)
                     if(HAVE__FUTIME)
                         tuklib_add_definitions(xz HAVE__FUTIME)
                     else()
                         check_symbol_exists(utime "utime.h" HAVE_UTIME)
                         tuklib_add_definition_if(xz HAVE_UTIME)
                     endif()
                 endif()
             endif()
         endif()
     endif()
 
     if(ENABLE_NLS)
         target_link_libraries(xz PRIVATE Intl::Intl)
 
         target_compile_definitions(xz PRIVATE
                 ENABLE_NLS
                 PACKAGE="${TRANSLATION_DOMAIN}"
                 LOCALEDIR="${LOCALEDIR_DEFINITION}"
         )
 
         file(STRINGS po/LINGUAS LINGUAS)
 
         # Where to find .gmo files. If msgfmt is available, the .po files
         # will be converted as part of the build. Otherwise we will use
         # the pre-generated .gmo files which are included in XZ Utils
         # tarballs by Autotools.
         set(GMO_DIR "${CMAKE_CURRENT_SOURCE_DIR}/po")
 
         if(GETTEXT_FOUND)
             # NOTE: gettext_process_po_files' INSTALL_DESTINATION is
             # incompatible with how Autotools requires the .po files to
             # be named. CMake would require each .po file to be named with
             # the translation domain and thus each .po file would need its
             # own language-specific directory (like "po/fi/xz.po"). On top
             # of this, INSTALL_DESTINATION doesn't allow specifying COMPONENT
             # and thus the .mo files go into "Unspecified" component. So we
             # can use gettext_process_po_files to convert the .po files but
             # installation needs to be done with our own code.
             #
             # Also, the .gmo files will go to root of the build directory
             # instead of neatly into a subdirectory. This is hardcoded in
             # CMake's FindGettext.cmake.
             foreach(LANG IN LISTS LINGUAS)
                 gettext_process_po_files("${LANG}" ALL
                         PO_FILES "${CMAKE_CURRENT_SOURCE_DIR}/po/${LANG}.po")
             endforeach()
 
             set(GMO_DIR "${CMAKE_CURRENT_BINARY_DIR}")
         endif()
 
         foreach(LANG IN LISTS LINGUAS)
             install(
                 FILES "${GMO_DIR}/${LANG}.gmo"
                 DESTINATION "${CMAKE_INSTALL_LOCALEDIR}/${LANG}/LC_MESSAGES"
                 RENAME "${TRANSLATION_DOMAIN}.mo"
                 COMPONENT xz_Runtime)
         endforeach()
     endif()
 
     # This command must be before the symlink creation to keep things working
     # on Cygwin and MSYS2 in all cases.
     #
     #   - Cygwin can encode symlinks in multiple ways. This can be
     #     controlled via the environment variable "CYGWIN". If it contains
     #     "winsymlinks:nativestrict" then symlink creation will fail if
     #     the link target doesn't exist. This mode isn't the default though.
     #     See: https://cygwin.com/faq.html#faq.api.symlinks
     #
     #   - MSYS2 supports the same winsymlinks option in the environment
     #     variable "MSYS" (not "MSYS2). The default in MSYS2 is to make
     #     a copy of the file instead of any kind of symlink. Thus the link
     #     target must exist or the creation of the "symlink" (copy) will fail.
     #
     # Our installation order must be such that when a symbolic link is created
     # its target must already exists. There is no race condition for parallel
     # builds because the generated cmake_install.cmake executes serially.
     install(TARGETS xz
             RUNTIME DESTINATION "${CMAKE_INSTALL_BINDIR}"
                     COMPONENT xz_Runtime)
 
     if(UNIX)
         option(CREATE_XZ_SYMLINKS "Create unxz and xzcat symlinks" ON)
         option(CREATE_LZMA_SYMLINKS "Create lzma, unlzma, and lzcat symlinks"
                ON)
         set(XZ_LINKS)
 
         if(CREATE_XZ_SYMLINKS)
             list(APPEND XZ_LINKS "unxz" "xzcat")
         endif()
 
         if(CREATE_LZMA_SYMLINKS)
             list(APPEND XZ_LINKS "lzma" "unlzma" "lzcat")
         endif()
 
         # On Cygwin, don't add the .exe suffix to the symlinks.
         #
         # FIXME? Does this make sense on MSYS & MSYS2 where "ln -s"
         # by default makes copies? Inside MSYS & MSYS2 it is possible
         # to execute files without the .exe suffix but not outside
         # (like in Command Prompt). Omitting the suffix matches
         # what configure.ac has done for many years though.
         my_install_symlinks(xz_Runtime "${CMAKE_INSTALL_BINDIR}"
                             "xz${CMAKE_EXECUTABLE_SUFFIX}" "" "${XZ_LINKS}")
 
         # Install the man pages and (optionally) their symlinks
         # and translations.
         my_install_man(xz_Documentation src/xz/xz.1 "${XZ_LINKS}")
     endif()
 endif()
 
 
 #############################################################################
 # Scripts
 #############################################################################
 
 if(UNIX)
     # NOTE: This isn't as sophisticated as in the Autotools build which
     # uses posix-shell.m4 but hopefully this doesn't need to be either.
     # CMake likely won't be used on as many (old) obscure systems as the
     # Autotools-based builds are.
     if(CMAKE_SYSTEM_NAME STREQUAL "SunOS" AND EXISTS "/usr/xpg4/bin/sh")
         set(POSIX_SHELL_DEFAULT "/usr/xpg4/bin/sh")
     else()
         set(POSIX_SHELL_DEFAULT "/bin/sh")
     endif()
 
     set(POSIX_SHELL "${POSIX_SHELL_DEFAULT}" CACHE STRING
         "Shell to use for scripts (xzgrep and others)")
 
     # Guess the extra path to add from POSIX_SHELL. Autotools-based build
     # has a separate option --enable-path-for-scripts=PREFIX but this is
     # enough for Solaris.
     set(enable_path_for_scripts)
     get_filename_component(POSIX_SHELL_DIR "${POSIX_SHELL}" DIRECTORY)
 
     if(NOT POSIX_SHELL_DIR STREQUAL "/bin" AND
             NOT POSIX_SHELL_DIR STREQUAL "/usr/bin")
         set(enable_path_for_scripts "PATH=${POSIX_SHELL_DIR}:\$PATH")
     endif()
 
     set(XZDIFF_LINKS xzcmp)
     set(XZGREP_LINKS xzegrep xzfgrep)
     set(XZMORE_LINKS)
     set(XZLESS_LINKS)
 
     if(CREATE_LZMA_SYMLINKS)
         list(APPEND XZDIFF_LINKS lzdiff lzcmp)
         list(APPEND XZGREP_LINKS lzgrep lzegrep lzfgrep)
         list(APPEND XZMORE_LINKS lzmore)
         list(APPEND XZLESS_LINKS lzless)
     endif()
 
     set(xz "xz")
 
     foreach(S xzdiff xzgrep xzmore xzless)
         configure_file("src/scripts/${S}.in" "${S}"
                @ONLY
                NEWLINE_STYLE LF)
 
         install(PROGRAMS "${CMAKE_CURRENT_BINARY_DIR}/${S}"
                 DESTINATION "${CMAKE_INSTALL_BINDIR}"
                 COMPONENT scripts_Runtime)
     endforeach()
 
     # file(CHMOD ...) would need CMake 3.19 so use execute_process instead.
     # Using +x is fine even if umask was 077. If execute bit is set at all
     # then "make install" will set it for group and other access bits too.
     execute_process(COMMAND chmod +x xzdiff xzgrep xzmore xzless
                     WORKING_DIRECTORY "${CMAKE_CURRENT_BINARY_DIR}")
 
     unset(xz)
     unset(POSIX_SHELL)
     unset(enable_path_for_scripts)
 
     my_install_symlinks(scripts_Runtime "${CMAKE_INSTALL_BINDIR}" xzdiff ""
                         "${XZDIFF_LINKS}")
 
     my_install_symlinks(scripts_Runtime "${CMAKE_INSTALL_BINDIR}" xzgrep ""
                         "${XZGREP_LINKS}")
 
     my_install_symlinks(scripts_Runtime "${CMAKE_INSTALL_BINDIR}" xzmore ""
                         "${XZMORE_LINKS}")
 
     my_install_symlinks(scripts_Runtime "${CMAKE_INSTALL_BINDIR}" xzless ""
                         "${XZLESS_LINKS}")
 
     my_install_man(scripts_Documentation src/scripts/xzdiff.1 "${XZDIFF_LINKS}")
     my_install_man(scripts_Documentation src/scripts/xzgrep.1 "${XZGREP_LINKS}")
     my_install_man(scripts_Documentation src/scripts/xzmore.1 "${XZMORE_LINKS}")
     my_install_man(scripts_Documentation src/scripts/xzless.1 "${XZLESS_LINKS}")
 endif()
 
 
 #############################################################################
 # Documentation
 #############################################################################
 
 # Use OPTIONAL because doc/api might not exist. The liblzma API docs
 # can be generated by running "doxygen/update-doxygen".
 install(DIRECTORY doc/api doc/examples
         DESTINATION "${CMAKE_INSTALL_DOCDIR}"
         COMPONENT liblzma_Documentation
         OPTIONAL)
 
 # GPLv2 applies to the scripts. If GNU getopt_long is used then
 # LGPLv2.1 applies to the command line tools but, using the
 # section 3 of LGPLv2.1, GNU getopt_long can be handled as GPLv2 too.
 # Thus GPLv2 should be enough here.
 install(FILES AUTHORS
               COPYING
               COPYING.0BSD
               COPYING.GPLv2
               NEWS
               README
               THANKS
               doc/faq.txt
               doc/history.txt
               doc/lzma-file-format.txt
               doc/xz-file-format.txt
         DESTINATION "${CMAKE_INSTALL_DOCDIR}"
         COMPONENT Documentation)
 
 
 #############################################################################
 # Tests
 #############################################################################
 
 include(CTest)
 
 if(BUILD_TESTING)
     set(LIBLZMA_TESTS
         test_bcj_exact_size
         test_block_header
         test_check
         test_filter_flags
         test_filter_str
         test_hardware
         test_index
         test_index_hash
         test_lzip_decoder
         test_memlimit
         test_microlzma
         test_stream_flags
         test_vli
     )
 
     foreach(TEST IN LISTS LIBLZMA_TESTS)
         add_executable("${TEST}" "tests/${TEST}.c")
 
         target_include_directories("${TEST}" PRIVATE
             src/common
             src/liblzma/api
             src/liblzma
         )
 
         target_link_libraries("${TEST}" PRIVATE liblzma)
 
         # Put the test programs into their own subdirectory so they don't
         # pollute the top-level dir which might contain xz and xzdec.
         set_target_properties("${TEST}" PROPERTIES
             RUNTIME_OUTPUT_DIRECTORY "${CMAKE_CURRENT_BINARY_DIR}/tests_bin"
         )
 
         add_test(NAME "${TEST}"
                  COMMAND "${CMAKE_CURRENT_BINARY_DIR}/tests_bin/${TEST}"
         )
 
         # Set srcdir environment variable so that the tests find their
         # input files from the source tree.
         #
         # Set the return code for skipped tests to match Automake convention.
         set_tests_properties("${TEST}" PROPERTIES
             ENVIRONMENT "srcdir=${CMAKE_CURRENT_SOURCE_DIR}/tests"
             SKIP_RETURN_CODE 77
         )
     endforeach()
 
     if(UNIX AND HAVE_DECODERS)
         file(MAKE_DIRECTORY "${CMAKE_CURRENT_BINARY_DIR}/test_scripts")
 
         add_test(NAME test_scripts.sh
             COMMAND "${CMAKE_CURRENT_SOURCE_DIR}/tests/test_scripts.sh" ".."
             WORKING_DIRECTORY "${CMAKE_CURRENT_BINARY_DIR}/test_scripts"
         )
 
         set_tests_properties(test_scripts.sh PROPERTIES
             ENVIRONMENT "srcdir=${CMAKE_CURRENT_SOURCE_DIR}/tests"
             SKIP_RETURN_CODE 77
         )
     endif()
 endif()
diff --git a/configure.ac b/configure.ac
index 3676cd03..446e26e2 100644
--- a/configure.ac
+++ b/configure.ac
@@ -1,1360 +1,1385 @@
 #                                               -*- Autoconf -*-
 # SPDX-License-Identifier: 0BSD
 
 ###############################################################################
 #
 # Process this file with autoconf to produce a configure script.
 #
 # Author: Lasse Collin
 #
 ###############################################################################
 
 # NOTE: Don't add useless checks. autoscan detects this and that, but don't
 # let it confuse you. For example, we don't care about checking for behavior
 # of malloc(), stat(), or lstat(), since we don't use those functions in
 # a way that would cause the problems the autoconf macros check.
 
 AC_PREREQ([2.69])
 
 AC_INIT([XZ Utils], m4_esyscmd([/bin/sh build-aux/version.sh]),
 	[xz@tukaani.org], [xz], [https://xz.tukaani.org/xz-utils/])
 AC_CONFIG_SRCDIR([src/liblzma/common/common.h])
 AC_CONFIG_AUX_DIR([build-aux])
 AC_CONFIG_MACRO_DIR([m4])
 AC_CONFIG_HEADERS([config.h])
 
 echo
 echo "$PACKAGE_STRING"
 
 echo
 echo "System type:"
 # This is needed to know if assembler optimizations can be used.
 AC_CANONICAL_HOST
 
 # We do some special things on Windows (32-bit or 64-bit) builds.
 case $host_os in
 	mingw* | cygwin | msys) is_w32=yes ;;
 	*)                      is_w32=no ;;
 esac
 AM_CONDITIONAL([COND_W32], [test "$is_w32" = yes])
 
 # We need to use $EXEEXT with $(LN_S) when creating symlinks to
 # executables. Cygwin is an exception to this, since it is recommended
 # that symlinks don't have the .exe suffix. To make this work, we
 # define LN_EXEEXT.
 #
 # MSYS2 is treated the same way as Cygwin. It uses plain "msys" like
 # the original MSYS when building MSYS/MSYS2-binaries. Hopefully this
 # doesn't break things for the original MSYS developers. Note that this
 # doesn't affect normal MSYS/MSYS2 users building non-MSYS/MSYS2 binaries
 # since in that case the $host_os is usually mingw32.
 case $host_os in
 	cygwin | msys)  LN_EXEEXT= ;;
 	*)              LN_EXEEXT='$(EXEEXT)' ;;
 esac
 AC_SUBST([LN_EXEEXT])
 
 echo
 echo "Configure options:"
 AM_CFLAGS=
 
 
 #############
 # Debugging #
 #############
 
 AC_MSG_CHECKING([if debugging code should be compiled])
 AC_ARG_ENABLE([debug], AS_HELP_STRING([--enable-debug], [Enable debugging code.]),
 	[], enable_debug=no)
 if test "x$enable_debug" = xyes; then
 	AC_MSG_RESULT([yes])
 else
 	AC_DEFINE([NDEBUG], [1], [Define to 1 to disable debugging code.])
 	AC_MSG_RESULT([no])
 fi
 
 
 ###########
 # Filters #
 ###########
 
 m4_define([SUPPORTED_FILTERS], [lzma1,lzma2,delta,x86,powerpc,ia64,arm,armthumb,arm64,sparc,riscv])dnl
 m4_define([SIMPLE_FILTERS], [x86,powerpc,ia64,arm,armthumb,arm64,sparc,riscv])
 m4_define([LZ_FILTERS], [lzma1,lzma2])
 
 m4_foreach([NAME], [SUPPORTED_FILTERS],
 [enable_filter_[]NAME=no
 enable_encoder_[]NAME=no
 enable_decoder_[]NAME=no
 ])dnl
 
 AC_MSG_CHECKING([which encoders to build])
 AC_ARG_ENABLE([encoders], AS_HELP_STRING([--enable-encoders=LIST],
 		[Comma-separated list of encoders to build. Default=all.
 		Available encoders:]
 			m4_translit(m4_defn([SUPPORTED_FILTERS]), [,], [ ])),
 	[], [enable_encoders=SUPPORTED_FILTERS])
 enable_encoders=`echo "$enable_encoders" | sed 's/,/ /g'`
 if test "x$enable_encoders" = xno || test "x$enable_encoders" = x; then
 	enable_encoders=no
 	AC_MSG_RESULT([(none)])
 else
 	for arg in $enable_encoders
 	do
 		case $arg in m4_foreach([NAME], [SUPPORTED_FILTERS], [
 			NAME)
 				enable_filter_[]NAME=yes
 				enable_encoder_[]NAME=yes
 				AC_DEFINE(HAVE_ENCODER_[]m4_toupper(NAME), [1],
 				[Define to 1 if] NAME [encoder is enabled.])
 				;;])
 			*)
 				AC_MSG_RESULT([])
 				AC_MSG_ERROR([unknown filter: $arg])
 				;;
 		esac
 	done
 	AC_DEFINE([HAVE_ENCODERS], [1],
 		[Define to 1 if any of HAVE_ENCODER_foo have been defined.])
 	AC_MSG_RESULT([$enable_encoders])
 fi
 
 AC_MSG_CHECKING([which decoders to build])
 AC_ARG_ENABLE([decoders], AS_HELP_STRING([--enable-decoders=LIST],
 		[Comma-separated list of decoders to build. Default=all.
 		Available decoders are the same as available encoders.]),
 	[], [enable_decoders=SUPPORTED_FILTERS])
 enable_decoders=`echo "$enable_decoders" | sed 's/,/ /g'`
 if test "x$enable_decoders" = xno || test "x$enable_decoders" = x; then
 	enable_decoders=no
 	AC_MSG_RESULT([(none)])
 else
 	for arg in $enable_decoders
 	do
 		case $arg in m4_foreach([NAME], [SUPPORTED_FILTERS], [
 			NAME)
 				enable_filter_[]NAME=yes
 				enable_decoder_[]NAME=yes
 				AC_DEFINE(HAVE_DECODER_[]m4_toupper(NAME), [1],
 				[Define to 1 if] NAME [decoder is enabled.])
 				;;])
 			*)
 				AC_MSG_RESULT([])
 				AC_MSG_ERROR([unknown filter: $arg])
 				;;
 		esac
 	done
 	AC_DEFINE([HAVE_DECODERS], [1],
 		[Define to 1 if any of HAVE_DECODER_foo have been defined.])
 	AC_MSG_RESULT([$enable_decoders])
 fi
 
 if test "x$enable_encoder_lzma2$enable_encoder_lzma1" = xyesno \
 		|| test "x$enable_decoder_lzma2$enable_decoder_lzma1" = xyesno; then
 	AC_MSG_ERROR([LZMA2 requires that LZMA1 is also enabled.])
 fi
 
 AM_CONDITIONAL(COND_MAIN_ENCODER, test "x$enable_encoders" != xno)
 AM_CONDITIONAL(COND_MAIN_DECODER, test "x$enable_decoders" != xno)
 
 m4_foreach([NAME], [SUPPORTED_FILTERS],
 [AM_CONDITIONAL(COND_FILTER_[]m4_toupper(NAME), test "x$enable_filter_[]NAME" = xyes)
 AM_CONDITIONAL(COND_ENCODER_[]m4_toupper(NAME), test "x$enable_encoder_[]NAME" = xyes)
 AM_CONDITIONAL(COND_DECODER_[]m4_toupper(NAME), test "x$enable_decoder_[]NAME" = xyes)
 ])dnl
 
 # The so called "simple filters" share common code.
 enable_filter_simple=no
 enable_encoder_simple=no
 enable_decoder_simple=no
 m4_foreach([NAME], [SIMPLE_FILTERS],
 [test "x$enable_filter_[]NAME" = xyes && enable_filter_simple=yes
 test "x$enable_encoder_[]NAME" = xyes && enable_encoder_simple=yes
 test "x$enable_decoder_[]NAME" = xyes && enable_decoder_simple=yes
 ])dnl
 AM_CONDITIONAL(COND_FILTER_SIMPLE, test "x$enable_filter_simple" = xyes)
 AM_CONDITIONAL(COND_ENCODER_SIMPLE, test "x$enable_encoder_simple" = xyes)
 AM_CONDITIONAL(COND_DECODER_SIMPLE, test "x$enable_decoder_simple" = xyes)
 
 # LZ-based filters share common code.
 enable_filter_lz=no
 enable_encoder_lz=no
 enable_decoder_lz=no
 m4_foreach([NAME], [LZ_FILTERS],
 [test "x$enable_filter_[]NAME" = xyes && enable_filter_lz=yes
 test "x$enable_encoder_[]NAME" = xyes && enable_encoder_lz=yes
 test "x$enable_decoder_[]NAME" = xyes && enable_decoder_lz=yes
 ])dnl
 AM_CONDITIONAL(COND_FILTER_LZ, test "x$enable_filter_lz" = xyes)
 AM_CONDITIONAL(COND_ENCODER_LZ, test "x$enable_encoder_lz" = xyes)
 AM_CONDITIONAL(COND_DECODER_LZ, test "x$enable_decoder_lz" = xyes)
 
 
 #################
 # Match finders #
 #################
 
 m4_define([SUPPORTED_MATCH_FINDERS], [hc3,hc4,bt2,bt3,bt4])
 
 m4_foreach([NAME], [SUPPORTED_MATCH_FINDERS],
 [enable_match_finder_[]NAME=no
 ])
 
 AC_MSG_CHECKING([which match finders to build])
 AC_ARG_ENABLE([match-finders], AS_HELP_STRING([--enable-match-finders=LIST],
 		[Comma-separated list of match finders to build. Default=all.
 		At least one match finder is required for encoding with
 		the LZMA1 and LZMA2 filters. Available match finders:]
 		m4_translit(m4_defn([SUPPORTED_MATCH_FINDERS]), [,], [ ])), [],
 	[enable_match_finders=SUPPORTED_MATCH_FINDERS])
 enable_match_finders=`echo "$enable_match_finders" | sed 's/,/ /g'`
 if test "x$enable_encoder_lz" = xyes ; then
 	if test -z "$enable_match_finders"; then
 		AC_MSG_ERROR([At least one match finder is required for an LZ-based encoder.])
 	fi
 
 	for arg in $enable_match_finders
 		do
 		case $arg in m4_foreach([NAME], [SUPPORTED_MATCH_FINDERS], [
 			NAME)
 				enable_match_finder_[]NAME=yes
 				AC_DEFINE(HAVE_MF_[]m4_toupper(NAME), [1],
 				[Define to 1 to enable] NAME [match finder.])
 				;;])
 			*)
 				AC_MSG_RESULT([])
 				AC_MSG_ERROR([unknown match finder: $arg])
 				;;
 		esac
 	done
 	AC_MSG_RESULT([$enable_match_finders])
 else
 	AC_MSG_RESULT([(none because not building any LZ-based encoder)])
 fi
 
 
 ####################
 # Integrity checks #
 ####################
 
 m4_define([SUPPORTED_CHECKS], [crc32,crc64,sha256])
 
 m4_foreach([NAME], [SUPPORTED_CHECKS],
 [enable_check_[]NAME=no
 ])dnl
 
 AC_MSG_CHECKING([which integrity checks to build])
 AC_ARG_ENABLE([checks], AS_HELP_STRING([--enable-checks=LIST],
 		[Comma-separated list of integrity checks to build.
 		Default=all. Available integrity checks:]
 		m4_translit(m4_defn([SUPPORTED_CHECKS]), [,], [ ])),
 	[], [enable_checks=SUPPORTED_CHECKS])
 enable_checks=`echo "$enable_checks" | sed 's/,/ /g'`
 if test "x$enable_checks" = xno || test "x$enable_checks" = x; then
 	AC_MSG_RESULT([(none)])
 else
 	for arg in $enable_checks
 	do
 		case $arg in m4_foreach([NAME], [SUPPORTED_CHECKS], [
 			NAME)
 				enable_check_[]NAME=yes
 				AC_DEFINE(HAVE_CHECK_[]m4_toupper(NAME), [1],
 				[Define to 1 if] NAME
 				[integrity check is enabled.])
 				;;])
 			*)
 				AC_MSG_RESULT([])
 				AC_MSG_ERROR([unknown integrity check: $arg])
 				;;
 		esac
 	done
 	AC_MSG_RESULT([$enable_checks])
 fi
 if test "x$enable_check_crc32" = xno ; then
 	AC_MSG_ERROR([For now, the CRC32 check must always be enabled.])
 fi
 
 m4_foreach([NAME], [SUPPORTED_CHECKS],
 [AM_CONDITIONAL(COND_CHECK_[]m4_toupper(NAME), test "x$enable_check_[]NAME" = xyes)
 ])dnl
 
 AC_MSG_CHECKING([if external SHA-256 should be used])
 AC_ARG_ENABLE([external-sha256], AS_HELP_STRING([--enable-external-sha256],
 		[Use SHA-256 code from the operating system.
 		See INSTALL for possible subtle problems.]),
 		[], [enable_external_sha256=no])
 if test "x$enable_check_sha256" != "xyes"; then
 	enable_external_sha256=no
 fi
 if test "x$enable_external_sha256" = xyes; then
 	AC_MSG_RESULT([yes])
 else
 	AC_MSG_RESULT([no])
 fi
 
 
 #############
 # MicroLZMA #
 #############
 
 AC_MSG_CHECKING([if MicroLZMA support should be built])
 AC_ARG_ENABLE([microlzma], AS_HELP_STRING([--disable-microlzma],
 		[Do not build MicroLZMA encoder and decoder.
 		It is needed by specific applications only,
 		for example, erofs-utils.]),
 	[], [enable_microlzma=yes])
 case $enable_microlzma in
 	yes)
 		AC_DEFINE([HAVE_MICROLZMA], [1],
 			[Define to 1 if MicroLZMA support is enabled.])
 		AC_MSG_RESULT([yes])
 		;;
 	no)
 		AC_MSG_RESULT([no])
 		;;
 	*)
 		AC_MSG_RESULT([])
 		AC_MSG_ERROR([--enable-microlzma accepts only 'yes' or 'no'.])
 		;;
 esac
 AM_CONDITIONAL(COND_MICROLZMA, test "x$enable_microlzma" = xyes)
 
 
 #############################
 # .lz (lzip) format support #
 #############################
 
 AC_MSG_CHECKING([if .lz (lzip) decompression support should be built])
 AC_ARG_ENABLE([lzip-decoder], AS_HELP_STRING([--disable-lzip-decoder],
 		[Disable decompression support for .lz (lzip) files.]),
 	[], [enable_lzip_decoder=yes])
 if test "x$enable_decoder_lzma1" != xyes; then
 	enable_lzip_decoder=no
 	AC_MSG_RESULT([no because LZMA1 decoder is disabled])
 elif test "x$enable_lzip_decoder" = xyes; then
 	AC_DEFINE([HAVE_LZIP_DECODER], [1],
 		[Define to 1 if .lz (lzip) decompression support is enabled.])
 	AC_MSG_RESULT([yes])
 else
 	AC_MSG_RESULT([no])
 fi
 AM_CONDITIONAL(COND_LZIP_DECODER, test "x$enable_lzip_decoder" = xyes)
 
 
 ###########################
 # Assembler optimizations #
 ###########################
 
 AC_MSG_CHECKING([if assembler optimizations should be used])
 AC_ARG_ENABLE([assembler], AS_HELP_STRING([--disable-assembler],
 		[Do not use assembler optimizations even if such exist
 		for the architecture.]),
 	[], [enable_assembler=yes])
 if test "x$enable_assembler" = xyes; then
 	enable_assembler=no
 	case $host_os in
 		# Darwin should work too but only if not creating universal
 		# binaries. Solaris x86 could work too but I cannot test.
 		linux* | *bsd* | mingw* | cygwin | msys | *djgpp*)
 			case $host_cpu in
 				i?86)   enable_assembler=x86 ;;
 			esac
 			;;
 	esac
 fi
 case $enable_assembler in
 	x86 | no)
 		AC_MSG_RESULT([$enable_assembler])
 		;;
 	*)
 		AC_MSG_RESULT([])
 		AC_MSG_ERROR([--enable-assembler accepts only 'yes', 'no', or 'x86' (32-bit).])
 		;;
 esac
 AM_CONDITIONAL(COND_ASM_X86, test "x$enable_assembler" = xx86)
 
 
 #############
 # CLMUL CRC #
 #############
 
 AC_ARG_ENABLE([clmul-crc], AS_HELP_STRING([--disable-clmul-crc],
 		[Do not use carryless multiplication for CRC calculation
 		even if support for it is detected.]),
 	[], [enable_clmul_crc=yes])
 
 
 ############################
 # ARM64 CRC32 Instructions #
 ############################
 
 AC_ARG_ENABLE([arm64-crc32], AS_HELP_STRING([--disable-arm64-crc32],
 		[Do not use ARM64 CRC32 instructions even if support for it
 		is detected.]),
 	[], [enable_arm64_crc32=yes])
 
 
 #####################
 # Size optimization #
 #####################
 
 AC_MSG_CHECKING([if small size is preferred over speed])
 AC_ARG_ENABLE([small], AS_HELP_STRING([--enable-small],
 		[Make liblzma smaller and a little slower.
 		This is disabled by default to optimize for speed.]),
 	[], [enable_small=no])
 if test "x$enable_small" = xyes; then
 	AC_DEFINE([HAVE_SMALL], [1], [Define to 1 if optimizing for size.])
 elif test "x$enable_small" != xno; then
 	AC_MSG_RESULT([])
 	AC_MSG_ERROR([--enable-small accepts only 'yes' or 'no'])
 fi
 AC_MSG_RESULT([$enable_small])
 AM_CONDITIONAL(COND_SMALL, test "x$enable_small" = xyes)
 
 
 #############
 # Threading #
 #############
 
 AC_MSG_CHECKING([if threading support is wanted])
 AC_ARG_ENABLE([threads], AS_HELP_STRING([--enable-threads=METHOD],
 		[Supported METHODS are 'yes', 'no', 'posix', 'win95', and
 		'vista'. The default is 'yes'. Using 'no' together with
 		--enable-small makes liblzma thread unsafe.]),
 	[], [enable_threads=yes])
 
 if test "x$enable_threads" = xyes; then
 	case $host_os in
 		mingw*)
 			case $host_cpu in
 				i?86)   enable_threads=win95 ;;
 				*)      enable_threads=vista ;;
 			esac
 			;;
 		*)
 			enable_threads=posix
 			;;
 	esac
 fi
 
 case $enable_threads in
 	posix | win95 | vista)
 		AC_MSG_RESULT([yes, $enable_threads])
 		;;
 	no)
 		AC_MSG_RESULT([no])
 		;;
 	*)
 		AC_MSG_RESULT([])
 		AC_MSG_ERROR([--enable-threads only accepts 'yes', 'no', 'posix', 'win95', or 'vista'])
 		;;
 esac
 
 # We use the actual result a little later.
 
 
 #########################
 # Assumed amount of RAM #
 #########################
 
 # We use 128 MiB as default, because it will allow decompressing files
 # created with "xz -9". It would be slightly safer to guess a lower value,
 # but most systems, on which we don't have any way to determine the amount
 # of RAM, will probably have at least 128 MiB of RAM.
 AC_MSG_CHECKING([how much RAM to assume if the real amount is unknown])
 AC_ARG_ENABLE([assume-ram], AS_HELP_STRING([--enable-assume-ram=SIZE],
 		[If and only if the real amount of RAM cannot be determined,
 		assume SIZE MiB. The default is 128 MiB. This affects the
 		default memory usage limit.]),
 	[], [enable_assume_ram=128])
 assume_ram_check=`echo "$enable_assume_ram" | tr -d 0123456789`
 if test -z "$enable_assume_ram" || test -n "$assume_ram_check"; then
 	AC_MSG_RESULT([])
 	AC_MSG_ERROR([--enable-assume-ram accepts only an integer argument])
 fi
 AC_MSG_RESULT([$enable_assume_ram MiB])
 AC_DEFINE_UNQUOTED([ASSUME_RAM], [$enable_assume_ram],
 		[How many MiB of RAM to assume if the real amount cannot
 		be determined.])
 
 
 #########################
 # Components to install #
 #########################
 
 AC_ARG_ENABLE([xz], [AS_HELP_STRING([--disable-xz],
 		[do not build the xz tool])],
 	[], [enable_xz=yes])
 AM_CONDITIONAL([COND_XZ], [test x$enable_xz != xno])
 
 AC_ARG_ENABLE([xzdec], [AS_HELP_STRING([--disable-xzdec],
 		[do not build xzdec])],
 	[], [enable_xzdec=yes])
 test "x$enable_decoders" = xno && enable_xzdec=no
 AM_CONDITIONAL([COND_XZDEC], [test x$enable_xzdec != xno])
 
 AC_ARG_ENABLE([lzmadec], [AS_HELP_STRING([--disable-lzmadec],
 		[do not build lzmadec
 		(it exists primarily for LZMA Utils compatibility)])],
 	[], [enable_lzmadec=yes])
 test "x$enable_decoder_lzma1" = xno && enable_lzmadec=no
 AM_CONDITIONAL([COND_LZMADEC], [test x$enable_lzmadec != xno])
 
 AC_ARG_ENABLE([lzmainfo], [AS_HELP_STRING([--disable-lzmainfo],
 		[do not build lzmainfo
 		(it exists primarily for LZMA Utils compatibility)])],
 	[], [enable_lzmainfo=yes])
 test "x$enable_decoder_lzma1" = xno && enable_lzmainfo=no
 AM_CONDITIONAL([COND_LZMAINFO], [test x$enable_lzmainfo != xno])
 
 AC_ARG_ENABLE([lzma-links], [AS_HELP_STRING([--disable-lzma-links],
 		[do not create symlinks for LZMA Utils compatibility])],
 	[], [enable_lzma_links=yes])
 AM_CONDITIONAL([COND_LZMALINKS], [test x$enable_lzma_links != xno])
 
 AC_ARG_ENABLE([scripts], [AS_HELP_STRING([--disable-scripts],
 		[do not install the scripts xzdiff, xzgrep, xzless, xzmore,
 		and their symlinks])],
 	[], [enable_scripts=yes])
 AM_CONDITIONAL([COND_SCRIPTS], [test x$enable_scripts != xno])
 
 AC_ARG_ENABLE([doc], [AS_HELP_STRING([--disable-doc],
 		[do not install documentation files to docdir
 		(man pages will still be installed)])],
 	[], [enable_doc=yes])
 AM_CONDITIONAL([COND_DOC], [test x$enable_doc != xno])
 
 
 ##############
 # Sandboxing #
 ##############
 
 AC_MSG_CHECKING([if sandboxing should be used])
 AC_ARG_ENABLE([sandbox], [AS_HELP_STRING([--enable-sandbox=METHOD],
 		[Sandboxing METHOD can be
 		'auto', 'no', 'capsicum', 'pledge', or 'landlock'.
 		The default is 'auto' which enables sandboxing if
 		a supported sandboxing method is found.])],
 	[], [enable_sandbox=auto])
 case $enable_xzdec-$enable_xz-$enable_sandbox in
 	no-no-*)
 		enable_sandbox=no
 		AC_MSG_RESULT([no, --disable-xz and --disable-xzdec was used])
 		;;
 	*-*-auto)
 		AC_MSG_RESULT([maybe (autodetect)])
 		;;
 	*-*-no | *-*-capsicum | *-*-pledge | *-*-landlock)
 		AC_MSG_RESULT([$enable_sandbox])
 		;;
 	*)
 		AC_MSG_RESULT([])
 		AC_MSG_ERROR([--enable-sandbox only accepts 'auto', 'no', 'capsicum', 'pledge', or 'landlock'.])
 		;;
 esac
 
 
 ###########################
 # PATH prefix for scripts #
 ###########################
 
 # The scripts can add a prefix to the search PATH so that POSIX tools
 # or the xz binary is always in the PATH.
 AC_ARG_ENABLE([path-for-scripts],
 	[AS_HELP_STRING([--enable-path-for-scripts=PREFIX],
 		[If PREFIX isn't empty, PATH=PREFIX:$PATH will be set in
 		the beginning of the scripts (xzgrep and others).
 		The default is empty except on Solaris the default is
 		/usr/xpg4/bin.])],
 	[], [
 		case $host_os in
 			solaris*) enable_path_for_scripts=/usr/xpg4/bin ;;
 			*)        enable_path_for_scripts= ;;
 		esac
 	])
 if test -n "$enable_path_for_scripts" && test "x$enable_path_for_scripts" != xno ; then
 	enable_path_for_scripts="PATH=$enable_path_for_scripts:\$PATH"
 else
 	enable_path_for_scripts=
 fi
 AC_SUBST([enable_path_for_scripts])
 
 
 ###############################################################################
 # Checks for programs.
 ###############################################################################
 
 echo
 case $host_os in
 	solaris*)
 		# The gnulib POSIX shell macro below may pick a shell that
 		# doesn't work with xzgrep. Workaround by picking a shell
 		# that is known to work.
 		if test -z "$gl_cv_posix_shell" && test -x /usr/xpg4/bin/sh; then
 			gl_cv_posix_shell=/usr/xpg4/bin/sh
 		fi
 		;;
 esac
 gl_POSIX_SHELL
 if test -z "$POSIX_SHELL" && test "x$enable_scripts" = xyes ; then
 	AC_MSG_ERROR([No POSIX conforming shell (sh) was found.])
 fi
 
 echo
 echo "Initializing Automake:"
 
 # We don't use "subdir-objects" yet because it breaks "make distclean" when
 # dependencies are enabled (as of Automake 1.14.1) due to this bug:
 # https://debbugs.gnu.org/cgi/bugreport.cgi?bug=17354
 # The -Wno-unsupported is used to silence warnings about missing
 # "subdir-objects".
 AM_INIT_AUTOMAKE([1.12 foreign tar-v7 filename-length-max=99 -Wno-unsupported])
 AC_PROG_LN_S
 
 dnl # Autoconf >= 2.70 warns that AC_PROG_CC_C99 is obsolete. However,
 dnl # we have to keep using AC_PROG_CC_C99 instead of AC_PROG_CC
 dnl # as long as we try to be compatible with Autoconf 2.69.
 AC_PROG_CC_C99
 if test x$ac_cv_prog_cc_c99 = xno ; then
 	AC_MSG_ERROR([No C99 compiler was found.])
 fi
 
 AM_PROG_CC_C_O
 AM_PROG_AS
 AC_USE_SYSTEM_EXTENSIONS
 
 AS_CASE([$enable_threads],
 	[posix], [
 		echo
 		echo "POSIX threading support:"
 		AX_PTHREAD([:]) dnl We don't need the HAVE_PTHREAD macro.
 		LIBS="$LIBS $PTHREAD_LIBS"
 		AM_CFLAGS="$AM_CFLAGS $PTHREAD_CFLAGS"
 
 		dnl NOTE: PTHREAD_CC is ignored. It would be useful on AIX,
 		dnl but it's tricky to get it right together with
 		dnl AC_PROG_CC_C99. Thus, this is handled by telling the
 		dnl user in INSTALL to set the correct CC manually.
 
 		AC_DEFINE([MYTHREAD_POSIX], [1],
 			[Define to 1 when using POSIX threads (pthreads).])
 
 		# This is nice to have but not mandatory.
 		OLD_CFLAGS=$CFLAGS
 		CFLAGS="$CFLAGS $PTHREAD_CFLAGS"
 		AC_CHECK_FUNCS([pthread_condattr_setclock])
 		CFLAGS=$OLD_CFLAGS
 	],
 	[win95], [
 		AC_DEFINE([MYTHREAD_WIN95], [1], [Define to 1 when using
 			Windows 95 (and thus XP) compatible threads.
 			This avoids use of features that were added in
 			Windows Vista.])
 	],
 	[vista], [
 		AC_DEFINE([MYTHREAD_VISTA], [1], [Define to 1 when using
 			Windows Vista compatible threads. This uses
 			features that are not available on Windows XP.])
 	]
 )
 AM_CONDITIONAL([COND_THREADS], [test "x$enable_threads" != xno])
 
 echo
 echo "Initializing Libtool:"
 LT_PREREQ([2.4])
 LT_INIT([win32-dll])
 LT_LANG([Windows Resource])
 
 # This is a bit wrong since it is possible to request that only some libs
 # are built as shared. Using that feature isn't so common though, and this
 # breaks only on Windows (at least for now) if the user enables only some
 # libs as shared.
 AM_CONDITIONAL([COND_SHARED], [test "x$enable_shared" != xno])
 
 #####################
 # Symbol versioning #
 #####################
 
 # NOTE: This checks if we are building shared or static library
 # and if --with-pic or --without-pic was used. Thus this check
 # must be after Libtool initialization.
 AC_MSG_CHECKING([if library symbol versioning should be used])
 AC_ARG_ENABLE([symbol-versions], [AS_HELP_STRING([--enable-symbol-versions],
 		[Use symbol versioning for liblzma. Enabled by default on
 		GNU/Linux, other GNU-based systems, and FreeBSD.])],
 	[], [enable_symbol_versions=auto])
 if test "x$enable_symbol_versions" = xauto; then
 	case $host_os in
 		# NOTE: Even if one omits -gnu on GNU/Linux (e.g.
 		# i486-slackware-linux), configure will (via config.sub)
 		# append -gnu (e.g. i486-slackware-linux-gnu), and this
 		# test will work correctly.
 		gnu* | *-gnu* | freebsd*)
 			enable_symbol_versions=yes
 			;;
 		*)
 			enable_symbol_versions=no
 			;;
 	esac
 fi
 
 # There are two variants for symbol versioning.
 # See src/liblzma/validate_map.sh for details.
 #
 # On GNU/Linux, extra symbols are added in the C code. These extra symbols
 # must not be put into a static library as they can cause problems (and
 # even if they didn't cause problems, they would be useless). On other
 # systems symbol versioning may be used too but there is no problem as only
 # a linker script is specified in src/liblzma/Makefile.am and that isn't
 # used when creating a static library.
 #
 # Libtool always uses -DPIC when building shared libraries by default and
 # doesn't use it for static libs by default. This can be overridden with
 # --with-pic and --without-pic though. As long as neither --with-pic nor
 # --without-pic is used then we can use #ifdef PIC to detect if the file is
 # being built for a shared library.
 if test "x$enable_symbol_versions" = xno ; then
 	enable_symbol_versions=no
 	AC_MSG_RESULT([no])
 elif test "x$enable_shared" = xno ; then
 	enable_symbol_versions=no
 	AC_MSG_RESULT([no (not building a shared library)])
 else
 	case "$host_cpu-$host_os" in
 		microblaze*)
 			# GCC 12 on MicroBlaze doesn't support __symver__
 			# attribute. It's simplest and safest to use the
 			# generic version on that platform since then only
 			# the linker script is needed. The RHEL/CentOS 7
 			# compatibility symbols don't matter on MicroBlaze.
 			enable_symbol_versions=generic
 			;;
 		*-linux*)
 			case "$pic_mode-$enable_static" in
 				default-*)
 					# Use symvers if PIC is defined.
 					have_symbol_versions_linux=2
 					;;
 				*-no)
 					# Not building static library.
 					# Use symvers unconditionally.
 					have_symbol_versions_linux=1
 					;;
 				*)
 					AC_MSG_RESULT([])
 					AC_MSG_ERROR([
     On GNU/Linux, building both shared and static library at the same time
     is not supported if --with-pic or --without-pic is used.
     Use either --disable-shared or --disable-static to build one type
     of library at a time. If both types are needed, build one at a time,
     possibly picking only src/liblzma/.libs/liblzma.a from the static build.])
 					;;
 			esac
 			enable_symbol_versions=linux
 			AC_DEFINE_UNQUOTED([HAVE_SYMBOL_VERSIONS_LINUX],
 				[$have_symbol_versions_linux],
 				[Define to 1 to if GNU/Linux-specific details
 				are unconditionally wanted for symbol
 				versioning. Define to 2 to if these are wanted
 				only if also PIC is defined (allows building
 				both shared and static liblzma at the same
 				time with Libtool if neither --with-pic nor
 				--without-pic is used). This define must be
 				used together with liblzma_linux.map.])
 			;;
 		*)
 			enable_symbol_versions=generic
 			;;
 	esac
 	AC_MSG_RESULT([yes ($enable_symbol_versions)])
 fi
 
 AM_CONDITIONAL([COND_SYMVERS_LINUX],
 	[test "x$enable_symbol_versions" = xlinux])
 AM_CONDITIONAL([COND_SYMVERS_GENERIC],
 	[test "x$enable_symbol_versions" = xgeneric])
 
 
 ###############################################################################
 # Checks for libraries.
 ###############################################################################
 
 dnl Support for _REQUIRE_VERSION was added in gettext 0.19.6. If both
 dnl _REQUIRE_VERSION and _VERSION are present, the _VERSION is ignored.
 dnl We use both for compatibility with other programs in the Autotools family.
 echo
 echo "Initializing gettext:"
 AM_GNU_GETTEXT_REQUIRE_VERSION([0.19.6])
 AM_GNU_GETTEXT_VERSION([0.19.6])
 AM_GNU_GETTEXT([external])
 
 
 ###############################################################################
 # Checks for header files.
 ###############################################################################
 
 echo
 echo "System headers and functions:"
 
 # There is currently no workarounds in this package if some of
 # these headers are missing.
 AC_CHECK_HEADERS([fcntl.h limits.h sys/time.h],
 	[],
 	[AC_MSG_ERROR([Required header file(s) are missing.])])
 
 # immintrin.h allows the use of the intrinsic functions if they are available.
 # cpuid.h may be used for detecting x86 processor features at runtime.
 AC_CHECK_HEADERS([immintrin.h cpuid.h])
 
 
 ###############################################################################
 # Checks for typedefs, structures, and compiler characteristics.
 ###############################################################################
 
 AC_HEADER_STDBOOL
 
 AC_TYPE_UINT8_T
 AC_TYPE_UINT16_T
 AC_TYPE_INT32_T
 AC_TYPE_UINT32_T
 AC_TYPE_INT64_T
 AC_TYPE_UINT64_T
 AC_TYPE_UINTPTR_T
 
 AC_CHECK_SIZEOF([size_t])
 
 # The command line tool can copy high resolution timestamps if such
 # information is available in struct stat. Otherwise one second accuracy
 # is used.
 AC_CHECK_MEMBERS([
 	struct stat.st_atim.tv_nsec,
 	struct stat.st_atimespec.tv_nsec,
 	struct stat.st_atimensec,
 	struct stat.st_uatime,
 	struct stat.st_atim.st__tim.tv_nsec])
 
 AC_SYS_LARGEFILE
 AC_C_BIGENDIAN
 
 # __attribute__((__constructor__)) can be used for one-time initializations.
 # Use -Werror because some compilers accept unknown attributes and just
 # give a warning.
 #
 # FIXME? Unfortunately -Werror can cause trouble if CFLAGS contains options
 # that produce warnings for unrelated reasons. For example, GCC and Clang
 # support -Wunused-macros which will warn about "#define _GNU_SOURCE 1"
 # which will be among the #defines that Autoconf inserts to the beginning of
 # the test program. There seems to be no nice way to prevent Autoconf from
 # inserting the any defines to the test program.
 AC_MSG_CHECKING([if __attribute__((__constructor__)) can be used])
 have_func_attribute_constructor=no
 OLD_CFLAGS="$CFLAGS"
 CFLAGS="$CFLAGS -Werror"
 AC_COMPILE_IFELSE([AC_LANG_SOURCE([[
 	__attribute__((__constructor__))
 	static void my_constructor_func(void) { return; }
 ]])], [
 	AC_DEFINE([HAVE_FUNC_ATTRIBUTE_CONSTRUCTOR], [1],
 		[Define to 1 if __attribute__((__constructor__))
 		is supported for functions.])
 	have_func_attribute_constructor=yes
 	AC_MSG_RESULT([yes])
 ], [
 	AC_MSG_RESULT([no])
 ])
 CFLAGS="$OLD_CFLAGS"
 
 # The Win95 threading lacks a thread-safe one-time initialization function.
 # The one-time initialization is needed for crc32_small.c and crc64_small.c
 # create the CRC tables. So if small mode is enabled, the threading mode is
 # win95, and the compiler does not support attribute constructor, then we
 # would end up with a multithreaded build that is thread-unsafe. As a
 # result this configuration is not allowed.
 if test "x$enable_small$enable_threads$have_func_attribute_constructor" \
 		= xyeswin95no; then
 	AC_MSG_ERROR([
     --enable-threads=win95 and --enable-small cannot be used
     at the same time with a compiler that doesn't support
     __attribute__((__constructor__))])
 fi
 
 # __attribute__((__ifunc__())) can be used to choose between different
 # implementations of the same function at runtime. This is slightly more
 # efficient than using __attribute__((__constructor__)) and setting
 # a function pointer.
 AC_ARG_ENABLE([ifunc], [AS_HELP_STRING([--enable-ifunc],
 		[Use __attribute__((__ifunc__())). Enabled by default on
 		GNU/Linux (glibc) and FreeBSD.])],
 	[], [enable_ifunc=auto])
 
 # When enable_ifunc is 'auto', allow the use of __attribute__((__ifunc__()))
 # if compiler support is detected and we are building for GNU/Linux (glibc)
 # or FreeBSD. uClibc and musl don't support ifunc in their dynamic linkers
 # but some compilers still accept the attribute when compiling for these
 # C libraries, which results in broken binaries. That's why we need to
 # check which libc is being used.
 if test "x$enable_ifunc" = xauto ; then
 	OLD_CFLAGS="$CFLAGS"
 	CFLAGS="$CFLAGS -Werror"
 	AC_MSG_CHECKING([if __attribute__((__ifunc__())) can be used])
 	AC_COMPILE_IFELSE([AC_LANG_SOURCE([[
 		/*
 		 * Force a compilation error when not using glibc on Linux
 		 * or if we are not using FreeBSD. uClibc will define
 		 * __GLIBC__ but does not support ifunc, so we must have
 		 * an extra check to disable with uClibc.
 		 */
 		#if defined(__linux__)
 		#	include <features.h>
 		#	if !defined(__GLIBC__) || defined(__UCLIBC__)
 				compile error
 		#	endif
 		#elif !defined(__FreeBSD__)
 			compile error
 		#endif
 
 		static void func(void) { return; }
 		static void (*resolve_func (void)) (void) { return func; }
 		void func_ifunc (void)
 				__attribute__((__ifunc__("resolve_func")));
 		/*
 		 * 'clang -Wall' incorrectly warns that resolve_func is
 		 * unused (-Wunused-function). Correct assembly output is
 		 * still produced. This problem exists at least in Clang
 		 * versions 4 to 17. The following silences the bogus warning:
 		 */
 		void make_clang_quiet(void);
 		void make_clang_quiet(void) { resolve_func()(); }
 	]])], [
 		enable_ifunc=yes
 	], [
 		enable_ifunc=no
 	])
 
 	AC_MSG_RESULT([$enable_ifunc])
 
 	CFLAGS="$OLD_CFLAGS"
 fi
 
 if test "x$enable_ifunc" = xyes ; then
 	AC_DEFINE([HAVE_FUNC_ATTRIBUTE_IFUNC], [1],
 			[Define to 1 if __attribute__((__ifunc__()))
 			is supported for functions.])
 
 	# ifunc explicitly does not work with -fsanitize=address.
 	# If configured, it will result in a liblzma build that will fail
 	# when liblzma is loaded at runtime (when the ifunc resolver
 	# executes).
 	AS_CASE([$CFLAGS], [*-fsanitize=*], [AC_MSG_ERROR([
     CFLAGS contains '-fsanitize=' which is incompatible with ifunc.
     Use --disable-ifunc when using '-fsanitize'.])])
 fi
 
 
 ###############################################################################
 # Checks for library functions.
 ###############################################################################
 
 # Gnulib replacements as needed
 gl_GETOPT
 
 # If clock_gettime() is available, liblzma with pthreads may use it, and
 # xz may use it even when threading support is disabled. In XZ Utils 5.4.x
 # and older, configure checked for clock_gettime() only when using pthreads.
 # This way non-threaded builds of liblzma didn't get a useless dependency on
 # librt which further had a dependency on libpthread. Avoiding these was
 # useful when a small build was needed, for example, for initramfs use.
 #
 # The above reasoning is thoroughly obsolete: On GNU/Linux, librt hasn't
 # been needed for clock_gettime() since glibc 2.17 (2012-12-25).
 # Solaris 10 needs librt but Solaris 11 doesn't anymore.
 AC_SEARCH_LIBS([clock_gettime], [rt])
 AC_CHECK_FUNCS([clock_gettime])
 AC_CHECK_DECL([CLOCK_MONOTONIC], [AC_DEFINE([HAVE_CLOCK_MONOTONIC], [1],
 	[Define to 1 if 'CLOCK_MONOTONIC' is declared in <time.h>.])], [],
 	[[#include <time.h>]])
 
 # Find the best function to set timestamps.
 AC_CHECK_FUNCS([futimens futimes futimesat utimes _futime utime], [break])
 
 # This is nice to have but not mandatory.
 AC_CHECK_FUNCS([posix_fadvise])
 
 TUKLIB_PROGNAME
 TUKLIB_INTEGER
 TUKLIB_PHYSMEM
 TUKLIB_CPUCORES
 TUKLIB_MBSTR
 
 # If requested, check for system-provided SHA-256. At least the following
 # implementations are supported:
 #
 # OS       Headers                     Library  Type           Function
 # FreeBSD  sys/types.h + sha256.h      libmd    SHA256_CTX     SHA256_Init
 # NetBSD   sys/types.h + sha2.h                 SHA256_CTX     SHA256_Init
 # OpenBSD  sys/types.h + sha2.h                 SHA2_CTX       SHA256Init
 # Solaris  sys/types.h + sha2.h        libmd    SHA256_CTX     SHA256Init
 # MINIX 3  sys/types.h + sha2.h                 SHA256_CTX     SHA256_Init
 # Darwin   CommonCrypto/CommonDigest.h          CC_SHA256_CTX  CC_SHA256_Init
 #
 # Note that Darwin's CC_SHA256_Update takes buffer size as uint32_t instead
 # of size_t.
 #
 sha256_header_found=no
 sha256_type_found=no
 sha256_func_found=no
 AS_IF([test "x$enable_external_sha256" = "xyes"], [
 	# Test for Common Crypto before others, because Darwin has sha256.h
 	# too and we don't want to use that, because on older versions it
 	# uses OpenSSL functions, whose SHA256_Init is not guaranteed to
 	# succeed.
 	AC_CHECK_HEADERS(
 		[CommonCrypto/CommonDigest.h sha256.h sha2.h],
 		[sha256_header_found=yes ; break])
 	if test "x$sha256_header_found" = xyes; then
 		AC_CHECK_TYPES([CC_SHA256_CTX, SHA256_CTX, SHA2_CTX],
 			[sha256_type_found=yes], [],
 			[[#ifdef HAVE_SYS_TYPES_H
 			  # include <sys/types.h>
 			  #endif
 			  #ifdef HAVE_COMMONCRYPTO_COMMONDIGEST_H
 			  # include <CommonCrypto/CommonDigest.h>
 			  #endif
 			  #ifdef HAVE_SHA256_H
 			  # include <sha256.h>
 			  #endif
 			  #ifdef HAVE_SHA2_H
 			  # include <sha2.h>
 			  #endif]])
 		if test "x$sha256_type_found" = xyes ; then
 			AC_SEARCH_LIBS([SHA256Init], [md])
 			AC_SEARCH_LIBS([SHA256_Init], [md])
 			AC_CHECK_FUNCS([CC_SHA256_Init SHA256Init SHA256_Init],
 				[sha256_func_found=yes ; break])
 		fi
 	fi
 ])
 AM_CONDITIONAL([COND_INTERNAL_SHA256], [test "x$sha256_func_found" = xno])
 if test "x$enable_external_sha256$sha256_func_found" = xyesno; then
 	AC_MSG_ERROR([--enable-external-sha256 was specified but no supported external SHA-256 implementation was found])
 fi
 
 # Check for SSE2 intrinsics. There is no run-time detection for SSE2 so if
 # compiler options enable SSE2 then SSE2 support is required by the binaries.
 # The compile-time check for SSE2 is done with #ifdefs because some compilers
 # (ICC, MSVC) allow SSE2 intrinsics even when SSE2 isn't enabled.
 AC_CHECK_DECL([_mm_movemask_epi8],
 	[AC_DEFINE([HAVE__MM_MOVEMASK_EPI8], [1],
 		[Define to 1 if _mm_movemask_epi8 is available.])],
 	[],
 [#ifdef HAVE_IMMINTRIN_H
 #include <immintrin.h>
 #endif])
 
 # For faster CRC on 32/64-bit x86 and E2K (see also crc64_fast.c):
 #
 #   - Check for the CLMUL intrinsic _mm_clmulepi64_si128 in <immintrin.h>.
 #     Check also for _mm_set_epi64x for consistency with CMake build
 #     where it's needed to disable CLMUL with VS2013.
 #
 #   - Check that __attribute__((__target__("ssse3,sse4.1,pclmul"))) works
 #     together with _mm_clmulepi64_si128 from <immintrin.h>. The attribute
 #     was added in GCC 4.4 but some GCC 4.x versions don't allow intrinsics
 #     with it. Exception: it must be not be used with EDG-based compilers
 #     like ICC and the compiler on E2K.
 #
 # If everything above is supported, runtime detection will be used to keep the
 # binaries working on systems that don't support the required extensions.
 AC_MSG_CHECKING([if _mm_clmulepi64_si128 is usable])
 AS_IF([test "x$enable_clmul_crc" = xno], [
 	AC_MSG_RESULT([no, --disable-clmul-crc was used])
 ], [
 	AC_COMPILE_IFELSE([AC_LANG_SOURCE([[
 #include <immintrin.h>
 
 // CLMUL works on older E2K instruction set but it is slow due to emulation.
 #if defined(__e2k__) && __iset__ < 6
 #	error
 #endif
 
 // Intel's old compiler (ICC) can define __GNUC__ but the attribute must not
 // be used with it. The new Clang-based ICX needs the attribute.
 // Checking for !defined(__EDG__) catches ICC and other EDG-based compilers.
 #if (defined(__GNUC__) || defined(__clang__)) && !defined(__EDG__)
 __attribute__((__target__("ssse3,sse4.1,pclmul")))
 #endif
 __m128i my_clmul(__m128i a)
 {
 	const __m128i b = _mm_set_epi64x(1, 2);
 	return _mm_clmulepi64_si128(a, b, 0);
 }
 	]])], [
 		AC_DEFINE([HAVE_USABLE_CLMUL], [1],
 			[Define to 1 if _mm_set_epi64x and
 			_mm_clmulepi64_si128 are usable.
 			See configure.ac for details.])
 		enable_clmul_crc=yes
 	], [
 		enable_clmul_crc=no
 	])
 	AC_MSG_RESULT([$enable_clmul_crc])
 ])
 
 # ARM64 C Language Extensions define CRC32 functions in arm_acle.h.
 # These are supported by at least GCC and Clang which both need
 # __attribute__((__target__("+crc"))), unless the needed compiler flags
 # are used to support the CRC instruction.
 AC_MSG_CHECKING([if ARM64 CRC32 instruction is usable])
 AS_IF([test "x$enable_arm64_crc32" = xno], [
 	AC_MSG_RESULT([no, --disable-arm64-crc32 was used])
 ], [
 	# Set -Werror here because some versions of Clang (14 and older)
 	# do not report the unsupported __attribute__((__target__("+crc")))
 	# or __crc32d() as an error, only as a warning. This does not need
 	# to be done with CMake because tests will attempt to link and the
 	# error will be reported then.
 	OLD_CFLAGS="$CFLAGS"
 	CFLAGS="$CFLAGS -Werror"
 
 	AC_COMPILE_IFELSE([AC_LANG_SOURCE([[
 #include <arm_acle.h>
 #include <stdint.h>
 
 #if (defined(__GNUC__) || defined(__clang__)) && !defined(__EDG__)
 __attribute__((__target__("+crc")))
 #endif
 uint32_t my_crc(uint32_t a, uint64_t b)
 {
 	return __crc32d(a, b);
 }
 	]])], [
 		AC_DEFINE([HAVE_ARM64_CRC32], [1],
 			[Define to 1 if ARM64 CRC32 instruction is supported.
 			See configure.ac for details.])
 		enable_arm64_crc32=yes
 	], [
 		enable_arm64_crc32=no
 	])
 	AC_MSG_RESULT([$enable_arm64_crc32])
 
 	CFLAGS="$OLD_CFLAGS"
 ])
 
 # Check for ARM64 CRC32 instruction runtime detection.
 # getauxval() is supported on Linux, elf_aux_info() on FreeBSD, and
 # sysctlbyname("hw.optional.armv8_crc32", ...) is supported on Darwin
 # (macOS, iOS, etc.). Note that sysctlbyname() is supported on FreeBSD,
 # NetBSD, and possibly others too but the string is specific to Apple OSes.
 # The C code is responsible for checking defined(__APPLE__) before using
 # sysctlbyname("hw.optional.armv8_crc32", ...).
 AS_IF([test "x$enable_arm64_crc32" = xyes], [
 	AC_CHECK_FUNCS([getauxval elf_aux_info sysctlbyname])
 ])
 
 
 # Check for sandbox support. If one is found, set enable_sandbox=found.
 #
 # About -fsanitize: Of our three sandbox methods, only Landlock is
 # incompatible with -fsanitize. FreeBSD 13.2 with Capsicum was tested with
 # -fsanitize=address,undefined and had no issues. OpenBSD (as of version
 # 7.4) has minimal support for process instrumentation. OpenBSD does not
 # distribute the additional libraries needed (libasan, libubsan, etc.) with
 # GCC or Clang needed for runtime sanitization support and instead only
 # support -fsanitize-minimal-runtime for minimal undefined behavior
 # sanitization. This minimal support is compatible with our use of the
 # Pledge sandbox. So only Landlock will result in a build that cannot
 # compress or decompress a single file to standard out.
 AS_CASE([$enable_sandbox],
 	[auto | capsicum], [
 		AC_CHECK_FUNCS([cap_rights_limit], [enable_sandbox=found])
 	]
 )
 AS_CASE([$enable_sandbox],
 	[auto | pledge], [
 		AC_CHECK_FUNCS([pledge], [enable_sandbox=found])
 	]
 )
 AS_CASE([$enable_sandbox],
 	[auto | landlock], [
-		AC_CHECK_HEADERS([linux/landlock.h], [
+		AC_MSG_CHECKING([if Linux Landlock is usable])
+
+		# A compile check is done here because some systems have
+		# linux/landlock.h, but do not have the syscalls defined
+		# in order to actually use Linux Landlock.
+		AC_COMPILE_IFELSE([AC_LANG_SOURCE([[
+			#include <linux/landlock.h>
+			#include <sys/syscall.h>
+			#include <sys/prctl.h>
+
+			void my_sandbox(void)
+			{
+				(void)prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0);
+				(void)SYS_landlock_create_ruleset;
+				(void)SYS_landlock_restrict_self;
+				(void)LANDLOCK_CREATE_RULESET_VERSION;
+				return;
+			}
+		]])], [
 			enable_sandbox=found
 
 			AS_CASE([$CFLAGS], [*-fsanitize=*], [AC_MSG_ERROR([
     CFLAGS contains '-fsanitize=' which is incompatible with the Landlock
     sandboxing. Use --disable-sandbox when using '-fsanitize'.])])
+
+			AC_DEFINE([HAVE_LINUX_LANDLOCK], [1],
+				[Define to 1 if Linux Landlock is supported.
+				See configure.ac for details.])
+			AC_MSG_RESULT([yes])
+		], [
+			AC_MSG_RESULT([no])
 		])
 	]
 )
 
 # If a specific sandboxing method was explicitly requested and it wasn't
 # found, give an error.
 case $enable_sandbox in
 	auto | no | found)
 		;;
 	*)
 		AC_MSG_ERROR([$enable_sandbox support not found])
 		;;
 esac
 
 
 ###############################################################################
 # If using GCC, set some additional AM_CFLAGS:
 ###############################################################################
 
 if test "$GCC" = yes ; then
 	echo
 	echo "GCC extensions:"
 fi
 
 # Always do the visibility check but don't set AM_CFLAGS on Windows.
 # This way things get set properly even on Windows.
 gl_VISIBILITY
 if test -n "$CFLAG_VISIBILITY" && test "$is_w32" = no; then
 	AM_CFLAGS="$AM_CFLAGS $CFLAG_VISIBILITY"
 fi
 
 AS_IF([test "$GCC" = yes], [
 	# Enable as much warnings as possible. These commented warnings won't
 	# work for this package though:
 	#   * -Wunreachable-code breaks several assert(0) cases, which are
 	#     backed up with "return LZMA_PROG_ERROR".
 	#   * -Wcast-qual would break various things where we need a non-const
 	#     pointer although we don't modify anything through it.
 	#   * -Winline, -Wdisabled-optimization, -Wunsafe-loop-optimizations
 	#     don't seem so useful here; at least the last one gives some
 	#     warnings which are not bugs.
 	#   * -Wconversion still shows too many warnings.
 	#
 	# The flags before the empty line are for GCC and many of them
 	# are supported by Clang too. The flags after the empty line are
 	# for Clang.
 	for NEW_FLAG in \
 			-Wall \
 			-Wextra \
 			-Wvla \
 			-Wformat=2 \
 			-Winit-self \
 			-Wmissing-include-dirs \
 			-Wshift-overflow=2 \
 			-Wstrict-overflow=3 \
 			-Walloc-zero \
 			-Wduplicated-cond \
 			-Wfloat-equal \
 			-Wundef \
 			-Wshadow \
 			-Wpointer-arith \
 			-Wbad-function-cast \
 			-Wwrite-strings \
 			-Wdate-time \
 			-Wsign-conversion \
 			-Wfloat-conversion \
 			-Wlogical-op \
 			-Waggregate-return \
 			-Wstrict-prototypes \
 			-Wold-style-definition \
 			-Wmissing-prototypes \
 			-Wmissing-declarations \
 			-Wredundant-decls \
 			\
 			-Wc99-compat \
 			-Wc11-extensions \
 			-Wc2x-compat \
 			-Wc2x-extensions \
 			-Wpre-c2x-compat \
 			-Warray-bounds-pointer-arithmetic \
 			-Wassign-enum \
 			-Wconditional-uninitialized \
 			-Wdocumentation \
 			-Wduplicate-enum \
 			-Wempty-translation-unit \
 			-Wflexible-array-extensions \
 			-Wmissing-variable-declarations \
 			-Wnewline-eof \
 			-Wshift-sign-overflow \
 			-Wstring-conversion
 	do
 		AC_MSG_CHECKING([if $CC accepts $NEW_FLAG])
 		OLD_CFLAGS="$CFLAGS"
 		CFLAGS="$CFLAGS $NEW_FLAG -Werror"
 		AC_COMPILE_IFELSE([AC_LANG_SOURCE(
 				[[void foo(void); void foo(void) { }]])], [
 			AM_CFLAGS="$AM_CFLAGS $NEW_FLAG"
 			AC_MSG_RESULT([yes])
 		], [
 			AC_MSG_RESULT([no])
 		])
 		CFLAGS="$OLD_CFLAGS"
 	done
 
 	AC_ARG_ENABLE([werror],
 		AS_HELP_STRING([--enable-werror], [Enable -Werror to abort
 			compilation on all compiler warnings.]),
 		[], [enable_werror=no])
 	if test "x$enable_werror" = "xyes"; then
 		AM_CFLAGS="$AM_CFLAGS -Werror"
 	fi
 ])
 
 
 ###############################################################################
 # Create the makefiles and config.h
 ###############################################################################
 
 echo
 
 # Don't build the lib directory at all if we don't need any replacement
 # functions.
 AM_CONDITIONAL([COND_GNULIB], test -n "$LIBOBJS")
 
 # Add default AM_CFLAGS.
 AC_SUBST([AM_CFLAGS])
 
 # This is needed for src/scripts.
 xz=`echo xz | sed "$program_transform_name"`
 AC_SUBST([xz])
 
 AC_CONFIG_FILES([
 	Makefile
 	po/Makefile.in
 	lib/Makefile
 	src/Makefile
 	src/liblzma/Makefile
 	src/liblzma/api/Makefile
 	src/xz/Makefile
 	src/xzdec/Makefile
 	src/lzmainfo/Makefile
 	src/scripts/Makefile
 	tests/Makefile
 	debug/Makefile
 ])
 AC_CONFIG_FILES([src/scripts/xzdiff], [chmod +x src/scripts/xzdiff])
 AC_CONFIG_FILES([src/scripts/xzgrep], [chmod +x src/scripts/xzgrep])
 AC_CONFIG_FILES([src/scripts/xzmore], [chmod +x src/scripts/xzmore])
 AC_CONFIG_FILES([src/scripts/xzless], [chmod +x src/scripts/xzless])
 
 AC_OUTPUT
 
 # Some warnings
 if test x$tuklib_cv_physmem_method = xunknown; then
 	echo
 	echo "WARNING:"
 	echo "No supported method to detect the amount of RAM."
 	echo "Consider using --enable-assume-ram (if you didn't already)"
 	echo "or make a patch to add support for this operating system."
 fi
 
 if test x$tuklib_cv_cpucores_method = xunknown; then
 	echo
 	echo "WARNING:"
 	echo "No supported method to detect the number of CPU cores."
 fi
 
 if test "x$enable_threads$enable_small$have_func_attribute_constructor" \
 		= xnoyesno; then
 	echo
 	echo "NOTE:"
 	echo "liblzma will be thread-unsafe due to the combination"
 	echo "of --disable-threads --enable-small when using a compiler"
 	echo "that doesn't support __attribute__((__constructor__))."
 fi
diff --git a/src/xz/sandbox.c b/src/xz/sandbox.c
index 3b3069c8..5bd22737 100644
--- a/src/xz/sandbox.c
+++ b/src/xz/sandbox.c
@@ -1,355 +1,355 @@
 // SPDX-License-Identifier: 0BSD
 
 ///////////////////////////////////////////////////////////////////////////////
 //
 /// \file       sandbox.c
 /// \brief      Sandbox support
 //
 //  Author:     Lasse Collin
 //
 ///////////////////////////////////////////////////////////////////////////////
 
 #include "private.h"
 
 
 #ifndef ENABLE_SANDBOX
 
 // Prevent an empty translation unit when no sandboxing is supported.
 typedef int dummy;
 
 #else
 
 /// If the conditions for strict sandboxing (described in main())
 /// have been met, sandbox_allow_strict() can be called to set this
 /// variable to true.
 static bool strict_sandbox_allowed = false;
 
 
 extern void
 sandbox_allow_strict(void)
 {
 	strict_sandbox_allowed = true;
 	return;
 }
 
 
 // Strict sandboxing prevents opening any files. This *tries* to ensure
 // that any auxiliary files that might be required are already open.
 //
 // Returns true if strict sandboxing is allowed, false otherwise.
 static bool
 prepare_for_strict_sandbox(void)
 {
 	if (!strict_sandbox_allowed)
 		return false;
 
 	const char dummy_str[] = "x";
 
 	// Try to ensure that both libc and xz locale files have been
 	// loaded when NLS is enabled.
 	snprintf(NULL, 0, "%s%s", _(dummy_str), strerror(EINVAL));
 
 	// Try to ensure that iconv data files needed for handling multibyte
 	// characters have been loaded. This is needed at least with glibc.
 	tuklib_mbstr_width(dummy_str, NULL);
 
 	return true;
 }
 
 #endif
 
 
 #if defined(HAVE_PLEDGE)
 
 ///////////////
 // pledge(2) //
 ///////////////
 
 #include <unistd.h>
 
 
 extern void
 sandbox_init(void)
 {
 	if (pledge("stdio rpath wpath cpath fattr", "")) {
 		// gettext hasn't been initialized yet so
 		// there's no point to call it here.
 		message_fatal("Failed to enable the sandbox");
 	}
 
 	return;
 }
 
 
 extern void
 sandbox_enable_read_only(void)
 {
 	// We will be opening files for reading but
 	// won't create or remove any files.
 	if (pledge("stdio rpath", ""))
 		message_fatal(_("Failed to enable the sandbox"));
 
 	return;
 }
 
 
 extern void
 sandbox_enable_strict_if_allowed(int src_fd lzma_attribute((__unused__)),
 		int pipe_event_fd lzma_attribute((__unused__)),
 		int pipe_write_fd lzma_attribute((__unused__)))
 {
 	if (!prepare_for_strict_sandbox())
 		return;
 
 	// All files that need to be opened have already been opened.
 	if (pledge("stdio", ""))
 		message_fatal(_("Failed to enable the sandbox"));
 
 	return;
 }
 
 
-#elif defined(HAVE_LINUX_LANDLOCK_H)
+#elif defined(HAVE_LINUX_LANDLOCK)
 
 //////////////
 // Landlock //
 //////////////
 
 #include <linux/landlock.h>
 #include <sys/syscall.h>
 #include <sys/prctl.h>
 
 
 // Highest Landlock ABI version supported by this file:
 //   - For ABI versions 1-3 we don't need anything from <linux/landlock.h>
 //     that isn't part of version 1.
 //   - For ABI version 4 we need the larger struct landlock_ruleset_attr
 //     with the handled_access_net member. That is bundled with the macros
 //     LANDLOCK_ACCESS_NET_BIND_TCP and LANDLOCK_ACCESS_NET_CONNECT_TCP.
 #ifdef LANDLOCK_ACCESS_NET_BIND_TCP
 #	define LANDLOCK_ABI_MAX 4
 #else
 #	define LANDLOCK_ABI_MAX 3
 #endif
 
 
 /// Landlock ABI version supported by the kernel
 static int landlock_abi;
 
 
 // The required_rights should have those bits set that must not be restricted.
 // This function will then bitwise-and ~required_rights with a mask matching
 // the Landlock ABI version, leaving only those bits set that are supported
 // by the ABI and allowed to be restricted by the function argument.
 static void
 enable_landlock(uint64_t required_rights)
 {
 	assert(landlock_abi <= LANDLOCK_ABI_MAX);
 
 	if (landlock_abi <= 0)
 		return;
 
 	// We want to set all supported flags in handled_access_fs.
 	// This way the ruleset will initially forbid access to all
 	// actions that the available Landlock ABI version supports.
 	// Exceptions can be added using landlock_add_rule(2) to
 	// allow certain actions on certain files or directories.
 	//
 	// The same flag values are used on all archs. ABI v2 and v3
 	// both add one new flag.
 	//
 	// First in ABI v1: LANDLOCK_ACCESS_FS_EXECUTE = 1ULL << 0
 	// Last in ABI v1: LANDLOCK_ACCESS_FS_MAKE_SYM = 1ULL << 12
 	// Last in ABI v2: LANDLOCK_ACCESS_FS_REFER = 1ULL << 13
 	// Last in ABI v3: LANDLOCK_ACCESS_FS_TRUNCATE = 1ULL << 14
 	//
 	// This makes it simple to set the mask based on the ABI
 	// version and we don't need to care which flags are #defined
 	// in the installed <linux/landlock.h> for ABI versions 1-3.
 	const struct landlock_ruleset_attr attr = {
 		.handled_access_fs = ~required_rights
 			& ((1ULL << (12 + my_min(3, landlock_abi))) - 1),
 #if LANDLOCK_ABI_MAX >= 4
 		.handled_access_net = landlock_abi < 4 ? 0 :
 				(LANDLOCK_ACCESS_NET_BIND_TCP
 				| LANDLOCK_ACCESS_NET_CONNECT_TCP),
 #endif
 	};
 
 	const int ruleset_fd = syscall(SYS_landlock_create_ruleset,
 			&attr, sizeof(attr), 0U);
 	if (ruleset_fd < 0)
 		message_fatal(_("Failed to enable the sandbox"));
 
 	// All files we need should have already been opened. Thus,
 	// we don't need to add any rules using landlock_add_rule(2)
 	// before activating the sandbox.
 	//
 	// NOTE: It's possible that the hack prepare_for_strict_sandbox()
 	// isn't be good enough. It tries to get translations and
 	// libc-specific files loaded but if it's not good enough
 	// then perhaps a Landlock rule to allow reading from /usr
 	// and/or the xz installation prefix would be needed.
 	//
 	// prctl(PR_SET_NO_NEW_PRIVS, ...) was already called in
 	// sandbox_init() so we don't do it here again.
 	if (syscall(SYS_landlock_restrict_self, ruleset_fd, 0U) != 0)
 		message_fatal(_("Failed to enable the sandbox"));
 
 	return;
 }
 
 
 extern void
 sandbox_init(void)
 {
 	// Prevent the process from gaining new privileges. This must be done
 	// before landlock_restrict_self(2) but since we will never need new
 	// privileges, this call can be done here already.
 	//
 	// This is supported since Linux 3.5. Ignore the return value to
 	// keep compatibility with old kernels. landlock_restrict_self(2)
 	// will fail if the no_new_privs attribute isn't set, thus if prctl()
 	// fails here the error will still be detected when it matters.
 	(void)prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0);
 
 	// Get the highest Landlock ABI version supported by the kernel.
 	landlock_abi = syscall(SYS_landlock_create_ruleset,
 			(void *)NULL, 0, LANDLOCK_CREATE_RULESET_VERSION);
 
 	// The kernel might support a newer ABI than this file.
 	if (landlock_abi > LANDLOCK_ABI_MAX)
 		landlock_abi = LANDLOCK_ABI_MAX;
 
 	// These are all in ABI version 1 already. We don't need truncate
 	// rights because files are created with open() using O_EXCL and
 	// without O_TRUNC.
 	//
 	// LANDLOCK_ACCESS_FS_READ_DIR is included here to get a clear error
 	// message if xz is given a directory name. Without this permission
 	// the message would be "Permission denied" but with this permission
 	// it's "Is a directory, skipping". It could be worked around with
 	// stat()/lstat() but just giving this permission is simpler and
 	// shouldn't make the sandbox much weaker in practice.
 	const uint64_t required_rights
 			= LANDLOCK_ACCESS_FS_WRITE_FILE
 			| LANDLOCK_ACCESS_FS_READ_FILE
 			| LANDLOCK_ACCESS_FS_READ_DIR
 			| LANDLOCK_ACCESS_FS_REMOVE_FILE
 			| LANDLOCK_ACCESS_FS_MAKE_REG;
 
 	enable_landlock(required_rights);
 	return;
 }
 
 
 extern void
 sandbox_enable_read_only(void)
 {
 	// We will be opening files for reading but
 	// won't create or remove any files.
 	const uint64_t required_rights
 			= LANDLOCK_ACCESS_FS_READ_FILE
 			| LANDLOCK_ACCESS_FS_READ_DIR;
 	enable_landlock(required_rights);
 	return;
 }
 
 
 extern void
 sandbox_enable_strict_if_allowed(int src_fd lzma_attribute((__unused__)),
 		int pipe_event_fd lzma_attribute((__unused__)),
 		int pipe_write_fd lzma_attribute((__unused__)))
 {
 	if (!prepare_for_strict_sandbox())
 		return;
 
 	// Allow all restrictions that the kernel supports with the
 	// highest Landlock ABI version that the kernel or xz supports.
 	//
 	// NOTE: LANDLOCK_ACCESS_FS_READ_DIR isn't needed here because
 	// the only input file has already been opened.
 	enable_landlock(0);
 	return;
 }
 
 
 #elif defined(HAVE_CAP_RIGHTS_LIMIT)
 
 //////////////
 // Capsicum //
 //////////////
 
 #include <sys/capsicum.h>
 
 
 extern void
 sandbox_init(void)
 {
 	// Nothing to do.
 	return;
 }
 
 
 extern void
 sandbox_enable_read_only(void)
 {
 	// Nothing to do.
 	return;
 }
 
 
 extern void
 sandbox_enable_strict_if_allowed(
 		int src_fd, int pipe_event_fd, int pipe_write_fd)
 {
 	if (!prepare_for_strict_sandbox())
 		return;
 
 	// Capsicum needs FreeBSD 10.2 or later.
 	cap_rights_t rights;
 
 	if (cap_enter())
 		goto error;
 
 	if (cap_rights_limit(src_fd, cap_rights_init(&rights,
 			CAP_EVENT, CAP_FCNTL, CAP_LOOKUP, CAP_READ, CAP_SEEK)))
 		goto error;
 
 	// If not reading from stdin, remove all capabilities from it.
 	if (src_fd != STDIN_FILENO && cap_rights_limit(
 			STDIN_FILENO, cap_rights_clear(&rights)))
 		goto error;
 
 	if (cap_rights_limit(STDOUT_FILENO, cap_rights_init(&rights,
 			CAP_EVENT, CAP_FCNTL, CAP_FSTAT, CAP_LOOKUP,
 			CAP_WRITE, CAP_SEEK)))
 		goto error;
 
 	if (cap_rights_limit(STDERR_FILENO, cap_rights_init(&rights,
 			CAP_WRITE)))
 		goto error;
 
 	if (cap_rights_limit(pipe_event_fd, cap_rights_init(&rights,
 			CAP_EVENT)))
 		goto error;
 
 	if (cap_rights_limit(pipe_write_fd, cap_rights_init(&rights,
 			CAP_WRITE)))
 		goto error;
 
 	return;
 
 error:
 	// If a kernel is configured without capability mode support or
 	// used in an emulator that does not implement the capability
 	// system calls, then the Capsicum system calls will fail and set
 	// errno to ENOSYS. In that case xz will silently run without
 	// the sandbox.
 	if (errno == ENOSYS)
 		return;
 
 	message_fatal(_("Failed to enable the sandbox"));
 }
 
 #endif
diff --git a/src/xz/sandbox.h b/src/xz/sandbox.h
index f41b4725..98b9862a 100644
--- a/src/xz/sandbox.h
+++ b/src/xz/sandbox.h
@@ -1,43 +1,43 @@
 // SPDX-License-Identifier: 0BSD
 
 ///////////////////////////////////////////////////////////////////////////////
 //
 /// \file       sandbox.h
 /// \brief      Sandbox support
 //
 //  Author:     Lasse Collin
 //
 ///////////////////////////////////////////////////////////////////////////////
 
-#if defined(HAVE_PLEDGE) || defined(HAVE_LINUX_LANDLOCK_H) \
+#if defined(HAVE_PLEDGE) || defined(HAVE_LINUX_LANDLOCK) \
 		|| defined(HAVE_CAP_RIGHTS_LIMIT)
 #	define ENABLE_SANDBOX 1
 #endif
 
 
 /// \brief      Enables early sandboxing that can always be enabled
 ///
 /// This requires that tuklib_progname() and io_init() have been called.
 extern void sandbox_init(void);
 
 
 /// \brief      Enable sandboxing that only allows opening files for reading
 extern void sandbox_enable_read_only(void);
 
 
 /// \brief      Tell sandboxing code that strict sandboxing can be used
 ///
 /// This function only sets a flag which will be read by
 /// sandbox_enable_strict_if_allowed().
 extern void sandbox_allow_strict(void);
 
 
 /// \brief      Enable sandboxing that allows reading from one file
 ///
 /// This does nothing if sandbox_allow_strict() hasn't been called.
 ///
 /// \param      src_fd          File descriptor open for reading
 /// \param      pipe_event_fd   user_abort_pipe[0] from file_io.c
 /// \param      pipe_write_fd   user_abort_pipe[1] from file_io.c
 extern void sandbox_enable_strict_if_allowed(
 		int src_fd, int pipe_event_fd, int pipe_write_fd);
diff --git a/src/xzdec/xzdec.c b/src/xzdec/xzdec.c
index 6fd0be39..ef8c80f3 100644
--- a/src/xzdec/xzdec.c
+++ b/src/xzdec/xzdec.c
@@ -1,464 +1,464 @@
 // SPDX-License-Identifier: 0BSD
 
 ///////////////////////////////////////////////////////////////////////////////
 //
 /// \file       xzdec.c
 /// \brief      Simple single-threaded tool to uncompress .xz or .lzma files
 //
 //  Author:     Lasse Collin
 //
 ///////////////////////////////////////////////////////////////////////////////
 
 #include "sysdefs.h"
 #include "lzma.h"
 
 #include <stdarg.h>
 #include <errno.h>
 #include <stdio.h>
 
 #ifndef _MSC_VER
 #	include <unistd.h>
 #endif
 
 #ifdef HAVE_CAP_RIGHTS_LIMIT
 #	include <sys/capsicum.h>
 #endif
 
-#ifdef HAVE_LINUX_LANDLOCK_H
+#ifdef HAVE_LINUX_LANDLOCK
 #	include <linux/landlock.h>
 #	include <sys/prctl.h>
 #	include <sys/syscall.h>
 #endif
 
 #if defined(HAVE_CAP_RIGHTS_LIMIT) || defined(HAVE_PLEDGE) \
-		|| defined(HAVE_LINUX_LANDLOCK_H)
+		|| defined(HAVE_LINUX_LANDLOCK)
 #	define ENABLE_SANDBOX 1
 #endif
 
 #include "getopt.h"
 #include "tuklib_progname.h"
 #include "tuklib_exit.h"
 
 #ifdef TUKLIB_DOSLIKE
 #	include <fcntl.h>
 #	include <io.h>
 #	ifdef _MSC_VER
 #		define fileno _fileno
 #		define setmode _setmode
 #	endif
 #endif
 
 
 #ifdef LZMADEC
 #	define TOOL_FORMAT "lzma"
 #else
 #	define TOOL_FORMAT "xz"
 #endif
 
 
 /// Error messages are suppressed if this is zero, which is the case when
 /// --quiet has been given at least twice.
 static int display_errors = 2;
 
 
 lzma_attribute((__format__(__printf__, 1, 2)))
 static void
 my_errorf(const char *fmt, ...)
 {
 	va_list ap;
 	va_start(ap, fmt);
 
 	if (display_errors) {
 		fprintf(stderr, "%s: ", progname);
 		vfprintf(stderr, fmt, ap);
 		fprintf(stderr, "\n");
 	}
 
 	va_end(ap);
 	return;
 }
 
 
 tuklib_attr_noreturn
 static void
 help(void)
 {
 	printf(
 "Usage: %s [OPTION]... [FILE]...\n"
 "Decompress files in the ." TOOL_FORMAT " format to standard output.\n"
 "\n"
 "  -d, --decompress   (ignored, only decompression is supported)\n"
 "  -k, --keep         (ignored, files are never deleted)\n"
 "  -c, --stdout       (ignored, output is always written to standard output)\n"
 "  -q, --quiet        specify *twice* to suppress errors\n"
 "  -Q, --no-warn      (ignored, the exit status 2 is never used)\n"
 "  -h, --help         display this help and exit\n"
 "  -V, --version      display the version number and exit\n"
 "\n"
 "With no FILE, or when FILE is -, read standard input.\n"
 "\n"
 "Report bugs to <" PACKAGE_BUGREPORT "> (in English or Finnish).\n"
 PACKAGE_NAME " home page: <" PACKAGE_URL ">\n", progname);
 
 	tuklib_exit(EXIT_SUCCESS, EXIT_FAILURE, display_errors);
 }
 
 
 tuklib_attr_noreturn
 static void
 version(void)
 {
 	printf(TOOL_FORMAT "dec (" PACKAGE_NAME ") " LZMA_VERSION_STRING "\n"
 			"liblzma %s\n", lzma_version_string());
 
 	tuklib_exit(EXIT_SUCCESS, EXIT_FAILURE, display_errors);
 }
 
 
 /// Parses command line options.
 static void
 parse_options(int argc, char **argv)
 {
 	static const char short_opts[] = "cdkM:hqQV";
 	static const struct option long_opts[] = {
 		{ "stdout",       no_argument,         NULL, 'c' },
 		{ "to-stdout",    no_argument,         NULL, 'c' },
 		{ "decompress",   no_argument,         NULL, 'd' },
 		{ "uncompress",   no_argument,         NULL, 'd' },
 		{ "keep",         no_argument,         NULL, 'k' },
 		{ "quiet",        no_argument,         NULL, 'q' },
 		{ "no-warn",      no_argument,         NULL, 'Q' },
 		{ "help",         no_argument,         NULL, 'h' },
 		{ "version",      no_argument,         NULL, 'V' },
 		{ NULL,           0,                   NULL, 0   }
 	};
 
 	int c;
 
 	while ((c = getopt_long(argc, argv, short_opts, long_opts, NULL))
 			!= -1) {
 		switch (c) {
 		case 'c':
 		case 'd':
 		case 'k':
 		case 'Q':
 			break;
 
 		case 'q':
 			if (display_errors > 0)
 				--display_errors;
 
 			break;
 
 		case 'h':
 			help();
 
 		case 'V':
 			version();
 
 		default:
 			exit(EXIT_FAILURE);
 		}
 	}
 
 	return;
 }
 
 
 static void
 uncompress(lzma_stream *strm, FILE *file, const char *filename)
 {
 	lzma_ret ret;
 
 	// Initialize the decoder
 #ifdef LZMADEC
 	ret = lzma_alone_decoder(strm, UINT64_MAX);
 #else
 	ret = lzma_stream_decoder(strm, UINT64_MAX, LZMA_CONCATENATED);
 #endif
 
 	// The only reasonable error here is LZMA_MEM_ERROR.
 	if (ret != LZMA_OK) {
 		my_errorf("%s", ret == LZMA_MEM_ERROR ? strerror(ENOMEM)
 				: "Internal error (bug)");
 		exit(EXIT_FAILURE);
 	}
 
 	// Input and output buffers
 	uint8_t in_buf[BUFSIZ];
 	uint8_t out_buf[BUFSIZ];
 
 	strm->avail_in = 0;
 	strm->next_out = out_buf;
 	strm->avail_out = BUFSIZ;
 
 	lzma_action action = LZMA_RUN;
 
 	while (true) {
 		if (strm->avail_in == 0) {
 			strm->next_in = in_buf;
 			strm->avail_in = fread(in_buf, 1, BUFSIZ, file);
 
 			if (ferror(file)) {
 				// POSIX says that fread() sets errno if
 				// an error occurred. ferror() doesn't
 				// touch errno.
 				my_errorf("%s: Error reading input file: %s",
 						filename, strerror(errno));
 				exit(EXIT_FAILURE);
 			}
 
 #ifndef LZMADEC
 			// When using LZMA_CONCATENATED, we need to tell
 			// liblzma when it has got all the input.
 			if (feof(file))
 				action = LZMA_FINISH;
 #endif
 		}
 
 		ret = lzma_code(strm, action);
 
 		// Write and check write error before checking decoder error.
 		// This way as much data as possible gets written to output
 		// even if decoder detected an error.
 		if (strm->avail_out == 0 || ret != LZMA_OK) {
 			const size_t write_size = BUFSIZ - strm->avail_out;
 
 			if (fwrite(out_buf, 1, write_size, stdout)
 					!= write_size) {
 				// Wouldn't be a surprise if writing to stderr
 				// would fail too but at least try to show an
 				// error message.
 				my_errorf("Cannot write to standard output: "
 						"%s", strerror(errno));
 				exit(EXIT_FAILURE);
 			}
 
 			strm->next_out = out_buf;
 			strm->avail_out = BUFSIZ;
 		}
 
 		if (ret != LZMA_OK) {
 			if (ret == LZMA_STREAM_END) {
 #ifdef LZMADEC
 				// Check that there's no trailing garbage.
 				if (strm->avail_in != 0
 						|| fread(in_buf, 1, 1, file)
 							!= 0
 						|| !feof(file))
 					ret = LZMA_DATA_ERROR;
 				else
 					return;
 #else
 				// lzma_stream_decoder() already guarantees
 				// that there's no trailing garbage.
 				assert(strm->avail_in == 0);
 				assert(action == LZMA_FINISH);
 				assert(feof(file));
 				return;
 #endif
 			}
 
 			const char *msg;
 			switch (ret) {
 			case LZMA_MEM_ERROR:
 				msg = strerror(ENOMEM);
 				break;
 
 			case LZMA_FORMAT_ERROR:
 				msg = "File format not recognized";
 				break;
 
 			case LZMA_OPTIONS_ERROR:
 				// FIXME: Better message?
 				msg = "Unsupported compression options";
 				break;
 
 			case LZMA_DATA_ERROR:
 				msg = "File is corrupt";
 				break;
 
 			case LZMA_BUF_ERROR:
 				msg = "Unexpected end of input";
 				break;
 
 			default:
 				msg = "Internal error (bug)";
 				break;
 			}
 
 			my_errorf("%s: %s", filename, msg);
 			exit(EXIT_FAILURE);
 		}
 	}
 }
 
 
 #ifdef ENABLE_SANDBOX
 static void
 sandbox_enter(int src_fd)
 {
 #if defined(HAVE_CAP_RIGHTS_LIMIT)
 	// Capsicum needs FreeBSD 10.2 or later.
 	cap_rights_t rights;
 
 	if (cap_enter())
 		goto error;
 
 	if (cap_rights_limit(src_fd, cap_rights_init(&rights, CAP_READ)))
 		goto error;
 
 	// If not reading from stdin, remove all capabilities from it.
 	if (src_fd != STDIN_FILENO && cap_rights_limit(
 			STDIN_FILENO, cap_rights_clear(&rights)))
 		goto error;
 
 	if (cap_rights_limit(STDOUT_FILENO, cap_rights_init(&rights, CAP_WRITE)))
 		goto error;
 
 	if (cap_rights_limit(STDERR_FILENO, cap_rights_init(&rights, CAP_WRITE)))
 		goto error;
 
 #elif defined(HAVE_PLEDGE)
 	// pledge() was introduced in OpenBSD 5.9.
 	if (pledge("stdio", ""))
 		goto error;
 
 	(void)src_fd;
-#elif defined(HAVE_LINUX_LANDLOCK_H)
+#elif defined(HAVE_LINUX_LANDLOCK)
 	int landlock_abi = syscall(SYS_landlock_create_ruleset,
 			(void *)NULL, 0, LANDLOCK_CREATE_RULESET_VERSION);
 
 	if (landlock_abi > 0) {
 		// We support ABI versions 1-3.
 		if (landlock_abi > 3)
 			landlock_abi = 3;
 
 		const struct landlock_ruleset_attr attr = {
 			.handled_access_fs = (1ULL << (12 + landlock_abi)) - 1
 		};
 
 		const int ruleset_fd = syscall(SYS_landlock_create_ruleset,
 				&attr, sizeof(attr), 0U);
 		if (ruleset_fd < 0)
 			goto error;
 
 		// All files we need should have already been opened. Thus,
 		// we don't need to add any rules using landlock_add_rule(2)
 		// before activating the sandbox.
 		if (syscall(SYS_landlock_restrict_self, ruleset_fd, 0U) != 0)
 			goto error;
 	}
 
 	(void)src_fd;
 #else
 #	error ENABLE_SANDBOX is defined but no sandboxing method was found.
 #endif
 
 	return;
 
 error:
 #ifdef HAVE_CAP_RIGHTS_LIMIT
 	// If a kernel is configured without capability mode support or
 	// used in an emulator that does not implement the capability
 	// system calls, then the Capsicum system calls will fail and set
 	// errno to ENOSYS. In that case xzdec will silently run without
 	// the sandbox.
 	if (errno == ENOSYS)
 		return;
 #endif
 	my_errorf("Failed to enable the sandbox");
 	exit(EXIT_FAILURE);
 }
 #endif
 
 
 int
 main(int argc, char **argv)
 {
 #ifdef HAVE_PLEDGE
 	// OpenBSD's pledge(2) sandbox.
 	// Initially enable the sandbox slightly more relaxed so that
 	// the process can still open files. This allows the sandbox to
 	// be enabled when parsing command line arguments and decompressing
 	// all files (the more strict sandbox only restricts the last file
 	// that is decompressed).
 	if (pledge("stdio rpath", "")) {
 		my_errorf("Failed to enable the sandbox");
 		exit(EXIT_FAILURE);
 	}
 #endif
 
-#ifdef HAVE_LINUX_LANDLOCK_H
+#ifdef HAVE_LINUX_LANDLOCK
 	// Prevent the process from gaining new privileges. The return
 	// is ignored to keep compatibility with old kernels.
 	(void)prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0);
 #endif
 
 	// Initialize progname which we will be used in error messages.
 	tuklib_progname_init(argv);
 
 	// Parse the command line options.
 	parse_options(argc, argv);
 
 	// The same lzma_stream is used for all files that we decode. This way
 	// we don't need to reallocate memory for every file if they use same
 	// compression settings.
 	lzma_stream strm = LZMA_STREAM_INIT;
 
 	// Some systems require setting stdin and stdout to binary mode.
 #ifdef TUKLIB_DOSLIKE
 	setmode(fileno(stdin), O_BINARY);
 	setmode(fileno(stdout), O_BINARY);
 #endif
 
 	if (optind == argc) {
 		// No filenames given, decode from stdin.
 #ifdef ENABLE_SANDBOX
 		sandbox_enter(STDIN_FILENO);
 #endif
 		uncompress(&strm, stdin, "(stdin)");
 	} else {
 		// Loop through the filenames given on the command line.
 		do {
 			FILE *src_file;
 			const char *src_name;
 
 			// "-" indicates stdin.
 			if (strcmp(argv[optind], "-") == 0) {
 				src_file = stdin;
 				src_name = "(stdin)";
 			} else {
 				src_name = argv[optind];
 				src_file = fopen(src_name, "rb");
 				if (src_file == NULL) {
 					my_errorf("%s: %s", src_name,
 							strerror(errno));
 					exit(EXIT_FAILURE);
 				}
 			}
 #ifdef ENABLE_SANDBOX
 			// Enable the sandbox for the last file. When the
 			// strict sandbox is enabled the process can no
 			// longer open additional files. It is likely that
 			// the most common way to use xzdec is to
 			// decompress a single file, so this fully protects
 			// most use cases.
 			if (optind == argc - 1)
 				sandbox_enter(fileno(src_file));
 #endif
 			uncompress(&strm, src_file, src_name);
 
 			if (src_file != stdin)
 				fclose(src_file);
 		} while (++optind < argc);
 	}
 
 #ifndef NDEBUG
 	// Free the memory only when debugging. Freeing wastes some time,
 	// but allows detecting possible memory leaks with Valgrind.
 	lzma_end(&strm);
 #endif
 
 	tuklib_exit(EXIT_SUCCESS, EXIT_FAILURE, display_errors);
 }