commit 8bf9f72ee1c05b9e205a72807e8a9e304785673d
Author: Jia Tan <jiat0218@gmail.com>
Date:   Sun Feb 25 21:41:55 2024 +0800

    Fix typos in NEWS and CMakeLists.

diff --git a/CMakeLists.txt b/CMakeLists.txt
index 4924f436..b783399c 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -1,2035 +1,2035 @@
 # SPDX-License-Identifier: 0BSD
 
 #############################################################################
 #
 # CMake support for building XZ Utils
 #
 # The complete CMake-based build hasn't been tested much yet and
 # thus it's still slightly experimental. Testing this especially
 # outside GNU/Linux and Windows would be great now.
 #
 # A few things are still missing compared to the Autotools-based build:
 #
 #   - A few tests aren't CMake compatible yet and thus aren't run!
 #
 #   - 32-bit x86 assembly code for CRC32 and CRC64 isn't used.
 #
 #   - External SHA-256 code isn't supported but it's disabled by
 #     default in the Autotools build too (--enable-external-sha256).
 #
 #   - Extra compiler warning flags aren't added by default.
 #
 # About CMAKE_BUILD_TYPE:
 #
 #   - CMake's standard choices are fine to use for production builds,
 #     including "Release" and "RelWithDebInfo".
 #
 #     NOTE: While "Release" uses -O3 by default with some compilers,
 #     this file overrides -O3 to -O2 for "Release" builds if
 #     CMAKE_C_FLAGS_RELEASE is not defined by the user. At least
 #     with GCC and Clang/LLVM, -O3 doesn't seem useful for this
 #     package as it can result in bigger binaries without any
 #     improvement in speed compared to -O2.
 #
 #   - Empty value (the default) is handled slightly specially: It
 #     adds -DNDEBUG to disable debugging code (assert() and a few
 #     other things). No optimization flags are added so an empty
 #     CMAKE_BUILD_TYPE is an easy way to build with whatever
 #     optimization flags one wants, and so this method is also
 #     suitable for production builds.
 #
 #     If debugging is wanted when using empty CMAKE_BUILD_TYPE,
 #     include -UNDEBUG in the CFLAGS environment variable or
 #     in the CMAKE_C_FLAGS CMake variable to override -DNDEBUG.
 #     With empty CMAKE_BUILD_TYPE, the -UNDEBUG option will go
 #     after the -DNDEBUG option on the compiler command line and
 #     thus NDEBUG will be undefined.
 #
 #   - Non-standard build types like "None" aren't treated specially
 #     and thus won't have -DNEBUG. Such non-standard build types
 #     SHOULD BE AVOIDED FOR PRODUCTION BUILDS. Or at least one
 #     should remember to add -DNDEBUG.
 #
 # If building from xz.git instead of a release tarball, consider
 # the following *before* running cmake:
 #
 #   - To get translated messages, install GNU gettext tools (the
 #     command msgfmt is needed). Alternatively disable translations
 #     by setting ENABLE_NLS=OFF.
 #
 #   - To get translated man pages, run po4a/update-po which requires
 #     the po4a tool. The build works without this step too.
 #
 #   - To get Doxygen-generated liblzma API docs in HTML format,
 #     run doxygen/update-doxygen which requires the doxygen tool.
 #     The build works without this step too.
 #
 # This file provides the following installation components (if you only
 # need liblzma, install only its components!):
 #   - liblzma_Runtime (shared library only)
 #   - liblzma_Development
 #   - liblzma_Documentation (examples and Doxygen-generated API docs as HTML)
 #   - xz_Runtime (xz, the symlinks, and possibly translation files)
 #   - xz_Documentation (xz man pages and the symlinks)
 #   - xzdec_Runtime
 #   - xzdec_Documentation (xzdec *and* lzmadec man pages)
 #   - lzmadec_Runtime
 #   - lzmainfo_Runtime
 #   - lzmainfo_Documentation (lzmainfo man pages)
 #   - scripts_Runtime (xzdiff, xzgrep, xzless, xzmore)
 #   - scripts_Documentation (their man pages)
 #   - Documentation (generic docs like README and licenses)
 #
 # To find the target liblzma::liblzma from other packages, use the CONFIG
 # option with find_package() to avoid a conflict with the FindLibLZMA module
 # with case-insensitive file systems. For example, to require liblzma 5.2.5
 # or a newer compatible version:
 #
 #     find_package(liblzma 5.2.5 REQUIRED CONFIG)
 #     target_link_libraries(my_application liblzma::liblzma)
 #
 #############################################################################
 #
 # Author: Lasse Collin
 #
 #############################################################################
 
 # NOTE: Translation support is disabled with CMake older than 3.20.
 cmake_minimum_required(VERSION 3.14...3.28 FATAL_ERROR)
 
 include(CMakePushCheckState)
 include(CheckIncludeFile)
 include(CheckSymbolExists)
 include(CheckStructHasMember)
 include(CheckCSourceCompiles)
 include(cmake/tuklib_large_file_support.cmake)
 include(cmake/tuklib_integer.cmake)
 include(cmake/tuklib_cpucores.cmake)
 include(cmake/tuklib_physmem.cmake)
 include(cmake/tuklib_progname.cmake)
 include(cmake/tuklib_mbstr.cmake)
 
 set(PACKAGE_NAME "XZ Utils")
 set(PACKAGE_BUGREPORT "xz@tukaani.org")
 set(PACKAGE_URL "https://xz.tukaani.org/xz-utils/")
 
 # Get the package version from version.h into PACKAGE_VERSION variable.
 file(READ src/liblzma/api/lzma/version.h PACKAGE_VERSION)
 string(REGEX REPLACE
 "^.*\n\
 #define LZMA_VERSION_MAJOR ([0-9]+)\n\
 .*\
 #define LZMA_VERSION_MINOR ([0-9]+)\n\
 .*\
 #define LZMA_VERSION_PATCH ([0-9]+)\n\
 .*$"
        "\\1.\\2.\\3" PACKAGE_VERSION "${PACKAGE_VERSION}")
 
 # With several compilers, CMAKE_BUILD_TYPE=Release uses -O3 optimization
 # which results in bigger code without a clear difference in speed. If
 # no user-defined CMAKE_C_FLAGS_RELEASE is present, override -O3 to -O2
 # to make it possible to recommend CMAKE_BUILD_TYPE=Release.
 if(NOT DEFINED CMAKE_C_FLAGS_RELEASE)
     set(OVERRIDE_O3_IN_C_FLAGS_RELEASE ON)
 endif()
 
 # Among other things, this gives us variables xz_VERSION and xz_VERSION_MAJOR.
 project(xz VERSION "${PACKAGE_VERSION}" LANGUAGES C)
 
 if(OVERRIDE_O3_IN_C_FLAGS_RELEASE)
     # Looking at CMake's source, there aren't any _FLAGS_RELEASE_INIT
     # entries where "-O3" would appear as part of some other option,
     # thus a simple search and replace should be fine.
     string(REPLACE -O3 -O2 CMAKE_C_FLAGS_RELEASE "${CMAKE_C_FLAGS_RELEASE}")
 
     # Update the cache value while keeping its docstring unchanged.
     set_property(CACHE CMAKE_C_FLAGS_RELEASE
                  PROPERTY VALUE "${CMAKE_C_FLAGS_RELEASE}")
 endif()
 
 # We need a compiler that supports enough C99 or newer (variable-length arrays
 # aren't needed, those are optional in C17). Setting CMAKE_C_STANDARD here
 # makes it the default for all targets. It doesn't affect the INTERFACE so
 # liblzma::liblzma won't end up with INTERFACE_COMPILE_FEATURES "c_std_99"
 # (the API headers are C89 and C++ compatible).
 set(CMAKE_C_STANDARD 99)
 set(CMAKE_C_STANDARD_REQUIRED ON)
 
 # On Apple OSes, don't build executables as bundles:
 set(CMAKE_MACOSX_BUNDLE OFF)
 
 # Set CMAKE_INSTALL_LIBDIR and friends. This needs to be done before
 # the LOCALEDIR_DEFINITION workaround below.
 include(GNUInstallDirs)
 
 # windres from GNU binutils can be tricky with command line arguments
 # that contain spaces or other funny characters. Unfortunately we need
 # a space in PACKAGE_NAME. Using \x20 to encode the US-ASCII space seems
 # to work in both cmd.exe and /bin/sh.
 #
 # However, even \x20 isn't enough in all situations, resulting in
 # "syntax error" from windres. Using --use-temp-file prevents windres
 # from using popen() and this seems to fix the problem.
 #
 # llvm-windres from Clang/LLVM 16.0.6 and older: The \x20 results
 # in "XZx20Utils" in the compiled binary. The option --use-temp-file
 # makes no difference.
 #
 # llvm-windres 17.0.0 and later: It emulates GNU windres more accurately, so
 # the workarounds used with GNU windres must be used with llvm-windres too.
 #
 # CMake 3.27 doesn't have CMAKE_RC_COMPILER_ID so we rely on
 # CMAKE_C_COMPILER_ID.
 if((MINGW OR CYGWIN OR MSYS) AND (
         NOT CMAKE_C_COMPILER_ID STREQUAL "Clang" OR
         CMAKE_C_COMPILER_VERSION VERSION_GREATER_EQUAL "17"))
     # Use workarounds with GNU windres and llvm-windres >= 17.0.0. The \x20
     # in PACKAGE_NAME_DEFINITION works with gcc and clang too so we don't need
     # to worry how to pass different flags to windres and the C compiler.
     # Keep the original PACKAGE_NAME intact for generation of liblzma.pc.
     string(APPEND CMAKE_RC_FLAGS " --use-temp-file")
     string(REPLACE " " "\\x20" PACKAGE_NAME_DEFINITION "${PACKAGE_NAME}")
 
     # Use octal because "Program Files" would become \x20F.
     string(REPLACE " " "\\040" LOCALEDIR_DEFINITION
            "${CMAKE_INSTALL_FULL_LOCALEDIR}")
 else()
     # Elsewhere a space is safe. This also keeps things compatible with
     # EBCDIC in case CMake-based build is ever done on such a system.
     set(PACKAGE_NAME_DEFINITION "${PACKAGE_NAME}")
     set(LOCALEDIR_DEFINITION "${CMAKE_INSTALL_FULL_LOCALEDIR}")
 endif()
 
 # Definitions common to all targets:
 add_compile_definitions(
     # Package info:
     PACKAGE_NAME="${PACKAGE_NAME_DEFINITION}"
     PACKAGE_BUGREPORT="${PACKAGE_BUGREPORT}"
     PACKAGE_URL="${PACKAGE_URL}"
 
     # Standard headers and types are available:
     HAVE_STDBOOL_H
     HAVE__BOOL
     HAVE_STDINT_H
     HAVE_INTTYPES_H
 
     # Always enable CRC32 since liblzma should never build without it.
     HAVE_CHECK_CRC32
 
     # Disable assert() checks when no build type has been specified. Non-empty
     # build types like "Release" and "Debug" handle this by default.
     $<$<CONFIG:>:NDEBUG>
 )
 
 
 ######################
 # System definitions #
 ######################
 
 # _GNU_SOURCE and such definitions. This specific macro is special since
 # it also adds the definitions to CMAKE_REQUIRED_DEFINITIONS.
 tuklib_use_system_extensions(ALL)
 
 # Check for large file support. It's required on some 32-bit platforms and
 # even on 64-bit MinGW-w64 to get 64-bit off_t. This can be forced off on
 # the CMake command line if needed: -DLARGE_FILE_SUPPORT=OFF
 tuklib_large_file_support(ALL)
 
 # This is needed by liblzma and xz.
 tuklib_integer(ALL)
 
 # This is used for liblzma.pc generation to add -lrt if needed.
 set(LIBS)
 
 # Check for clock_gettime(). Do this before checking for threading so
 # that we know there if CLOCK_MONOTONIC is available.
 check_symbol_exists(clock_gettime time.h HAVE_CLOCK_GETTIME)
 
 if(NOT HAVE_CLOCK_GETTIME)
     # With glibc <= 2.17 or Solaris 10 this needs librt.
     # Add librt for the next check for HAVE_CLOCK_GETTIME. If it is
     # found after including the library, we know that librt is required.
     list(INSERT CMAKE_REQUIRED_LIBRARIES 0 rt)
     check_symbol_exists(clock_gettime time.h HAVE_CLOCK_GETTIME_LIBRT)
 
     # If it was found now, add librt to all targets and keep it in
     # CMAKE_REQUIRED_LIBRARIES for further tests too.
     if(HAVE_CLOCK_GETTIME_LIBRT)
         link_libraries(rt)
         set(LIBS "-lrt") # For liblzma.pc
     else()
         list(REMOVE_AT CMAKE_REQUIRED_LIBRARIES 0)
     endif()
 endif()
 
 if(HAVE_CLOCK_GETTIME OR HAVE_CLOCK_GETTIME_LIBRT)
     add_compile_definitions(HAVE_CLOCK_GETTIME)
 
     # Check if CLOCK_MONOTONIC is available for clock_gettime().
     check_symbol_exists(CLOCK_MONOTONIC time.h HAVE_CLOCK_MONOTONIC)
     tuklib_add_definition_if(ALL HAVE_CLOCK_MONOTONIC)
 endif()
 
 # Translation support requires CMake 3.20 because it added the Intl::Intl
 # target so we don't need to play with the individual variables.
 #
-# The defintion ENABLE_NLS is added only to those targets that use it, thus
+# The definition ENABLE_NLS is added only to those targets that use it, thus
 # it's not done here. (xz has translations, xzdec doesn't.)
 if(CMAKE_VERSION VERSION_GREATER_EQUAL "3.20")
     find_package(Intl)
     find_package(Gettext)
     if(Intl_FOUND)
         option(ENABLE_NLS "Native Language Support (translated messages)" ON)
 
         # The *installed* name of the translation files is "xz.mo".
         set(TRANSLATION_DOMAIN "xz")
     endif()
 endif()
 
 # Options for new enough GCC or Clang on any arch or operating system:
 if(CMAKE_C_COMPILER_ID MATCHES GNU|Clang)
     # configure.ac has a long list but it won't be copied here:
     add_compile_options(-Wall -Wextra)
 endif()
 
 
 #############################################################################
 # liblzma
 #############################################################################
 
 option(BUILD_SHARED_LIBS "Build liblzma as a shared library instead of static")
 
 add_library(liblzma
     src/common/mythread.h
     src/common/sysdefs.h
     src/common/tuklib_common.h
     src/common/tuklib_config.h
     src/common/tuklib_integer.h
     src/common/tuklib_physmem.c
     src/common/tuklib_physmem.h
     src/liblzma/api/lzma.h
     src/liblzma/api/lzma/base.h
     src/liblzma/api/lzma/bcj.h
     src/liblzma/api/lzma/block.h
     src/liblzma/api/lzma/check.h
     src/liblzma/api/lzma/container.h
     src/liblzma/api/lzma/delta.h
     src/liblzma/api/lzma/filter.h
     src/liblzma/api/lzma/hardware.h
     src/liblzma/api/lzma/index.h
     src/liblzma/api/lzma/index_hash.h
     src/liblzma/api/lzma/lzma12.h
     src/liblzma/api/lzma/stream_flags.h
     src/liblzma/api/lzma/version.h
     src/liblzma/api/lzma/vli.h
     src/liblzma/check/check.c
     src/liblzma/check/check.h
     src/liblzma/check/crc_common.h
     src/liblzma/check/crc_x86_clmul.h
     src/liblzma/check/crc32_arm64.h
     src/liblzma/common/block_util.c
     src/liblzma/common/common.c
     src/liblzma/common/common.h
     src/liblzma/common/easy_preset.c
     src/liblzma/common/easy_preset.h
     src/liblzma/common/filter_common.c
     src/liblzma/common/filter_common.h
     src/liblzma/common/hardware_physmem.c
     src/liblzma/common/index.c
     src/liblzma/common/index.h
     src/liblzma/common/memcmplen.h
     src/liblzma/common/stream_flags_common.c
     src/liblzma/common/stream_flags_common.h
     src/liblzma/common/string_conversion.c
     src/liblzma/common/vli_size.c
 )
 
 target_include_directories(liblzma PRIVATE
     src/liblzma/api
     src/liblzma/common
     src/liblzma/check
     src/liblzma/lz
     src/liblzma/rangecoder
     src/liblzma/lzma
     src/liblzma/delta
     src/liblzma/simple
     src/common
 )
 
 
 ######################
 # Size optimizations #
 ######################
 
 option(ENABLE_SMALL "Reduce code size at expense of speed. \
 This may be useful together with CMAKE_BUILD_TYPE=MinSizeRel.")
 
 if(ENABLE_SMALL)
     add_compile_definitions(HAVE_SMALL)
 endif()
 
 
 ##########
 # Checks #
 ##########
 
 set(ADDITIONAL_SUPPORTED_CHECKS crc64 sha256)
 
 set(ADDITIONAL_CHECK_TYPES "${ADDITIONAL_SUPPORTED_CHECKS}" CACHE STRING
     "Additional check types to support (crc32 is always built)")
 
 foreach(CHECK IN LISTS ADDITIONAL_CHECK_TYPES)
     if(NOT CHECK IN_LIST ADDITIONAL_SUPPORTED_CHECKS)
         message(FATAL_ERROR "'${CHECK}' is not a supported check type")
     endif()
 endforeach()
 
 if(ENABLE_SMALL)
     target_sources(liblzma PRIVATE src/liblzma/check/crc32_small.c)
 else()
     target_sources(liblzma PRIVATE
         src/liblzma/check/crc32_fast.c
         src/liblzma/check/crc32_table.c
         src/liblzma/check/crc32_table_be.h
         src/liblzma/check/crc32_table_le.h
     )
 endif()
 
 if("crc64" IN_LIST ADDITIONAL_CHECK_TYPES)
     add_compile_definitions("HAVE_CHECK_CRC64")
 
     if(ENABLE_SMALL)
         target_sources(liblzma PRIVATE src/liblzma/check/crc64_small.c)
     else()
         target_sources(liblzma PRIVATE
             src/liblzma/check/crc64_fast.c
             src/liblzma/check/crc64_table.c
             src/liblzma/check/crc64_table_be.h
             src/liblzma/check/crc64_table_le.h
         )
     endif()
 endif()
 
 if("sha256" IN_LIST ADDITIONAL_CHECK_TYPES)
     add_compile_definitions("HAVE_CHECK_SHA256")
     target_sources(liblzma PRIVATE src/liblzma/check/sha256.c)
 endif()
 
 
 #################
 # Match finders #
 #################
 
 set(SUPPORTED_MATCH_FINDERS hc3 hc4 bt2 bt3 bt4)
 
 set(MATCH_FINDERS "${SUPPORTED_MATCH_FINDERS}" CACHE STRING
     "Match finders to support (at least one is required for LZMA1 or LZMA2)")
 
 foreach(MF IN LISTS MATCH_FINDERS)
     if(MF IN_LIST SUPPORTED_MATCH_FINDERS)
         string(TOUPPER "${MF}" MF_UPPER)
         add_compile_definitions("HAVE_MF_${MF_UPPER}")
     else()
         message(FATAL_ERROR "'${MF}' is not a supported match finder")
     endif()
 endforeach()
 
 
 #############
 # Threading #
 #############
 
 # Supported threading methods:
 # ON    - autodetect the best threading method. The autodetection will
 #         prefer Windows threading (win95 or vista) over posix if both are
 #         available. vista threads will be used over win95 unless it is a
 #         32-bit build.
 # OFF   - Disable threading.
 # posix - Use posix threading (pthreads), or throw an error if not available.
 # win95 - Use Windows win95 threading, or throw an error if not available.
 # vista - Use Windows vista threading, or throw an error if not available.
 set(SUPPORTED_THREADING_METHODS ON OFF posix win95 vista)
 
 set(ENABLE_THREADS ON CACHE STRING
     "Threading method: Set to 'ON' to autodetect, 'OFF' to disable threading.")
 
 # Create dropdown in CMake GUI since only 1 threading method is possible
 # to select in a build.
 set_property(CACHE ENABLE_THREADS
              PROPERTY STRINGS "${SUPPORTED_THREADING_METHODS}")
 
 # This is a flag variable set when win95 threads are used. We must ensure
 # the combination of enable_small and win95 threads is not used without a
 # compiler supporting attribute __constructor__.
 set(USE_WIN95_THREADS OFF)
 
 # This is a flag variable set when posix threads (pthreads) are used.
 # It's needed when creating liblzma-config.cmake where dependency on
 # Threads::Threads is only needed with pthreads.
 set(USE_POSIX_THREADS OFF)
 
 if(NOT ENABLE_THREADS IN_LIST SUPPORTED_THREADING_METHODS)
     message(FATAL_ERROR "'${ENABLE_THREADS}' is not a supported "
                         "threading method")
 endif()
 
 if(ENABLE_THREADS)
     # Also set THREADS_PREFER_PTHREAD_FLAG since the flag has no effect
     # for Windows threading.
     set(THREADS_PREFER_PTHREAD_FLAG TRUE)
     find_package(Threads REQUIRED)
 
     # If both Windows and posix threading are available, prefer Windows.
     # Note that on Cygwin CMAKE_USE_WIN32_THREADS_INIT is false.
     if(CMAKE_USE_WIN32_THREADS_INIT AND NOT ENABLE_THREADS STREQUAL "posix")
         if(ENABLE_THREADS STREQUAL "win95"
                 OR (ENABLE_THREADS STREQUAL "ON"
                     AND CMAKE_SIZEOF_VOID_P EQUAL 4))
             # Use Windows 95 (and thus XP) compatible threads.
             # This avoids use of features that were added in
             # Windows Vista. This is used for 32-bit x86 builds for
             # compatibility reasons since it makes no measurable difference
             # in performance compared to Vista threads.
             set(USE_WIN95_THREADS ON)
             add_compile_definitions(MYTHREAD_WIN95)
         else()
             add_compile_definitions(MYTHREAD_VISTA)
         endif()
     elseif(CMAKE_USE_PTHREADS_INIT)
         if(ENABLE_THREADS STREQUAL "posix" OR ENABLE_THREADS STREQUAL "ON")
             # The threading library only needs to be explicitly linked
             # for posix threads, so this is needed for creating
             # liblzma-config.cmake later.
             set(USE_POSIX_THREADS ON)
 
             target_link_libraries(liblzma Threads::Threads)
             add_compile_definitions(MYTHREAD_POSIX)
 
             # Check if pthread_condattr_setclock() exists to
             # use CLOCK_MONOTONIC.
             if(HAVE_CLOCK_MONOTONIC)
                 list(INSERT CMAKE_REQUIRED_LIBRARIES 0
                      "${CMAKE_THREAD_LIBS_INIT}")
                 check_symbol_exists(pthread_condattr_setclock pthread.h
                                     HAVE_PTHREAD_CONDATTR_SETCLOCK)
                 tuklib_add_definition_if(ALL HAVE_PTHREAD_CONDATTR_SETCLOCK)
             endif()
         else()
             message(SEND_ERROR
                     "Windows threading method was requested but a compatible "
                     "library could not be found")
         endif()
     else()
         message(SEND_ERROR "No supported threading library found")
     endif()
 
     target_sources(liblzma PRIVATE
         src/common/tuklib_cpucores.c
         src/common/tuklib_cpucores.h
         src/liblzma/common/hardware_cputhreads.c
         src/liblzma/common/outqueue.c
         src/liblzma/common/outqueue.h
     )
 endif()
 
 
 ############
 # Encoders #
 ############
 
 set(SIMPLE_FILTERS
     x86
     arm
     armthumb
     arm64
     powerpc
     ia64
     sparc
     riscv
 )
 
 # The SUPPORTED_FILTERS are shared between Encoders and Decoders
 # since only lzip does not appear in both lists. lzip is a special
 # case anyway, so it is handled separately in the Decoders section.
 set(SUPPORTED_FILTERS
     lzma1
     lzma2
     delta
     "${SIMPLE_FILTERS}"
 )
 
 set(ENCODERS "${SUPPORTED_FILTERS}" CACHE STRING "Encoders to support")
 
 # If LZMA2 is enabled, then LZMA1 must also be enabled.
 if(NOT "lzma1" IN_LIST ENCODERS AND "lzma2" IN_LIST ENCODERS)
     message(FATAL_ERROR "LZMA2 encoder requires that LZMA1 is also enabled")
 endif()
 
 # If LZMA1 is enabled, then at least one match finder must be enabled.
 if(MATCH_FINDERS STREQUAL "" AND "lzma1" IN_LIST ENCODERS)
     message(FATAL_ERROR "At least 1 match finder is required for an "
                         "LZ-based encoder")
 endif()
 
 set(HAVE_DELTA_CODER OFF)
 set(SIMPLE_ENCODERS OFF)
 set(HAVE_ENCODERS OFF)
 
 foreach(ENCODER IN LISTS ENCODERS)
     if(ENCODER IN_LIST SUPPORTED_FILTERS)
         set(HAVE_ENCODERS ON)
 
         if(NOT SIMPLE_ENCODERS AND ENCODER IN_LIST SIMPLE_FILTERS)
             set(SIMPLE_ENCODERS ON)
         endif()
 
         string(TOUPPER "${ENCODER}" ENCODER_UPPER)
         add_compile_definitions("HAVE_ENCODER_${ENCODER_UPPER}")
     else()
         message(FATAL_ERROR "'${ENCODER}' is not a supported encoder")
     endif()
 endforeach()
 
 if(HAVE_ENCODERS)
     add_compile_definitions(HAVE_ENCODERS)
 
     target_sources(liblzma PRIVATE
         src/liblzma/common/alone_encoder.c
         src/liblzma/common/block_buffer_encoder.c
         src/liblzma/common/block_buffer_encoder.h
         src/liblzma/common/block_encoder.c
         src/liblzma/common/block_encoder.h
         src/liblzma/common/block_header_encoder.c
         src/liblzma/common/easy_buffer_encoder.c
         src/liblzma/common/easy_encoder.c
         src/liblzma/common/easy_encoder_memusage.c
         src/liblzma/common/filter_buffer_encoder.c
         src/liblzma/common/filter_encoder.c
         src/liblzma/common/filter_encoder.h
         src/liblzma/common/filter_flags_encoder.c
         src/liblzma/common/index_encoder.c
         src/liblzma/common/index_encoder.h
         src/liblzma/common/stream_buffer_encoder.c
         src/liblzma/common/stream_encoder.c
         src/liblzma/common/stream_flags_encoder.c
         src/liblzma/common/vli_encoder.c
     )
 
     if(ENABLE_THREADS)
         target_sources(liblzma PRIVATE
             src/liblzma/common/stream_encoder_mt.c
         )
     endif()
 
     if(SIMPLE_ENCODERS)
         target_sources(liblzma PRIVATE
             src/liblzma/simple/simple_encoder.c
             src/liblzma/simple/simple_encoder.h
         )
     endif()
 
     if("lzma1" IN_LIST ENCODERS)
         target_sources(liblzma PRIVATE
             src/liblzma/lzma/lzma_encoder.c
             src/liblzma/lzma/lzma_encoder.h
             src/liblzma/lzma/lzma_encoder_optimum_fast.c
             src/liblzma/lzma/lzma_encoder_optimum_normal.c
             src/liblzma/lzma/lzma_encoder_private.h
             src/liblzma/lzma/fastpos.h
             src/liblzma/lz/lz_encoder.c
             src/liblzma/lz/lz_encoder.h
             src/liblzma/lz/lz_encoder_hash.h
             src/liblzma/lz/lz_encoder_hash_table.h
             src/liblzma/lz/lz_encoder_mf.c
             src/liblzma/rangecoder/price.h
             src/liblzma/rangecoder/price_table.c
             src/liblzma/rangecoder/range_encoder.h
         )
 
         if(NOT ENABLE_SMALL)
             target_sources(liblzma PRIVATE src/liblzma/lzma/fastpos_table.c)
         endif()
     endif()
 
     if("lzma2" IN_LIST ENCODERS)
         target_sources(liblzma PRIVATE
             src/liblzma/lzma/lzma2_encoder.c
             src/liblzma/lzma/lzma2_encoder.h
         )
     endif()
 
     if("delta" IN_LIST ENCODERS)
         set(HAVE_DELTA_CODER ON)
         target_sources(liblzma PRIVATE
             src/liblzma/delta/delta_encoder.c
             src/liblzma/delta/delta_encoder.h
         )
     endif()
 endif()
 
 
 ############
 # Decoders #
 ############
 
 set(DECODERS "${SUPPORTED_FILTERS}" CACHE STRING "Decoders to support")
 
 set(SIMPLE_DECODERS OFF)
 set(HAVE_DECODERS OFF)
 
 foreach(DECODER IN LISTS DECODERS)
     if(DECODER IN_LIST SUPPORTED_FILTERS)
         set(HAVE_DECODERS ON)
 
         if(NOT SIMPLE_DECODERS AND DECODER IN_LIST SIMPLE_FILTERS)
             set(SIMPLE_DECODERS ON)
         endif()
 
         string(TOUPPER "${DECODER}" DECODER_UPPER)
         add_compile_definitions("HAVE_DECODER_${DECODER_UPPER}")
     else()
         message(FATAL_ERROR "'${DECODER}' is not a supported decoder")
     endif()
 endforeach()
 
 if(HAVE_DECODERS)
     add_compile_definitions(HAVE_DECODERS)
 
     target_sources(liblzma PRIVATE
         src/liblzma/common/alone_decoder.c
         src/liblzma/common/alone_decoder.h
         src/liblzma/common/auto_decoder.c
         src/liblzma/common/block_buffer_decoder.c
         src/liblzma/common/block_decoder.c
         src/liblzma/common/block_decoder.h
         src/liblzma/common/block_header_decoder.c
         src/liblzma/common/easy_decoder_memusage.c
         src/liblzma/common/file_info.c
         src/liblzma/common/filter_buffer_decoder.c
         src/liblzma/common/filter_decoder.c
         src/liblzma/common/filter_decoder.h
         src/liblzma/common/filter_flags_decoder.c
         src/liblzma/common/index_decoder.c
         src/liblzma/common/index_decoder.h
         src/liblzma/common/index_hash.c
         src/liblzma/common/stream_buffer_decoder.c
         src/liblzma/common/stream_decoder.c
         src/liblzma/common/stream_flags_decoder.c
         src/liblzma/common/stream_decoder.h
         src/liblzma/common/vli_decoder.c
     )
 
     if(ENABLE_THREADS)
         target_sources(liblzma PRIVATE
             src/liblzma/common/stream_decoder_mt.c
         )
     endif()
 
     if(SIMPLE_DECODERS)
         target_sources(liblzma PRIVATE
             src/liblzma/simple/simple_decoder.c
             src/liblzma/simple/simple_decoder.h
         )
     endif()
 
     if("lzma1" IN_LIST DECODERS)
         target_sources(liblzma PRIVATE
             src/liblzma/lzma/lzma_decoder.c
             src/liblzma/lzma/lzma_decoder.h
             src/liblzma/rangecoder/range_decoder.h
             src/liblzma/lz/lz_decoder.c
             src/liblzma/lz/lz_decoder.h
         )
     endif()
 
     if("lzma2" IN_LIST DECODERS)
         target_sources(liblzma PRIVATE
             src/liblzma/lzma/lzma2_decoder.c
             src/liblzma/lzma/lzma2_decoder.h
         )
     endif()
 
     if("delta" IN_LIST DECODERS)
         set(HAVE_DELTA_CODER ON)
         target_sources(liblzma PRIVATE
             src/liblzma/delta/delta_decoder.c
             src/liblzma/delta/delta_decoder.h
         )
     endif()
 endif()
 
 # Some sources must appear if the filter is configured as either
 # an encoder or decoder.
 if("lzma1" IN_LIST ENCODERS OR "lzma1" IN_LIST DECODERS)
     target_sources(liblzma PRIVATE
         src/liblzma/rangecoder/range_common.h
         src/liblzma/lzma/lzma_encoder_presets.c
         src/liblzma/lzma/lzma_common.h
     )
 endif()
 
 if(HAVE_DELTA_CODER)
     target_sources(liblzma PRIVATE
         src/liblzma/delta/delta_common.c
         src/liblzma/delta/delta_common.h
         src/liblzma/delta/delta_private.h
     )
 endif()
 
 if(SIMPLE_ENCODERS OR SIMPLE_DECODERS)
     target_sources(liblzma PRIVATE
         src/liblzma/simple/simple_coder.c
         src/liblzma/simple/simple_coder.h
         src/liblzma/simple/simple_private.h
     )
 endif()
 
 foreach(SIMPLE_CODER IN LISTS SIMPLE_FILTERS)
     if(SIMPLE_CODER IN_LIST ENCODERS OR SIMPLE_CODER IN_LIST DECODERS)
         target_sources(liblzma PRIVATE "src/liblzma/simple/${SIMPLE_CODER}.c")
     endif()
 endforeach()
 
 
 #############
 # MicroLZMA #
 #############
 
 option(MICROLZMA_ENCODER
        "MicroLZMA encoder (needed by specific applications only)" ON)
 
 option(MICROLZMA_DECODER
        "MicroLZMA decoder (needed by specific applications only)" ON)
 
 if(MICROLZMA_ENCODER)
     if(NOT "lzma1" IN_LIST ENCODERS)
         message(FATAL_ERROR "The LZMA1 encoder is required to support the "
                             "MicroLZMA encoder")
     endif()
 
     target_sources(liblzma PRIVATE src/liblzma/common/microlzma_encoder.c)
 endif()
 
 if(MICROLZMA_DECODER)
     if(NOT "lzma1" IN_LIST DECODERS)
         message(FATAL_ERROR "The LZMA1 decoder is required to support the "
                             "MicroLZMA decoder")
     endif()
 
     target_sources(liblzma PRIVATE src/liblzma/common/microlzma_decoder.c)
 endif()
 
 if (MICROLZMA_ENCODER OR MICROLZMA_DECODER)
     add_compile_definitions(HAVE_MICROLZMA)
 endif()
 
 
 #############################
 # lzip (.lz) format support #
 #############################
 
 option(LZIP_DECODER "Support lzip decoder" ON)
 
 if(LZIP_DECODER)
     # If lzip decoder support is requested, make sure LZMA1 decoder is enabled.
     if(NOT "lzma1" IN_LIST DECODERS)
         message(FATAL_ERROR "The LZMA1 decoder is required to support the "
                             "lzip decoder")
     endif()
 
     add_compile_definitions(HAVE_LZIP_DECODER)
 
     target_sources(liblzma PRIVATE
         src/liblzma/common/lzip_decoder.c
         src/liblzma/common/lzip_decoder.h
     )
 endif()
 
 
 ##############
 # Sandboxing #
 ##############
 
 # ON        Use sandboxing if a supported method is available in the OS.
 # OFF       Disable sandboxing.
 # capsicum  Require Capsicum (FreeBSD >= 10.2) and fail if not found.
 # pledge    Require pledge(2) (OpenBSD >= 5.9) and fail if not found.
 # landlock  Require Landlock (Linux >= 5.13) and fail if not found.
 set(SUPPORTED_SANDBOX_METHODS ON OFF capsicum pledge landlock)
 
 set(ENABLE_SANDBOX ON CACHE STRING
     "Sandboxing method to use in 'xz', 'xzdec', and 'lzmadec'")
 
 set_property(CACHE ENABLE_SANDBOX
                 PROPERTY STRINGS "${SUPPORTED_SANDBOX_METHODS}")
 
 if(NOT ENABLE_SANDBOX IN_LIST SUPPORTED_SANDBOX_METHODS)
     message(FATAL_ERROR "'${ENABLE_SANDBOX}' is not a supported "
                         "sandboxing method")
 endif()
 
 # When autodetecting, the search order is fixed and we must not find
 # more than one method.
 if(ENABLE_SANDBOX STREQUAL "OFF")
     set(SANDBOX_FOUND ON)
 else()
     set(SANDBOX_FOUND OFF)
 endif()
 
 # Since xz and xzdec can both use sandboxing, the compile definition needed
 # to use the sandbox must be added to both targets.
 set(SANDBOX_COMPILE_DEFINITION OFF)
 
 # Sandboxing: Capsicum
 if(NOT SANDBOX_FOUND AND ENABLE_SANDBOX MATCHES "^ON$|^capsicum$")
     check_symbol_exists(cap_rights_limit sys/capsicum.h
                         HAVE_CAP_RIGHTS_LIMIT)
     if(HAVE_CAP_RIGHTS_LIMIT)
         set(SANDBOX_COMPILE_DEFINITION "HAVE_CAP_RIGHTS_LIMIT")
         set(SANDBOX_FOUND ON)
     endif()
 endif()
 
 # Sandboxing: pledge(2)
 if(NOT SANDBOX_FOUND AND ENABLE_SANDBOX MATCHES "^ON$|^pledge$")
     check_symbol_exists(pledge unistd.h HAVE_PLEDGE)
     if(HAVE_PLEDGE)
         set(SANDBOX_COMPILE_DEFINITION "HAVE_PLEDGE")
         set(SANDBOX_FOUND ON)
     endif()
 endif()
 
 # Sandboxing: Landlock
 if(NOT SANDBOX_FOUND AND ENABLE_SANDBOX MATCHES "^ON$|^landlock$")
     check_include_file(linux/landlock.h HAVE_LINUX_LANDLOCK_H)
 
     if(HAVE_LINUX_LANDLOCK_H)
         set(SANDBOX_COMPILE_DEFINITION "HAVE_LINUX_LANDLOCK_H")
         set(SANDBOX_FOUND ON)
 
         # Of our three sandbox methods, only Landlock is incompatible
         # with -fsanitize. FreeBSD 13.2 with Capsicum was tested with
         # -fsanitize=address,undefined and had no issues. OpenBSD (as
         # of version 7.4) has minimal support for process instrumentation.
         # OpenBSD does not distribute the additional libraries needed
         # (libasan, libubsan, etc.) with GCC or Clang needed for runtime
         # sanitization support and instead only support
         # -fsanitize-minimal-runtime for minimal undefined behavior
         # sanitization. This minimal support is compatible with our use
         # of the Pledge sandbox. So only Landlock will result in a
         # build that cannot compress or decompress a single file to
         # standard out.
         if(CMAKE_C_FLAGS MATCHES "-fsanitize=")
             message(SEND_ERROR
                     "CMAKE_C_FLAGS or the environment variable CFLAGS "
                     "contains '-fsanitize=' which is incompatible "
                     "with Landlock sandboxing. Use -DENABLE_SANDBOX=OFF "
                     "as an argument to 'cmake' when using '-fsanitize'.")
         endif()
     endif()
 endif()
 
 if(NOT SANDBOX_FOUND AND NOT ENABLE_SANDBOX MATCHES "^ON$|^OFF$")
     message(SEND_ERROR "ENABLE_SANDBOX=${ENABLE_SANDBOX} was used but "
                         "support for the sandboxing method wasn't found.")
 endif()
 
 ###
 
 # Put the tuklib functions under the lzma_ namespace.
 target_compile_definitions(liblzma PRIVATE TUKLIB_SYMBOL_PREFIX=lzma_)
 tuklib_cpucores(liblzma)
 tuklib_physmem(liblzma)
 
 # While liblzma can be built without tuklib_cpucores or tuklib_physmem
 # modules, the liblzma API functions lzma_cputhreads() and lzma_physmem()
 # will then be useless (which isn't too bad but still unfortunate). Since
 # I expect the CMake-based builds to be only used on systems that are
 # supported by these tuklib modules, problems with these tuklib modules
 # are considered a hard error for now. This hopefully helps to catch bugs
 # in the CMake versions of the tuklib checks.
 if(NOT TUKLIB_CPUCORES_FOUND OR NOT TUKLIB_PHYSMEM_FOUND)
     # Use SEND_ERROR instead of FATAL_ERROR. If someone reports a bug,
     # seeing the results of the remaining checks can be useful too.
     message(SEND_ERROR
             "tuklib_cpucores() or tuklib_physmem() failed. "
             "Unless you really are building for a system where these "
             "modules are not supported (unlikely), this is a bug in the "
             "included cmake/tuklib_*.cmake files that should be fixed. "
             "To build anyway, edit this CMakeLists.txt to ignore this error.")
 endif()
 
 # Check for __attribute__((__constructor__)) support.
 # This needs -Werror because some compilers just warn
 # about this being unsupported.
 cmake_push_check_state()
 set(CMAKE_REQUIRED_FLAGS "-Werror")
 check_c_source_compiles("
         __attribute__((__constructor__))
         static void my_constructor_func(void) { return; }
         int main(void) { return 0; }
     "
     HAVE_FUNC_ATTRIBUTE_CONSTRUCTOR)
 cmake_pop_check_state()
 tuklib_add_definition_if(liblzma HAVE_FUNC_ATTRIBUTE_CONSTRUCTOR)
 
 # The Win95 threading lacks a thread-safe one-time initialization function.
 # The one-time initialization is needed for crc32_small.c and crc64_small.c
 # create the CRC tables. So if small mode is enabled, the threading mode is
 # win95, and the compiler does not support attribute constructor, then we
 # would end up with a multithreaded build that is thread-unsafe. As a
 # result this configuration is not allowed.
 if(USE_WIN95_THREADS AND ENABLE_SMALL AND NOT HAVE_FUNC_ATTRIBUTE_CONSTRUCTOR)
     message(SEND_ERROR "Threading method win95 and ENABLE_SMALL "
                         "cannot be used at the same time with a compiler "
                         "that doesn't support "
                         "__attribute__((__constructor__))")
 endif()
 
 
 # Check for __attribute__((__ifunc__())) support.
 # Supported values for USE_ATTR_IFUNC:
 #
 # auto (default) - Detect ifunc support with a compile test.
 # ON             - Always enable ifunc.
 # OFF            - Disable ifunc usage.
 set(USE_ATTR_IFUNC "auto" CACHE STRING "Use __attribute__((__ifunc__())).")
 
 set(SUPPORTED_USE_ATTR_IFUNC auto ON OFF)
 
 if(NOT USE_ATTR_IFUNC IN_LIST SUPPORTED_USE_ATTR_IFUNC)
     message(FATAL_ERROR "'${USE_ATTR_IFUNC}' is not a supported value for"
                         "USE_ATTR_IFUNC")
 endif()
 
 # When USE_ATTR_IFUNC is 'auto', allow the use of __attribute__((__ifunc__()))
 # if compiler support is detected and we are building for GNU/Linux (glibc)
 # or FreeBSD. uClibc and musl don't support ifunc in their dynamic linkers
 # but some compilers still accept the attribute when compiling for these
 # C libraries, which results in broken binaries. That's why we need to
 # check which libc is being used.
 if(USE_ATTR_IFUNC STREQUAL "auto")
     cmake_push_check_state()
     set(CMAKE_REQUIRED_FLAGS "-Werror")
 
     check_c_source_compiles("
             /*
              * Force a compilation error when not using glibc on Linux
              * or if we are not using FreeBSD. uClibc will define
              * __GLIBC__ but does not support ifunc, so we must have
              * an extra check to disable with uClibc.
              */
             #if defined(__linux__)
             #   include <features.h>
             #   if !defined(__GLIBC__) || defined(__UCLIBC__)
             compile error
             #   endif
             #elif !defined(__FreeBSD__)
             compile error
             #endif
 
             static void func(void) { return; }
             static void (*resolve_func(void)) (void) { return func; }
             void func_ifunc(void)
                     __attribute__((__ifunc__(\"resolve_func\")));
             int main(void) { return 0; }
             /*
              * 'clang -Wall' incorrectly warns that resolve_func is
              * unused (-Wunused-function). Correct assembly output is
              * still produced. This problem exists at least in Clang
              * versions 4 to 17. The following silences the bogus warning:
              */
             void make_clang_quiet(void);
             void make_clang_quiet(void) { resolve_func()(); }
         "
         SYSTEM_SUPPORTS_IFUNC)
 
         cmake_pop_check_state()
 endif()
 
 if(USE_ATTR_IFUNC STREQUAL "ON" OR SYSTEM_SUPPORTS_IFUNC)
     tuklib_add_definitions(liblzma HAVE_FUNC_ATTRIBUTE_IFUNC)
 
     if(CMAKE_C_FLAGS MATCHES "-fsanitize=")
         message(SEND_ERROR
                 "CMAKE_C_FLAGS or the environment variable CFLAGS "
                 "contains '-fsanitize=' which is incompatible "
                 "with ifunc. Use -DUSE_ATTR_IFUNC=OFF "
                 "as an argument to 'cmake' when using '-fsanitize'.")
     endif()
 endif()
 
 # cpuid.h
 check_include_file(cpuid.h HAVE_CPUID_H)
 tuklib_add_definition_if(liblzma HAVE_CPUID_H)
 
 # immintrin.h:
 check_include_file(immintrin.h HAVE_IMMINTRIN_H)
 if(HAVE_IMMINTRIN_H)
     target_compile_definitions(liblzma PRIVATE HAVE_IMMINTRIN_H)
 
     # SSE2 intrinsics:
     check_c_source_compiles("
             #include <immintrin.h>
             int main(void)
             {
                 __m128i x = { 0 };
                 _mm_movemask_epi8(x);
                 return 0;
             }
         "
         HAVE__MM_MOVEMASK_EPI8)
     tuklib_add_definition_if(liblzma HAVE__MM_MOVEMASK_EPI8)
 
     # CLMUL intrinsic:
     option(ALLOW_CLMUL_CRC "Allow carryless multiplication for CRC \
 calculation if supported by the system" ON)
 
     if(ALLOW_CLMUL_CRC)
         check_c_source_compiles("
                 #include <immintrin.h>
                 #if defined(__e2k__) && __iset__ < 6
                 #   error
                 #endif
                 #if (defined(__GNUC__) || defined(__clang__)) \
                         && !defined(__EDG__)
                 __attribute__((__target__(\"ssse3,sse4.1,pclmul\")))
                 #endif
                 __m128i my_clmul(__m128i a)
                 {
                     const __m128i b = _mm_set_epi64x(1, 2);
                     return _mm_clmulepi64_si128(a, b, 0);
                 }
                 int main(void) { return 0; }
             "
             HAVE_USABLE_CLMUL)
         tuklib_add_definition_if(liblzma HAVE_USABLE_CLMUL)
     endif()
 endif()
 
 # ARM64 C Language Extensions define CRC32 functions in arm_acle.h.
 # These are supported by at least GCC and Clang which both need
 # __attribute__((__target__("+crc"))), unless the needed compiler flags
 # are used to support the CRC instruction.
 option(ALLOW_ARM64_CRC32 "Allow ARM64 CRC32 instruction if supported by \
 the system" ON)
 
 if(ALLOW_ARM64_CRC32)
     check_c_source_compiles("
             #include <stdint.h>
 
             #ifndef _MSC_VER
             #include <arm_acle.h>
             #endif
 
             #if (defined(__GNUC__) || defined(__clang__)) && !defined(__EDG__)
             __attribute__((__target__(\"+crc\")))
             #endif
             uint32_t my_crc(uint32_t a, uint64_t b)
             {
                 return __crc32d(a, b);
             }
             int main(void) { return 0; }
         "
         HAVE_ARM64_CRC32)
 
     if(HAVE_ARM64_CRC32)
         target_compile_definitions(liblzma PRIVATE HAVE_ARM64_CRC32)
 
         # Check for ARM64 CRC32 instruction runtime detection.
         # getauxval() is supported on Linux.
         check_symbol_exists(getauxval sys/auxv.h HAVE_GETAUXVAL)
         tuklib_add_definition_if(liblzma HAVE_GETAUXVAL)
 
         # elf_aux_info() is supported on FreeBSD.
         check_symbol_exists(elf_aux_info sys/auxv.h HAVE_ELF_AUX_INFO)
         tuklib_add_definition_if(liblzma HAVE_ELF_AUX_INFO)
 
         # sysctlbyname("hw.optional.armv8_crc32", ...) is supported on Darwin
         # (macOS, iOS, etc.). Note that sysctlbyname() is supported on FreeBSD,
         # NetBSD, and possibly others too but the string is specific to
         # Apple OSes. The C code is responsible for checking
         # defined(__APPLE__) before using
         # sysctlbyname("hw.optional.armv8_crc32", ...).
         check_symbol_exists(sysctlbyname sys/sysctl.h HAVE_SYSCTLBYNAME)
         tuklib_add_definition_if(liblzma HAVE_SYSCTLBYNAME)
     endif()
 endif()
 
 
 # Symbol visibility support:
 #
 # The C_VISIBILITY_PRESET property takes care of adding the compiler
 # option -fvisibility=hidden (or equivalent) if and only if it is supported.
 #
 # HAVE_VISIBILITY should always be defined to 0 or 1. It tells liblzma
 # if __attribute__((__visibility__("default")))
 # and __attribute__((__visibility__("hidden"))) are supported.
 # Those are useful only when the compiler supports -fvisibility=hidden
 # or such option so HAVE_VISIBILITY should be 1 only when both option and
 # the attribute support are present. HAVE_VISIBILITY is ignored on Windows
 # and Cygwin by the liblzma C code; __declspec(dllexport) is used instead.
 #
 # CMake's GenerateExportHeader module is too fancy since liblzma already
 # has the necessary macros. Instead, check CMake's internal variable
 # CMAKE_C_COMPILE_OPTIONS_VISIBILITY (it's the C-specific variant of
 # CMAKE_<LANG>_COMPILE_OPTIONS_VISIBILITY) which contains the compiler
 # command line option for visibility support. It's empty or unset when
 # visibility isn't supported. (It was added to CMake 2.8.12 in the commit
 # 0e9f4bc00c6b26f254e74063e4026ac33b786513 in 2013.) This way we don't
 # set HAVE_VISIBILITY to 1 when visibility isn't actually supported.
 if(BUILD_SHARED_LIBS AND CMAKE_C_COMPILE_OPTIONS_VISIBILITY)
     set_target_properties(liblzma PROPERTIES C_VISIBILITY_PRESET hidden)
     target_compile_definitions(liblzma PRIVATE HAVE_VISIBILITY=1)
 else()
     target_compile_definitions(liblzma PRIVATE HAVE_VISIBILITY=0)
 endif()
 
 if(WIN32)
     if(BUILD_SHARED_LIBS)
         # Add the Windows resource file for liblzma.dll.
         target_sources(liblzma PRIVATE src/liblzma/liblzma_w32res.rc)
 
         set_target_properties(liblzma PROPERTIES
             LINK_DEPENDS "${CMAKE_CURRENT_SOURCE_DIR}/src/common/common_w32res.rc"
         )
 
         # Export the public API symbols with __declspec(dllexport).
         target_compile_definitions(liblzma PRIVATE DLL_EXPORT)
 
         if(NOT MSVC)
             # Create a DEF file. The linker puts the ordinal numbers there
             # too so the output from the linker isn't our final file.
             target_link_options(liblzma PRIVATE
                                 "-Wl,--output-def,liblzma.def.in")
 
             # Remove the ordinal numbers from the DEF file so that
             # no one will create an import library that links by ordinal
             # instead of by name. We don't maintain a DEF file so the
             # ordinal numbers aren't stable.
             add_custom_command(TARGET liblzma POST_BUILD
                 COMMAND "${CMAKE_COMMAND}"
                     -DINPUT_FILE=liblzma.def.in
                     -DOUTPUT_FILE=liblzma.def
                     -P
                     "${CMAKE_CURRENT_SOURCE_DIR}/cmake/remove-ordinals.cmake"
                 BYPRODUCTS "liblzma.def"
                 VERBATIM)
         endif()
     else()
         # Disable __declspec(dllimport) when linking against static liblzma.
         target_compile_definitions(liblzma INTERFACE LZMA_API_STATIC)
     endif()
 elseif(BUILD_SHARED_LIBS AND CMAKE_SYSTEM_NAME STREQUAL "Linux" AND
        NOT CMAKE_SYSTEM_PROCESSOR MATCHES "[Mm]icro[Bb]laze")
     # GNU/Linux-specific symbol versioning for shared liblzma.
     # This includes a few extra compatibility symbols for RHEL/CentOS 7
     # which are pointless on non-glibc non-Linux systems.
     #
     # As a special case, GNU/Linux on MicroBlaze gets the generic
     # symbol versioning because GCC 12 doesn't support the __symver__
     # attribute on MicroBlaze. On Linux, CMAKE_SYSTEM_PROCESSOR comes
     # from "uname -m" for native builds (should be "microblaze") or from
     # the CMake toolchain file (not perfectly standardized but it very
     # likely has "microblaze" in lower case or mixed case somewhere in
     # the string).
     #
     # FIXME? Avoid symvers on Linux with non-glibc like musl?
     #
     # Note that adding link options doesn't affect static builds
     # but HAVE_SYMBOL_VERSIONS_LINUX must not be used with static builds
     # because it would put symbol versions into the static library which
     # can cause problems. It's clearer if all symver related things are
     # omitted when not building a shared library.
     #
     # NOTE: Set it explicitly to 1 to make it clear that versioning is
     # done unconditionally in the C files.
     target_compile_definitions(liblzma PRIVATE HAVE_SYMBOL_VERSIONS_LINUX=1)
     target_link_options(liblzma PRIVATE
         "-Wl,--version-script=${CMAKE_CURRENT_SOURCE_DIR}/src/liblzma/liblzma_linux.map"
     )
     set_target_properties(liblzma PROPERTIES
         LINK_DEPENDS "${CMAKE_CURRENT_SOURCE_DIR}/src/liblzma/liblzma_linux.map"
     )
 elseif(BUILD_SHARED_LIBS AND (CMAKE_SYSTEM_NAME STREQUAL "FreeBSD" OR
                               CMAKE_SYSTEM_NAME STREQUAL "Linux"))
     # Generic symbol versioning for shared liblzma is used on FreeBSD and
     # also on GNU/Linux on MicroBlaze.
     target_link_options(liblzma PRIVATE
         "-Wl,--version-script=${CMAKE_CURRENT_SOURCE_DIR}/src/liblzma/liblzma_generic.map"
     )
     set_target_properties(liblzma PROPERTIES
         LINK_DEPENDS "${CMAKE_CURRENT_SOURCE_DIR}/src/liblzma/liblzma_generic.map"
     )
 endif()
 
 set_target_properties(liblzma PROPERTIES
     # At least for now the package versioning matches the rules used for
     # shared library versioning (excluding development releases) so it is
     # fine to use the package version here.
     SOVERSION "${xz_VERSION_MAJOR}"
     VERSION "${xz_VERSION}"
 
     # It's liblzma.so or liblzma.dll, not libliblzma.so or lzma.dll.
     # Avoid the name lzma.dll because it would conflict with LZMA SDK.
     PREFIX ""
     IMPORT_PREFIX ""
 )
 
 # Create liblzma-config-version.cmake.
 #
 # FIXME: SameMajorVersion is correct for stable releases but it is wrong
 # for development releases where each release may have incompatible changes.
 include(CMakePackageConfigHelpers)
 write_basic_package_version_file(
     "${CMAKE_CURRENT_BINARY_DIR}/liblzma-config-version.cmake"
     VERSION "${liblzma_VERSION}"
     COMPATIBILITY SameMajorVersion)
 
 # Create liblzma-config.cmake. We use this spelling instead of
 # liblzmaConfig.cmake to make find_package work in case insensitive
 # manner even with case sensitive file systems. This gives more consistent
 # behavior between operating systems. This optionally includes a dependency
 # on a threading library, so the contents are created in two separate parts.
 # The "second half" is always needed, so create it first.
 set(LZMA_CONFIG_CONTENTS
 "include(\"\${CMAKE_CURRENT_LIST_DIR}/liblzma-targets.cmake\")
 
 if(NOT TARGET LibLZMA::LibLZMA)
     # Be compatible with the spelling used by the FindLibLZMA module. This
     # doesn't use ALIAS because it would make CMake resolve LibLZMA::LibLZMA
     # to liblzma::liblzma instead of keeping the original spelling. Keeping
     # the original spelling is important for good FindLibLZMA compatibility.
     add_library(LibLZMA::LibLZMA INTERFACE IMPORTED)
     set_target_properties(LibLZMA::LibLZMA PROPERTIES
                           INTERFACE_LINK_LIBRARIES liblzma::liblzma)
 endif()
 ")
 
 if(USE_POSIX_THREADS)
     set(LZMA_CONFIG_CONTENTS
 "include(CMakeFindDependencyMacro)
 set(THREADS_PREFER_PTHREAD_FLAG TRUE)
 find_dependency(Threads)
 
 ${LZMA_CONFIG_CONTENTS}
 ")
 endif()
 
 file(WRITE "${CMAKE_CURRENT_BINARY_DIR}/liblzma-config.cmake"
         "${LZMA_CONFIG_CONTENTS}")
 
 # Create liblzma.pc.
 set(prefix "${CMAKE_INSTALL_PREFIX}")
 set(exec_prefix "${CMAKE_INSTALL_PREFIX}")
 set(libdir "${CMAKE_INSTALL_FULL_LIBDIR}")
 set(includedir "${CMAKE_INSTALL_FULL_INCLUDEDIR}")
 set(PTHREAD_CFLAGS "${CMAKE_THREAD_LIBS_INIT}")
 configure_file(src/liblzma/liblzma.pc.in liblzma.pc
                @ONLY
                NEWLINE_STYLE LF)
 
 # Install the library binary. The INCLUDES specifies the include path that
 # is exported for other projects to use but it doesn't install any files.
 install(TARGETS liblzma EXPORT liblzmaTargets
         RUNTIME  DESTINATION "${CMAKE_INSTALL_BINDIR}"
                  COMPONENT liblzma_Runtime
         LIBRARY  DESTINATION "${CMAKE_INSTALL_LIBDIR}"
                  COMPONENT liblzma_Runtime
                  NAMELINK_COMPONENT liblzma_Development
         ARCHIVE  DESTINATION "${CMAKE_INSTALL_LIBDIR}"
                  COMPONENT liblzma_Development
         INCLUDES DESTINATION "${CMAKE_INSTALL_INCLUDEDIR}")
 
 # Install the liblzma API headers. These use a subdirectory so
 # this has to be done as a separate step.
 install(DIRECTORY src/liblzma/api/
         COMPONENT liblzma_Development
         DESTINATION "${CMAKE_INSTALL_INCLUDEDIR}"
         FILES_MATCHING PATTERN "*.h")
 
 # Install the CMake files that other packages can use to find liblzma.
 set(liblzma_INSTALL_CMAKEDIR
     "${CMAKE_INSTALL_LIBDIR}/cmake/liblzma"
     CACHE STRING "Path to liblzma's .cmake files")
 
 install(EXPORT liblzmaTargets
         NAMESPACE liblzma::
         FILE liblzma-targets.cmake
         DESTINATION "${liblzma_INSTALL_CMAKEDIR}"
         COMPONENT liblzma_Development)
 
 install(FILES "${CMAKE_CURRENT_BINARY_DIR}/liblzma-config.cmake"
               "${CMAKE_CURRENT_BINARY_DIR}/liblzma-config-version.cmake"
         DESTINATION "${liblzma_INSTALL_CMAKEDIR}"
         COMPONENT liblzma_Development)
 
 if(NOT MSVC)
     install(FILES "${CMAKE_CURRENT_BINARY_DIR}/liblzma.pc"
             DESTINATION "${CMAKE_INSTALL_LIBDIR}/pkgconfig"
             COMPONENT liblzma_Development)
 endif()
 
 
 #############################################################################
 # Helper functions for installing files
 #############################################################################
 
 # For each non-empty element in the list LINK_NAMES, creates symbolic links
 # ${LINK_NAME}${LINK_SUFFIX} -> ${TARGET_NAME} in the directory ${DIR}.
 # The target file should exist because on Cygwin and MSYS2 symlink creation
 # can fail under certain conditions if the target doesn't exist.
 function(my_install_symlinks COMPONENT DIR TARGET_NAME LINK_SUFFIX LINK_NAMES)
     install(CODE "set(D \"\$ENV{DESTDIR}\${CMAKE_INSTALL_PREFIX}/${DIR}\")
                  foreach(L ${LINK_NAMES})
                      file(CREATE_LINK \"${TARGET_NAME}\"
                                       \"\${D}/\${L}${LINK_SUFFIX}\"
                                       SYMBOLIC)
                  endforeach()"
             COMPONENT "${COMPONENT}")
 endfunction()
 
 # Installs a man page file of a given language ("" for the untranslated file)
 # and optionally its alternative names as symlinks. This is a helper function
 # for my_install_man() below.
 function(my_install_man_lang COMPONENT SRC_FILE MAN_LANG LINK_NAMES)
     # Get the man page section from the filename suffix.
     string(REGEX REPLACE "^.*\.([^/.]+)$" "\\1" MAN_SECTION "${SRC_FILE}")
 
     # A few man pages might be missing from translations.
     # Don't attempt to install them or create the related symlinks.
     if(NOT MAN_LANG STREQUAL "" AND NOT EXISTS "${SRC_FILE}")
         return()
     endif()
 
     # Installing the file must be done before creating the symlinks
     # due to Cygwin and MSYS2.
     install(FILES "${SRC_FILE}"
             DESTINATION "${CMAKE_INSTALL_MANDIR}/${MAN_LANG}/man${MAN_SECTION}"
             COMPONENT "${COMPONENT}")
 
     # Get the basename of the file to be used as the symlink target.
     get_filename_component(BASENAME "${SRC_FILE}" NAME)
 
     # LINK_NAMES don't contain the man page filename suffix (like ".1")
     # so it needs to be told to my_install_symlinks.
     my_install_symlinks("${COMPONENT}"
                         "${CMAKE_INSTALL_MANDIR}/${MAN_LANG}/man${MAN_SECTION}"
                         "${BASENAME}" ".${MAN_SECTION}" "${LINK_NAMES}")
 endfunction()
 
 # Installs a man page file and optionally its alternative names as symlinks.
 # Does the same for translations if ENABLE_NLS.
 function(my_install_man COMPONENT SRC_FILE LINK_NAMES)
     my_install_man_lang("${COMPONENT}" "${SRC_FILE}" "" "${LINK_NAMES}")
 
     if(ENABLE_NLS)
         # Find the translated versions of this man page.
         get_filename_component(BASENAME "${SRC_FILE}" NAME)
         file(GLOB MAN_FILES "po4a/man/*/${BASENAME}")
 
         foreach(F ${MAN_FILES})
             get_filename_component(MAN_LANG "${F}" DIRECTORY)
             get_filename_component(MAN_LANG "${MAN_LANG}" NAME)
             my_install_man_lang("${COMPONENT}" "${F}" "${MAN_LANG}"
                                 "${LINK_NAMES}")
         endforeach()
     endif()
 endfunction()
 
 
 #############################################################################
 # libgnu (getopt_long)
 #############################################################################
 
 # This mirrors how the Autotools build system handles the getopt_long
 # replacement, calling the object library libgnu since the replacement
 # version comes from Gnulib.
 add_library(libgnu OBJECT)
 
 # CMake requires that even an object library must have at least once source
 # file. So we give it a header file that results in no output files.
 #
 # NOTE: Using a file outside the lib directory makes it possible to
 # delete lib/*.h and lib/*.c and still keep the build working if
 # getopt_long replacement isn't needed. It's convenient if one wishes
 # to be certain that no GNU LGPL code gets included in the binaries.
 target_sources(libgnu PRIVATE src/common/sysdefs.h)
 
 # The Ninja Generator requires setting the linker language since it cannot
 # guess the programming language of just a header file. Setting this
 # property avoids needing an empty .c file or an non-empty unnecessary .c
 # file.
 set_target_properties(libgnu PROPERTIES LINKER_LANGUAGE C)
 
 # Create /lib directory in the build directory and add it to the include path.
 file(MAKE_DIRECTORY "${CMAKE_CURRENT_BINARY_DIR}/lib")
 target_include_directories(libgnu PUBLIC "${CMAKE_CURRENT_BINARY_DIR}/lib")
 
 # Include /lib from the source directory. It does no harm even if none of
 # the Gnulib replacements are used.
 target_include_directories(libgnu PUBLIC lib)
 
 # The command line tools need getopt_long in order to parse arguments. If
 # the system does not have a getopt_long implementation we can use the one
 # from Gnulib instead.
 check_symbol_exists(getopt_long getopt.h HAVE_GETOPT_LONG)
 
 if(NOT HAVE_GETOPT_LONG)
     # Set the __GETOPT_PREFIX definition to "rpl_" (replacement) to avoid
     # name conflicts with libc symbols. The same prefix is set if using
     # the Autotools build (m4/getopt.m4).
     target_compile_definitions(libgnu PUBLIC "__GETOPT_PREFIX=rpl_")
 
     # Create a custom copy command to copy the getopt header to the build
     # directory and re-copy it if it is updated. (Gnulib does it this way
     # because it allows choosing which .in.h files to actually use in the
     # build. We need just getopt.h so this is a bit overcomplicated for
     # a single header file only.)
     add_custom_command(OUTPUT "${CMAKE_CURRENT_BINARY_DIR}/lib/getopt.h"
         COMMAND "${CMAKE_COMMAND}" -E copy
             "${CMAKE_CURRENT_SOURCE_DIR}/lib/getopt.in.h"
             "${CMAKE_CURRENT_BINARY_DIR}/lib/getopt.h"
         MAIN_DEPENDENCY "${CMAKE_CURRENT_SOURCE_DIR}/lib/getopt.in.h"
         VERBATIM)
 
     target_sources(libgnu PRIVATE
         lib/getopt1.c
         lib/getopt.c
         lib/getopt_int.h
         lib/getopt-cdefs.h
         lib/getopt-core.h
         lib/getopt-ext.h
         lib/getopt-pfx-core.h
         lib/getopt-pfx-ext.h
         "${CMAKE_CURRENT_BINARY_DIR}/lib/getopt.h"
     )
 endif()
 
 
 #############################################################################
 # xzdec and lzmadec
 #############################################################################
 
 if(HAVE_DECODERS AND (NOT MSVC OR MSVC_VERSION GREATER_EQUAL 1900))
     foreach(XZDEC xzdec lzmadec)
         add_executable("${XZDEC}"
             src/common/sysdefs.h
             src/common/tuklib_common.h
             src/common/tuklib_config.h
             src/common/tuklib_exit.c
             src/common/tuklib_exit.h
             src/common/tuklib_gettext.h
             src/common/tuklib_progname.c
             src/common/tuklib_progname.h
             src/xzdec/xzdec.c
         )
 
         target_include_directories("${XZDEC}" PRIVATE
             src/common
             src/liblzma/api
         )
 
         target_link_libraries("${XZDEC}" PRIVATE liblzma libgnu)
 
         if(WIN32)
             # Add the Windows resource file for xzdec.exe or lzmadec.exe.
             target_sources("${XZDEC}" PRIVATE src/xzdec/xzdec_w32res.rc)
             set_target_properties("${XZDEC}" PROPERTIES
                 LINK_DEPENDS "${CMAKE_CURRENT_SOURCE_DIR}/src/common/common_w32res.rc"
             )
         endif()
 
         if(SANDBOX_COMPILE_DEFINITION)
             target_compile_definitions("${XZDEC}" PRIVATE
                                     "${SANDBOX_COMPILE_DEFINITION}")
         endif()
 
         tuklib_progname("${XZDEC}")
 
         install(TARGETS "${XZDEC}"
                 RUNTIME DESTINATION "${CMAKE_INSTALL_BINDIR}"
                         COMPONENT "${XZDEC}_Runtime")
     endforeach()
 
     # This is the only build-time difference with lzmadec.
     target_compile_definitions(lzmadec PRIVATE "LZMADEC")
 
     if(UNIX)
         # NOTE: This puts the lzmadec.1 symlinks into xzdec_Documentation.
         # This isn't great but doing them separately with translated
         # man pages would require extra code. So this has to suffice for now.
         my_install_man(xzdec_Documentation src/xzdec/xzdec.1 lzmadec)
     endif()
 endif()
 
 
 #############################################################################
 # lzmainfo
 #############################################################################
 
 if(HAVE_DECODERS AND (NOT MSVC OR MSVC_VERSION GREATER_EQUAL 1900))
     add_executable(lzmainfo
         src/common/sysdefs.h
         src/common/tuklib_common.h
         src/common/tuklib_config.h
         src/common/tuklib_exit.c
         src/common/tuklib_exit.h
         src/common/tuklib_gettext.h
         src/common/tuklib_progname.c
         src/common/tuklib_progname.h
         src/lzmainfo/lzmainfo.c
     )
 
     target_include_directories(lzmainfo PRIVATE
         src/common
         src/liblzma/api
     )
 
     target_link_libraries(lzmainfo PRIVATE liblzma libgnu)
 
     if(WIN32)
         # Add the Windows resource file for lzmainfo.exe.
         target_sources(lzmainfo PRIVATE src/lzmainfo/lzmainfo_w32res.rc)
         set_target_properties(lzmainfo PROPERTIES
             LINK_DEPENDS "${CMAKE_CURRENT_SOURCE_DIR}/src/common/common_w32res.rc"
         )
     endif()
 
     tuklib_progname(lzmainfo)
 
     # NOTE: The translations are in the "xz" domain and the .mo files are
     # installed as part of the "xz" target.
     if(ENABLE_NLS)
         target_link_libraries(lzmainfo PRIVATE Intl::Intl)
 
         target_compile_definitions(lzmainfo PRIVATE
                 ENABLE_NLS
                 PACKAGE="${TRANSLATION_DOMAIN}"
                 LOCALEDIR="${LOCALEDIR_DEFINITION}"
         )
     endif()
 
     install(TARGETS lzmainfo
             RUNTIME DESTINATION "${CMAKE_INSTALL_BINDIR}"
                     COMPONENT lzmainfo_Runtime)
 
     if(UNIX)
         my_install_man(lzmainfo_Documentation src/lzmainfo/lzmainfo.1 "")
     endif()
 endif()
 
 
 #############################################################################
 # xz
 #############################################################################
 
 if(NOT MSVC OR MSVC_VERSION GREATER_EQUAL 1900)
     add_executable(xz
         src/common/mythread.h
         src/common/sysdefs.h
         src/common/tuklib_common.h
         src/common/tuklib_config.h
         src/common/tuklib_exit.c
         src/common/tuklib_exit.h
         src/common/tuklib_gettext.h
         src/common/tuklib_integer.h
         src/common/tuklib_mbstr.h
         src/common/tuklib_mbstr_fw.c
         src/common/tuklib_mbstr_width.c
         src/common/tuklib_open_stdxxx.c
         src/common/tuklib_open_stdxxx.h
         src/common/tuklib_progname.c
         src/common/tuklib_progname.h
         src/xz/args.c
         src/xz/args.h
         src/xz/coder.c
         src/xz/coder.h
         src/xz/file_io.c
         src/xz/file_io.h
         src/xz/hardware.c
         src/xz/hardware.h
         src/xz/main.c
         src/xz/main.h
         src/xz/message.c
         src/xz/message.h
         src/xz/mytime.c
         src/xz/mytime.h
         src/xz/options.c
         src/xz/options.h
         src/xz/private.h
         src/xz/sandbox.c
         src/xz/sandbox.h
         src/xz/signals.c
         src/xz/signals.h
         src/xz/suffix.c
         src/xz/suffix.h
         src/xz/util.c
         src/xz/util.h
     )
 
     target_include_directories(xz PRIVATE
         src/common
         src/liblzma/api
     )
 
     if(HAVE_DECODERS)
         target_sources(xz PRIVATE
             src/xz/list.c
             src/xz/list.h
         )
     endif()
 
     target_link_libraries(xz PRIVATE liblzma libgnu)
 
     target_compile_definitions(xz PRIVATE ASSUME_RAM=128)
 
     if(WIN32)
         # Add the Windows resource file for xz.exe.
         target_sources(xz PRIVATE src/xz/xz_w32res.rc)
         set_target_properties(xz PROPERTIES
             LINK_DEPENDS "${CMAKE_CURRENT_SOURCE_DIR}/src/common/common_w32res.rc"
         )
     endif()
 
     if(SANDBOX_COMPILE_DEFINITION)
         target_compile_definitions(xz PRIVATE "${SANDBOX_COMPILE_DEFINITION}")
     endif()
 
     tuklib_progname(xz)
     tuklib_mbstr(xz)
 
     check_symbol_exists(optreset getopt.h HAVE_OPTRESET)
     tuklib_add_definition_if(xz HAVE_OPTRESET)
 
     check_symbol_exists(posix_fadvise fcntl.h HAVE_POSIX_FADVISE)
     tuklib_add_definition_if(xz HAVE_POSIX_FADVISE)
 
     # How to get file time:
     check_struct_has_member("struct stat" st_atim.tv_nsec
                             "sys/types.h;sys/stat.h"
                             HAVE_STRUCT_STAT_ST_ATIM_TV_NSEC)
     if(HAVE_STRUCT_STAT_ST_ATIM_TV_NSEC)
         tuklib_add_definitions(xz HAVE_STRUCT_STAT_ST_ATIM_TV_NSEC)
     else()
         check_struct_has_member("struct stat" st_atimespec.tv_nsec
                                 "sys/types.h;sys/stat.h"
                                 HAVE_STRUCT_STAT_ST_ATIMESPEC_TV_NSEC)
         if(HAVE_STRUCT_STAT_ST_ATIMESPEC_TV_NSEC)
             tuklib_add_definitions(xz HAVE_STRUCT_STAT_ST_ATIMESPEC_TV_NSEC)
         else()
             check_struct_has_member("struct stat" st_atimensec
                                     "sys/types.h;sys/stat.h"
                                     HAVE_STRUCT_STAT_ST_ATIMENSEC)
             tuklib_add_definition_if(xz HAVE_STRUCT_STAT_ST_ATIMENSEC)
         endif()
     endif()
 
     # How to set file time:
     check_symbol_exists(futimens "sys/types.h;sys/stat.h" HAVE_FUTIMENS)
     if(HAVE_FUTIMENS)
         tuklib_add_definitions(xz HAVE_FUTIMENS)
     else()
         check_symbol_exists(futimes "sys/time.h" HAVE_FUTIMES)
         if(HAVE_FUTIMES)
             tuklib_add_definitions(xz HAVE_FUTIMES)
         else()
             check_symbol_exists(futimesat "sys/time.h" HAVE_FUTIMESAT)
             if(HAVE_FUTIMESAT)
                 tuklib_add_definitions(xz HAVE_FUTIMESAT)
             else()
                 check_symbol_exists(utimes "sys/time.h" HAVE_UTIMES)
                 if(HAVE_UTIMES)
                     tuklib_add_definitions(xz HAVE_UTIMES)
                 else()
                     check_symbol_exists(_futime "sys/utime.h" HAVE__FUTIME)
                     if(HAVE__FUTIME)
                         tuklib_add_definitions(xz HAVE__FUTIME)
                     else()
                         check_symbol_exists(utime "utime.h" HAVE_UTIME)
                         tuklib_add_definition_if(xz HAVE_UTIME)
                     endif()
                 endif()
             endif()
         endif()
     endif()
 
     if(ENABLE_NLS)
         target_link_libraries(xz PRIVATE Intl::Intl)
 
         target_compile_definitions(xz PRIVATE
                 ENABLE_NLS
                 PACKAGE="${TRANSLATION_DOMAIN}"
                 LOCALEDIR="${LOCALEDIR_DEFINITION}"
         )
 
         file(STRINGS po/LINGUAS LINGUAS)
 
         # Where to find .gmo files. If msgfmt is available, the .po files
         # will be converted as part of the build. Otherwise we will use
         # the pre-generated .gmo files which are included in XZ Utils
         # tarballs by Autotools.
         set(GMO_DIR "${CMAKE_CURRENT_SOURCE_DIR}/po")
 
         if(GETTEXT_FOUND)
             # NOTE: gettext_process_po_files' INSTALL_DESTINATION is
             # incompatible with how Autotools requires the .po files to
             # be named. CMake would require each .po file to be named with
             # the translation domain and thus each .po file would need its
             # own language-specific directory (like "po/fi/xz.po"). On top
             # of this, INSTALL_DESTINATION doesn't allow specifying COMPONENT
             # and thus the .mo files go into "Unspecified" component. So we
             # can use gettext_process_po_files to convert the .po files but
             # installation needs to be done with our own code.
             #
             # Also, the .gmo files will go to root of the build directory
             # instead of neatly into a subdirectory. This is hardcoded in
             # CMake's FindGettext.cmake.
             foreach(LANG IN LISTS LINGUAS)
                 gettext_process_po_files("${LANG}" ALL
                         PO_FILES "${CMAKE_CURRENT_SOURCE_DIR}/po/${LANG}.po")
             endforeach()
 
             set(GMO_DIR "${CMAKE_CURRENT_BINARY_DIR}")
         endif()
 
         foreach(LANG IN LISTS LINGUAS)
             install(
                 FILES "${GMO_DIR}/${LANG}.gmo"
                 DESTINATION "${CMAKE_INSTALL_LOCALEDIR}/${LANG}/LC_MESSAGES"
                 RENAME "${TRANSLATION_DOMAIN}.mo"
                 COMPONENT xz_Runtime)
         endforeach()
     endif()
 
     # This command must be before the symlink creation to keep things working
     # on Cygwin and MSYS2 in all cases.
     #
     #   - Cygwin can encode symlinks in multiple ways. This can be
     #     controlled via the environment variable "CYGWIN". If it contains
     #     "winsymlinks:nativestrict" then symlink creation will fail if
     #     the link target doesn't exist. This mode isn't the default though.
     #     See: https://cygwin.com/faq.html#faq.api.symlinks
     #
     #   - MSYS2 supports the same winsymlinks option in the environment
     #     variable "MSYS" (not "MSYS2). The default in MSYS2 is to make
     #     a copy of the file instead of any kind of symlink. Thus the link
     #     target must exist or the creation of the "symlink" (copy) will fail.
     #
     # Our installation order must be such that when a symbolic link is created
     # its target must already exists. There is no race condition for parallel
     # builds because the generated cmake_install.cmake executes serially.
     install(TARGETS xz
             RUNTIME DESTINATION "${CMAKE_INSTALL_BINDIR}"
                     COMPONENT xz_Runtime)
 
     if(UNIX)
         option(CREATE_XZ_SYMLINKS "Create unxz and xzcat symlinks" ON)
         option(CREATE_LZMA_SYMLINKS "Create lzma, unlzma, and lzcat symlinks"
                ON)
         set(XZ_LINKS)
 
         if(CREATE_XZ_SYMLINKS)
             list(APPEND XZ_LINKS "unxz" "xzcat")
         endif()
 
         if(CREATE_LZMA_SYMLINKS)
             list(APPEND XZ_LINKS "lzma" "unlzma" "lzcat")
         endif()
 
         # On Cygwin, don't add the .exe suffix to the symlinks.
         #
         # FIXME? Does this make sense on MSYS & MSYS2 where "ln -s"
         # by default makes copies? Inside MSYS & MSYS2 it is possible
         # to execute files without the .exe suffix but not outside
         # (like in Command Prompt). Omitting the suffix matches
         # what configure.ac has done for many years though.
         my_install_symlinks(xz_Runtime "${CMAKE_INSTALL_BINDIR}"
                             "xz${CMAKE_EXECUTABLE_SUFFIX}" "" "${XZ_LINKS}")
 
         # Install the man pages and (optionally) their symlinks
         # and translations.
         my_install_man(xz_Documentation src/xz/xz.1 "${XZ_LINKS}")
     endif()
 endif()
 
 
 #############################################################################
 # Scripts
 #############################################################################
 
 if(UNIX)
     # NOTE: This isn't as sophisticated as in the Autotools build which
     # uses posix-shell.m4 but hopefully this doesn't need to be either.
     # CMake likely won't be used on as many (old) obscure systems as the
     # Autotools-based builds are.
     if(CMAKE_SYSTEM_NAME STREQUAL "SunOS" AND EXISTS "/usr/xpg4/bin/sh")
         set(POSIX_SHELL_DEFAULT "/usr/xpg4/bin/sh")
     else()
         set(POSIX_SHELL_DEFAULT "/bin/sh")
     endif()
 
     set(POSIX_SHELL "${POSIX_SHELL_DEFAULT}" CACHE STRING
         "Shell to use for scripts (xzgrep and others)")
 
     # Guess the extra path to add from POSIX_SHELL. Autotools-based build
     # has a separate option --enable-path-for-scripts=PREFIX but this is
     # enough for Solaris.
     set(enable_path_for_scripts)
     get_filename_component(POSIX_SHELL_DIR "${POSIX_SHELL}" DIRECTORY)
 
     if(NOT POSIX_SHELL_DIR STREQUAL "/bin" AND
             NOT POSIX_SHELL_DIR STREQUAL "/usr/bin")
         set(enable_path_for_scripts "PATH=${POSIX_SHELL_DIR}:\$PATH")
     endif()
 
     set(XZDIFF_LINKS xzcmp)
     set(XZGREP_LINKS xzegrep xzfgrep)
     set(XZMORE_LINKS)
     set(XZLESS_LINKS)
 
     if(CREATE_LZMA_SYMLINKS)
         list(APPEND XZDIFF_LINKS lzdiff lzcmp)
         list(APPEND XZGREP_LINKS lzgrep lzegrep lzfgrep)
         list(APPEND XZMORE_LINKS lzmore)
         list(APPEND XZLESS_LINKS lzless)
     endif()
 
     set(xz "xz")
 
     foreach(S xzdiff xzgrep xzmore xzless)
         configure_file("src/scripts/${S}.in" "${S}"
                @ONLY
                NEWLINE_STYLE LF)
 
         install(PROGRAMS "${CMAKE_CURRENT_BINARY_DIR}/${S}"
                 DESTINATION "${CMAKE_INSTALL_BINDIR}"
                 COMPONENT scripts_Runtime)
     endforeach()
 
     # file(CHMOD ...) would need CMake 3.19 so use execute_process instead.
     # Using +x is fine even if umask was 077. If execute bit is set at all
     # then "make install" will set it for group and other access bits too.
     execute_process(COMMAND chmod +x xzdiff xzgrep xzmore xzless
                     WORKING_DIRECTORY "${CMAKE_CURRENT_BINARY_DIR}")
 
     unset(xz)
     unset(POSIX_SHELL)
     unset(enable_path_for_scripts)
 
     my_install_symlinks(scripts_Runtime "${CMAKE_INSTALL_BINDIR}" xzdiff ""
                         "${XZDIFF_LINKS}")
 
     my_install_symlinks(scripts_Runtime "${CMAKE_INSTALL_BINDIR}" xzgrep ""
                         "${XZGREP_LINKS}")
 
     my_install_symlinks(scripts_Runtime "${CMAKE_INSTALL_BINDIR}" xzmore ""
                         "${XZMORE_LINKS}")
 
     my_install_symlinks(scripts_Runtime "${CMAKE_INSTALL_BINDIR}" xzless ""
                         "${XZLESS_LINKS}")
 
     my_install_man(scripts_Documentation src/scripts/xzdiff.1 "${XZDIFF_LINKS}")
     my_install_man(scripts_Documentation src/scripts/xzgrep.1 "${XZGREP_LINKS}")
     my_install_man(scripts_Documentation src/scripts/xzmore.1 "${XZMORE_LINKS}")
     my_install_man(scripts_Documentation src/scripts/xzless.1 "${XZLESS_LINKS}")
 endif()
 
 
 #############################################################################
 # Documentation
 #############################################################################
 
 # Use OPTIONAL because doc/api might not exist. The liblzma API docs
 # can be generated by running "doxygen/update-doxygen".
 install(DIRECTORY doc/api doc/examples
         DESTINATION "${CMAKE_INSTALL_DOCDIR}"
         COMPONENT liblzma_Documentation
         OPTIONAL)
 
 # GPLv2 applies to the scripts. If GNU getopt_long is used then
 # LGPLv2.1 applies to the command line tools but, using the
 # section 3 of LGPLv2.1, GNU getopt_long can be handled as GPLv2 too.
 # Thus GPLv2 should be enough here.
 install(FILES AUTHORS
               COPYING
               COPYING.0BSD
               COPYING.GPLv2
               NEWS
               README
               THANKS
               doc/faq.txt
               doc/history.txt
               doc/lzma-file-format.txt
               doc/xz-file-format.txt
         DESTINATION "${CMAKE_INSTALL_DOCDIR}"
         COMPONENT Documentation)
 
 
 #############################################################################
 # Tests
 #############################################################################
 
 include(CTest)
 
 if(BUILD_TESTING)
     set(LIBLZMA_TESTS
         test_bcj_exact_size
         test_block_header
         test_check
         test_filter_flags
         test_filter_str
         test_hardware
         test_index
         test_index_hash
         test_lzip_decoder
         test_memlimit
         test_stream_flags
         test_vli
     )
 
     foreach(TEST IN LISTS LIBLZMA_TESTS)
         add_executable("${TEST}" "tests/${TEST}.c")
 
         target_include_directories("${TEST}" PRIVATE
             src/common
             src/liblzma/api
             src/liblzma
         )
 
         target_link_libraries("${TEST}" PRIVATE liblzma)
 
         # Put the test programs into their own subdirectory so they don't
         # pollute the top-level dir which might contain xz and xzdec.
         set_target_properties("${TEST}" PROPERTIES
             RUNTIME_OUTPUT_DIRECTORY "${CMAKE_CURRENT_BINARY_DIR}/tests_bin"
         )
 
         add_test(NAME "${TEST}"
                  COMMAND "${CMAKE_CURRENT_BINARY_DIR}/tests_bin/${TEST}"
         )
 
         # Set srcdir environment variable so that the tests find their
         # input files from the source tree.
         #
         # Set the return code for skipped tests to match Automake convention.
         set_tests_properties("${TEST}" PROPERTIES
             ENVIRONMENT "srcdir=${CMAKE_CURRENT_SOURCE_DIR}/tests"
             SKIP_RETURN_CODE 77
         )
     endforeach()
 
     if(UNIX AND HAVE_DECODERS)
         file(MAKE_DIRECTORY "${CMAKE_CURRENT_BINARY_DIR}/test_scripts")
 
         add_test(NAME test_scripts.sh
             COMMAND "${CMAKE_CURRENT_SOURCE_DIR}/tests/test_scripts.sh" ".."
             WORKING_DIRECTORY "${CMAKE_CURRENT_BINARY_DIR}/test_scripts"
         )
 
         set_tests_properties(test_scripts.sh PROPERTIES
             ENVIRONMENT "srcdir=${CMAKE_CURRENT_SOURCE_DIR}/tests"
             SKIP_RETURN_CODE 77
         )
     endif()
 endif()
diff --git a/NEWS b/NEWS
index 65a8724d..2e9f408a 100644
--- a/NEWS
+++ b/NEWS
@@ -1,2148 +1,2148 @@
 
 XZ Utils Release Notes
 ======================
 
 5.6.0 (2024-02-24)
 
     This bumps the minor version of liblzma because new features were
     added. The API and ABI are still backward compatible with liblzma
     5.4.x and 5.2.x and 5.0.x.
 
     NOTE: As described in the NEWS for 5.5.2beta, the core components
     are now under the BSD Zero Clause License (0BSD).
 
     Since 5.5.2beta:
 
     * liblzma:
 
         - Disabled the branchless C variant in the LZMA decoder based
           on the benchmark results from the community.
 
         - Disabled x86-64 inline assembly on x32 to fix the build.
 
     * Sandboxing support in xz:
 
         - Landlock is now used even when xz needs to create files.
-          In this case the sandbox is has to be more permissive than
+          In this case the sandbox has to be more permissive than
           when no files need to be created. A similar thing was
           already in use with pledge(2) since 5.3.4alpha.
 
         - Landlock and pledge(2) are now stricter when reading from
           more than one input file and only writing to standard output.
 
         - Added support for Landlock ABI version 4.
 
     * CMake:
 
         - Default to -O2 instead of -O3 with CMAKE_BUILD_TYPE=Release.
           -O3 is not useful for speed and makes the code larger.
 
         - Now builds lzmainfo and lzmadec.
 
         - xzdiff, xzgrep, xzless, xzmore, and their symlinks are now
           installed. The scripts are also tested during "make test".
 
         - Added translation support for xz, lzmainfo, and the
           man pages.
 
         - Applied the symbol versioning workaround for MicroBlaze that
           is used in the Autotools build.
 
         - The general XZ Utils and liblzma API documentation is now
           installed.
 
         - The CMake component names were changed a little and several
           were added. liblzma_Runtime and liblzma_Development are
           unchanged.
 
         - Minimum required CMake version is now 3.14. However,
           translation support is disabled with CMake versions
           older than 3.20.
 
         - The CMake-based build is now close to feature parity with the
           Autotools-based build. Most importantly a few tests aren't
           run yet. Testing the CMake-based build on different operating
           systems would be welcome now. See the comment at the top of
           CMakeLists.txt.
 
     * Fixed a bug in the Autotools feature test for ARM64 CRC32
       instruction support for old versions of Clang. This did not
       affect the CMake build.
 
     * Windows:
 
         - The build instructions in INSTALL and windows/INSTALL*.txt
           were revised completely.
 
         - windows/build-with-cmake.bat along with the instructions
           in windows/INSTALL-MinGW-w64_with_CMake.txt should make
           it very easy to build liblzma.dll and xz.exe on Windows
           using CMake and MinGW-w64 with either GCC or Clang/LLVM.
 
         - windows/build.bash was updated. It now works on MSYS2 and
           on GNU/Linux (cross-compiling) to create a .zip and .7z
           package for 32-bit and 64-bit x86 using GCC + MinGW-w64.
 
     * The TODO file is no longer installed as part of the
       documentation. The file is out of date and does not reflect
       the actual tasks that will be completed in the future.
 
     * Translations:
 
         - Translated lzmainfo man pages are now installed. These
           had been forgotten in earlier versions.
 
         - Updated Croatian, Esperanto, German, Hungarian, Korean,
           Polish, Romanian, Spanish, Swedish, Vietnamese, and Ukrainian
           translations.
 
         - Updated German, Korean, Romanian, and Ukrainian man page
           translations.
 
     * Added a few tests.
 
     Summary of new features added in the 5.5.x development releases:
 
     * liblzma:
 
         - LZMA decoder: Speed optimizations to the C code and
           added GCC & Clang compatible inline assembly for x86-64.
 
         - Added lzma_mt_block_size() to recommend a Block size for
           multithreaded encoding.
 
         - Added CLMUL-based CRC32 on x86-64 and E2K with runtime
           processor detection. Similar to CRC64, on 32-bit x86 it
           isn't available unless --disable-assembler is used.
 
         - Optimized the CRC32 calculation on ARM64 platforms using the
           CRC32 instructions. Runtime detection for the instruction is
           used on GNU/Linux, FreeBSD, Windows, and macOS. If the
           compiler flags indicate unconditional CRC32 instruction
           support (+crc) then the generic version is not built.
 
         - Added definitions of mask values like
           LZMA_INDEX_CHECK_MASK_CRC32 to <lzma/index.h>.
 
     * xz:
 
         - Multithreaded mode is now the default. This improves
           compression speed and creates .xz files that can be
           decompressed in multithreaded mode. The downsides are
           increased memory usage and slightly worse compression ratio.
 
         - Added a new command line option --filters to set the filter
           chain using the liblzma filter string syntax.
 
         - Added new command line options --filters1 ... --filters9 to
           set additional filter chains using the liblzma filter string
           syntax. The --block-list option now allows specifying filter
           chains that were set using these new options.
 
         - Ported the command line tools to Windows MSVC.
           Visual Studio 2015 or later is required.
 
     * Added lz4 support to xzdiff/xzcmp and xzgrep.
 
 
 5.5.2beta (2024-02-14)
 
     * Licensing change: The core components are now under the
       BSD Zero Clause License (0BSD). In XZ Utils 5.4.6 and older
       and 5.5.1alpha these components are in the public domain and
       obviously remain so; the change affects the new releases only.
 
       0BSD is an extremely permissive license which doesn't require
       retaining or reproducing copyright or license notices when
       distributing the code, thus in practice there is extremely
       little difference to public domain.
 
     * liblzma
 
         - Significant speed optimizations to the LZMA decoder were
           made. There are now three variants that can be chosen at
           build time:
 
             * Basic C version: This is a few percent faster than
               5.4.x due to some new optimizations.
 
             * Branchless C: This is currently the default on platforms
               for which there is no assembly code. This should be a few
               percent faster than the basic C version.
 
             * x86-64 inline assembly. This works with GCC and Clang.
 
           The default choice can currently be overridden by setting
           LZMA_RANGE_DECODER_CONFIG in CPPFLAGS: 0 means the basic
           version and 3 means that branchless C version.
 
         - Optimized the CRC32 calculation on ARM64 platforms using the
           CRC32 instructions. The instructions are optional in ARMv8.0
           and are required in ARMv8.1 and later. Runtime detection for
           the instruction is used on GNU/Linux, FreeBSD, Windows, and
           macOS. If the compiler flags indicate unconditional CRC32
           instruction support (+crc) then the generic version is not
           built.
 
     * Added lz4 support to xzdiff/xzcmp and xzgrep.
 
     * Man pages of xzdiff/xzcmp, xzgrep, and xzmore were rewritten
       to simplify licensing of the man page translations.
 
     * Translations:
 
         - Updated Chinese (simplified), German, Korean, Polish,
           Romanian, Spanish, Swedish, and Ukrainian translations.
 
         - Updated German, Korean, Romanian, and Ukrainian man page
           translations.
 
     * Small improvements to the tests.
 
     * Added doc/examples/11_file_info.c. It was added to the Git
       repository in 2017 but forgotten to be added into distribution
       tarballs.
 
     * Removed doc/examples_old. These were from 2012.
 
     * Removed the macos/build.sh script. It had not been updated
       since 2013.
 
 
 5.5.1alpha (2024-01-26)
 
     * Added a new filter for RISC-V binaries. The filter can be used
       for 32-bit and 64-bit binaries with either little or big
       endianness. In liblzma, the Filter ID is LZMA_FILTER_RISCV (0x0B)
       and the xz option is --riscv. liblzma filter string syntax
       recognizes this filter as "riscv".
 
     * liblzma:
 
         - Added lzma_mt_block_size() to recommend a Block size for
           multithreaded encoding
 
         - Added CLMUL-based CRC32 on x86-64 and E2K with runtime
           processor detection. Similar to CRC64, on 32-bit x86 it
           isn't available unless --disable-assembler is used.
 
         - Implemented GNU indirect function (IFUNC) as a runtime
           function dispatching method for CRC32 and CRC64 fast
           implementations on x86. Only GNU/Linux (glibc) and FreeBSD
           builds will use IFUNC, unless --enable-ifunc is specified to
           configure.
 
         - Added definitions of mask values like
           LZMA_INDEX_CHECK_MASK_CRC32 to <lzma/index.h>.
 
         - The XZ logo is now included in the Doxygen generated
           documentation. It is licensed under Creative Commons
           Attribution-ShareAlike 4.0.
 
     * xz:
 
         - Multithreaded mode is now the default. This improves
           compression speed and creates .xz files that can be
           decompressed multithreaded at the cost of increased memory
           usage and slightly worse compression ratio.
 
         - Added new command line option --filters to set the filter
           chain using liblzma filter string syntax.
 
         - Added new command line options --filters1 ... --filters9 to
           set additional filter chains using liblzma filter string
           syntax. The --block-list option now allows specifying filter
           chains that were set using these new options.
 
         - Added support for Linux Landlock as a sandboxing method.
 
         - xzdec now supports pledge(2), Capsicum, and Linux Landlock as
           sandboxing methods.
 
         - Progress indicator time stats remain accurate after pausing
           xz with SIGTSTP.
 
         - Ported xz and xzdec to Windows MSVC. Visual Studio 2015 or
           later is required.
 
     * CMake Build:
 
         - Supports pledge(2), Capsicum, and Linux Landlock sandboxing
           methods.
 
         - Replacement functions for getopt_long() are used on platforms
           that do not have it.
 
     * Enabled unaligned access by default on PowerPC64LE and on RISC-V
       targets that define __riscv_misaligned_fast.
 
     * Tests:
 
         - Added two new fuzz targets to OSS-Fuzz.
 
         - Implemented Continuous Integration (CI) testing using
           GitHub Actions.
 
     * Changed quoting style from `...' to '...' in all messages,
       scripts, and documentation.
 
     * Added basic Codespell support to help catch typo errors.
 
 
 5.4.6 (2024-01-26)
 
     * Fixed a bug involving internal function pointers in liblzma not
       being initialized to NULL. The bug can only be triggered if
       lzma_filters_update() is called on a LZMA1 encoder, so it does
       not affect xz or any application known to us that uses liblzma.
 
     * xz:
 
         - Fixed a regression introduced in 5.4.2 that caused encoding
           in the raw format to unnecessarily fail if --suffix was not
           used. For instance, the following command no longer reports
           that --suffix must be used:
 
               echo foo | xz --format=raw --lzma2 | wc -c
 
         - Fixed an issue on MinGW-w64 builds that prevented reading
           from or writing to non-terminal character devices like NUL.
 
     * Added a new test.
 
 
 5.4.5 (2023-11-31)
 
     * liblzma:
 
         - Use __attribute__((__no_sanitize_address__)) to avoid address
           sanitization with CRC64 CLMUL. It uses 16-byte-aligned reads
           which can extend past the bounds of the input buffer and
           inherently trigger address sanitization errors. This isn't
           a bug.
 
         - Fixed an assertion failure that could be triggered by a large
           unpadded_size argument. It was verified that there was no
           other bug than the assertion failure.
 
         - Fixed a bug that prevented building with Windows Vista
           threading when __attribute__((__constructor__)) is not
           supported.
 
     * xz now properly handles special files such as "con" or "nul" on
       Windows. Before this fix, the following wrote "foo" to the
       console and deleted the input file "con_xz":
 
           echo foo | xz > con_xz
           xz --suffix=_xz --decompress con_xz
 
     * Build systems:
 
         - Allow builds with Windows win95 threading and small mode when
           __attribute__((__constructor__)) is supported.
 
         - Added a new line to liblzma.pc for MSYS2 (Windows):
 
               Cflags.private: -DLZMA_API_STATIC
 
           When compiling code that will link against static liblzma,
           the LZMA_API_STATIC macro needs to be defined on Windows.
 
         - CMake specific changes:
 
             * Fixed a bug that allowed CLOCK_MONOTONIC to be used even
               if the check for it failed.
 
             * Fixed a bug where configuring CMake multiple times
               resulted in HAVE_CLOCK_GETTIME and HAVE_CLOCK_MONOTONIC
               not being set.
 
             * Fixed the build with MinGW-w64-based Clang/LLVM 17.
               llvm-windres now has more accurate GNU windres emulation
               so the GNU windres workaround from 5.4.1 is needed with
               llvm-windres version 17 too.
 
             * The import library on Windows is now properly named
               "liblzma.dll.a" instead of "libliblzma.dll.a"
 
             * Fixed a bug causing the Ninja Generator to fail on
               UNIX-like systems. This bug was introduced in 5.4.0.
 
             * Added a new option to disable CLMUL CRC64.
 
             * A module-definition (.def) file is now created when
               building liblzma.dll with MinGW-w64.
 
             * The pkg-config liblzma.pc file is now installed on all
               builds except when using MSVC on Windows.
 
             * Added large file support by default for platforms that
               need it to handle files larger than 2 GiB. This includes
               MinGW-w64, even 64-bit builds.
 
     * Small fixes and improvements to the tests.
 
     * Updated translations: Chinese (simplified) and Esperanto.
 
 
 5.4.4 (2023-08-02)
 
     * liblzma and xzdec can now build against WASI SDK when threading
       support is disabled. xz and tests don't build yet.
 
     * CMake:
 
         - Fixed a bug preventing other projects from including liblzma
           multiple times using find_package().
 
         - Don't create broken symlinks in Cygwin and MSYS2 unless
           supported by the environment. This prevented building for the
           default MSYS2 environment. The problem was introduced in
           xz 5.4.0.
 
     * Documentation:
 
         - Small improvements to man pages.
 
         - Small improvements and typo fixes for liblzma API
           documentation.
 
     * Tests:
 
         - Added a new section to INSTALL to describe basic test usage
           and address recent questions about building the tests when
           cross compiling.
 
         - Small fixes and improvements to the tests.
 
     * Translations:
 
         - Fixed a mistake that caused one of the error messages to not
           be translated. This only affected versions 5.4.2 and 5.4.3.
 
         - Updated the Chinese (simplified), Croatian, Esperanto, German,
           Korean, Polish, Romanian, Spanish, Swedish, Ukrainian, and
           Vietnamese translations.
 
         - Updated the German, Korean, Romanian, and Ukrainian man page
           translations.
 
 
 5.4.3 (2023-05-04)
 
     * All fixes from 5.2.12
 
     * Features in the CMake build can now be disabled as CMake cache
       variables, similar to the Autotools build.
 
     * Minor update to the Croatian translation.
 
 
 5.4.2 (2023-03-18)
 
     * All fixes from 5.2.11 that were not included in 5.4.1.
 
     * If xz is built with support for the Capsicum sandbox but running
       in an environment that doesn't support Capsicum, xz now runs
       normally without sandboxing instead of exiting with an error.
 
     * liblzma:
 
         - Documentation was updated to improve the style, consistency,
           and completeness of the liblzma API headers.
 
         - The Doxygen-generated HTML documentation for the liblzma API
           header files is now included in the source release and is
           installed as part of "make install". All JavaScript is
           removed to simplify license compliance and to reduce the
           install size.
 
         - Fixed a minor bug in lzma_str_from_filters() that produced
           too many filters in the output string instead of reporting
           an error if the input array had more than four filters. This
           bug did not affect xz.
 
     * Build systems:
 
         - autogen.sh now invokes the doxygen tool via the new wrapper
           script doxygen/update-doxygen, unless the command line option
           --no-doxygen is used.
 
         - Added microlzma_encoder.c and microlzma_decoder.c to the
           VS project files for Windows and to the CMake build. These
           should have been included in 5.3.2alpha.
 
     * Tests:
 
         - Added a test to the CMake build that was forgotten in the
           previous release.
 
         - Added and refactored a few tests.
 
     * Translations:
 
         - Updated the Brazilian Portuguese translation.
 
         - Added Brazilian Portuguese man page translation.
 
 
 5.4.1 (2023-01-11)
 
     * liblzma:
 
         - Fixed the return value of lzma_microlzma_encoder() if the
           LZMA options lc/lp/pb are invalid. Invalid lc/lp/pb options
           made the function return LZMA_STREAM_END without encoding
           anything instead of returning LZMA_OPTIONS_ERROR.
 
         - Windows / Visual Studio: Workaround a possible compiler bug
           when targeting 32-bit x86 and compiling the CLMUL version of
           the CRC64 code. The CLMUL code isn't enabled by the Windows
           project files but it is in the CMake-based builds.
 
     * Build systems:
 
         - Windows-specific CMake changes:
 
             * Don't try to enable CLMUL CRC64 code if _mm_set_epi64x()
               isn't available. This fixes CMake-based build with Visual
               Studio 2013.
 
             * Created a workaround for a build failure with windres
               from GNU binutils. It is used only when the C compiler
               is GCC (not Clang). The workaround is incompatible
               with llvm-windres, resulting in "XZx20Utils" instead
               of "XZ Utils" in the resource file, but without the
               workaround llvm-windres works correctly. See the
               comment in CMakeLists.txt for details.
 
             * Included the resource files in the xz and xzdec build
               rules. Building the command line tools is still
               experimental but possible with MinGW-w64.
 
         - Visual Studio: Added stream_decoder_mt.c to the project
           files. Now the threaded decompressor lzma_stream_decoder_mt()
           gets built. CMake-based build wasn't affected.
 
         - Updated windows/INSTALL-MSVC.txt to mention that CMake-based
           build is now the preferred method with Visual Studio. The
           project files will probably be removed after 5.4.x releases.
 
         - Changes to #defines in config.h:
 
             * HAVE_DECL_CLOCK_MONOTONIC was replaced by
               HAVE_CLOCK_MONOTONIC. The old macro was always defined
               in configure-generated config.h to either 0 or 1. The
               new macro is defined (to 1) only if the declaration of
               CLOCK_MONOTONIC is available. This matches the way most
               other config.h macros work and makes things simpler with
               other build systems.
 
             * HAVE_DECL_PROGRAM_INVOCATION_NAME was replaced by
               HAVE_PROGRAM_INVOCATION_NAME for the same reason.
 
     * Tests:
 
         - Fixed test script compatibility with ancient /bin/sh
           versions. Now the five test_compress_* tests should
           no longer fail on Solaris 10.
 
         - Added and refactored a few tests.
 
     * Translations:
 
         - Updated the Catalan and Esperanto translations.
 
         - Added Korean and Ukrainian man page translations.
 
 
 5.4.0 (2022-12-13)
 
     This bumps the minor version of liblzma because new features were
     added. The API and ABI are still backward compatible with liblzma
     5.2.x and 5.0.x.
 
     Since 5.3.5beta:
 
     * All fixes from 5.2.10.
 
     * The ARM64 filter is now stable. The xz option is now --arm64.
       Decompression requires XZ Utils 5.4.0. In the future the ARM64
       filter will be supported by XZ for Java, XZ Embedded (including
       the version in Linux), LZMA SDK, and 7-Zip.
 
     * Translations:
 
         - Updated Catalan, Croatian, German, Romanian, and Turkish
           translations.
 
         - Updated German man page translations.
 
         - Added Romanian man page translations.
 
     Summary of new features added in the 5.3.x development releases:
 
     * liblzma:
 
         - Added threaded .xz decompressor lzma_stream_decoder_mt().
           It can use multiple threads with .xz files that have multiple
           Blocks with size information in Block Headers. The threaded
           encoder in xz has always created such files.
 
           Single-threaded encoder cannot store the size information in
           Block Headers even if one used LZMA_FULL_FLUSH to create
           multiple Blocks, so this threaded decoder cannot use multiple
           threads with such files.
 
           If there are multiple Streams (concatenated .xz files), one
           Stream will be decompressed completely before starting the
           next Stream.
 
         - A new decoder flag LZMA_FAIL_FAST was added. It makes the
           threaded decompressor report errors soon instead of first
           flushing all pending data before the error location.
 
         - New Filter IDs:
             * LZMA_FILTER_ARM64 is for ARM64 binaries.
             * LZMA_FILTER_LZMA1EXT is for raw LZMA1 streams that don't
               necessarily use the end marker.
 
         - Added lzma_str_to_filters(), lzma_str_from_filters(), and
           lzma_str_list_filters() to convert a preset or a filter chain
           string to a lzma_filter[] and vice versa. These should make
           it easier to write applications that allow users to specify
           custom compression options.
 
         - Added lzma_filters_free() which can be convenient for freeing
           the filter options in a filter chain (an array of lzma_filter
           structures).
 
         - lzma_file_info_decoder() to makes it a little easier to get
           the Index field from .xz files. This helps in getting the
           uncompressed file size but an easy-to-use random access
           API is still missing which has existed in XZ for Java for
           a long time.
 
         - Added lzma_microlzma_encoder() and lzma_microlzma_decoder().
           It is used by erofs-utils and may be used by others too.
 
           The MicroLZMA format is a raw LZMA stream (without end marker)
           whose first byte (always 0x00) has been replaced with
           bitwise-negation of the LZMA properties (lc/lp/pb). It was
           created for use in EROFS but may be used in other contexts
           as well where it is important to avoid wasting bytes for
           stream headers or footers. The format is also supported by
           XZ Embedded (the XZ Embedded version in Linux got MicroLZMA
           support in Linux 5.16).
 
           The MicroLZMA encoder API in liblzma can compress into a
           fixed-sized output buffer so that as much data is compressed
           as can be fit into the buffer while still creating a valid
           MicroLZMA stream. This is needed for EROFS.
 
         - Added lzma_lzip_decoder() to decompress the .lz (lzip) file
           format version 0 and the original unextended version 1 files.
           Also lzma_auto_decoder() supports .lz files.
 
         - lzma_filters_update() can now be used with the multi-threaded
           encoder (lzma_stream_encoder_mt()) to change the filter chain
           after LZMA_FULL_BARRIER or LZMA_FULL_FLUSH.
 
         - In lzma_options_lzma, allow nice_len = 2 and 3 with the match
           finders that require at least 3 or 4. Now it is internally
           rounded up if needed.
 
         - CLMUL-based CRC64 on x86-64 and E2K with runtime processor
           detection. On 32-bit x86 it currently isn't available unless
           --disable-assembler is used which can make the non-CLMUL
           CRC64 slower; this might be fixed in the future.
 
         - Building with --disable-threads --enable-small
           is now thread-safe if the compiler supports
           __attribute__((__constructor__)).
 
     * xz:
 
         - Using -T0 (--threads=0) will now use multi-threaded encoder
           even on a single-core system. This is to ensure that output
           from the same xz binary is identical on both single-core and
           multi-core systems.
 
         - --threads=+1 or -T+1 is now a way to put xz into
           multi-threaded mode while using only one worker thread.
           The + is ignored if the number is not 1.
 
         - A default soft memory usage limit is now used for compression
           when -T0 is used and no explicit limit has been specified.
           This soft limit is used to restrict the number of threads
           but if the limit is exceeded with even one thread then xz
           will continue with one thread using the multi-threaded
           encoder and this limit is ignored. If the number of threads
           is specified manually then no default limit will be used;
           this affects only -T0.
 
           This change helps on systems that have very many cores and
           using all of them for xz makes no sense. Previously xz -T0
           could run out of memory on such systems because it attempted
           to reserve memory for too many threads.
 
           This also helps with 32-bit builds which don't have a large
           amount of address space that would be required for many
           threads. The default soft limit for -T0 is at most 1400 MiB
           on all 32-bit platforms.
 
         - Previously a low value in --memlimit-compress wouldn't cause
           xz to switch from multi-threaded mode to single-threaded mode
           if the limit cannot otherwise be met; xz failed instead. Now
           xz can switch to single-threaded mode and then, if needed,
           scale down the LZMA2 dictionary size too just like it already
           did when it was started in single-threaded mode.
 
         - The option --no-adjust no longer prevents xz from scaling down
           the number of threads as that doesn't affect the compressed
           output (only performance). Now --no-adjust only prevents
           adjustments that affect compressed output, that is, with
           --no-adjust xz won't switch from multi-threaded mode to
           single-threaded mode and won't scale down the LZMA2
           dictionary size.
 
         - Added a new option --memlimit-mt-decompress=LIMIT. This is
           used to limit the number of decompressor threads (possibly
           falling back to single-threaded mode) but it will never make
           xz refuse to decompress a file. This has a system-specific
           default value because without any limit xz could end up
           allocating memory for the whole compressed input file, the
           whole uncompressed output file, multiple thread-specific
           decompressor instances and so on. Basically xz could
           attempt to use an insane amount of memory even with fairly
           common files. The system-specific default value is currently
           the same as the one used for compression with -T0.
 
           The new option works together with the existing option
           --memlimit-decompress=LIMIT. The old option sets a hard limit
           that must not be exceeded (xz will refuse to decompress)
           while the new option only restricts the number of threads.
           If the limit set with --memlimit-mt-decompress is greater
           than the limit set with --memlimit-compress, then the latter
           value is used also for --memlimit-mt-decompress.
 
         - Added new information to the output of xz --info-memory and
           new fields to the output of xz --robot --info-memory.
 
         - In --lzma2=nice=NUMBER allow 2 and 3 with all match finders
           now that liblzma handles it.
 
         - Don't mention endianness for ARM and ARM-Thumb filters in
           --long-help. The filters only work for little endian
           instruction encoding but modern ARM processors using
           big endian data access still use little endian
           instruction encoding. So the help text was misleading.
           In contrast, the PowerPC filter is only for big endian
           32/64-bit PowerPC code. Little endian PowerPC would need
           a separate filter.
 
         - Added decompression support for the .lz (lzip) file format
           version 0 and the original unextended version 1. It is
           autodetected by default. See also the option --format on
           the xz man page.
 
         - Sandboxing enabled by default:
             * Capsicum (FreeBSD)
             * pledge(2) (OpenBSD)
 
     * Scripts now support the .lz format using xz.
 
     * A few new tests were added.
 
     * The liblzma-specific tests are now supported in CMake-based
       builds too ("make test").
 
 
 5.3.5beta (2022-12-01)
 
     * All fixes from 5.2.9.
 
     * liblzma:
 
         - Added new LZMA_FILTER_LZMA1EXT for raw encoder and decoder to
           handle raw LZMA1 streams that don't have end of payload marker
           (EOPM) alias end of stream (EOS) marker. It can be used in
           filter chains, for example, with the x86 BCJ filter.
 
         - Added lzma_str_to_filters(), lzma_str_from_filters(), and
           lzma_str_list_filters() to make it easier for applications
           to get custom compression options from a user and convert
           it to an array of lzma_filter structures.
 
         - Added lzma_filters_free().
 
         - lzma_filters_update() can now be used with the multi-threaded
           encoder (lzma_stream_encoder_mt()) to change the filter chain
           after LZMA_FULL_BARRIER or LZMA_FULL_FLUSH.
 
         - In lzma_options_lzma, allow nice_len = 2 and 3 with the match
           finders that require at least 3 or 4. Now it is internally
           rounded up if needed.
 
         - ARM64 filter was modified. It is still experimental.
 
         - Fixed LTO build with Clang if -fgnuc-version=10 or similar
           was used to make Clang look like GCC >= 10. Now it uses
           __has_attribute(__symver__) which should be reliable.
 
     * xz:
 
         - --threads=+1 or -T+1 is now a way to put xz into multi-threaded
           mode while using only one worker thread.
 
         - In --lzma2=nice=NUMBER allow 2 and 3 with all match finders
           now that liblzma handles it.
 
     * Updated translations: Chinese (simplified), Korean, and Turkish.
 
 
 5.3.4alpha (2022-11-15)
 
     * All fixes from 5.2.7 and 5.2.8.
 
     * liblzma:
 
         - Minor improvements to the threaded decoder.
 
         - Added CRC64 implementation that uses SSSE3, SSE4.1, and CLMUL
           instructions on 32/64-bit x86 and E2K. On 32-bit x86 it's
           not enabled unless --disable-assembler is used but then
           the non-CLMUL code might be slower. Processor support is
           detected at runtime so this is built by default on x86-64
           and E2K. On these platforms, if compiler flags indicate
           unconditional CLMUL support (-msse4.1 -mpclmul) then the
           generic version is not built, making liblzma 8-9 KiB smaller
           compared to having both versions included.
 
           With extremely compressible files this can make decompression
           up to twice as fast but with typical files 5 % improvement
           is a more realistic expectation.
 
           The CLMUL version is slower than the generic version with
           tiny inputs (especially at 1-8 bytes per call, but up to
           16 bytes). In normal use in xz this doesn't matter at all.
 
         - Added an experimental ARM64 filter. This is *not* the final
           version! Files created with this experimental version won't
           be supported in the future versions! The filter design is
           a compromise where improving one use case makes some other
           cases worse.
 
         - Added decompression support for the .lz (lzip) file format
           version 0 and the original unextended version 1. See the
           API docs of lzma_lzip_decoder() for details. Also
           lzma_auto_decoder() supports .lz files.
 
         - Building with --disable-threads --enable-small
           is now thread-safe if the compiler supports
           __attribute__((__constructor__))
 
     * xz:
 
         - Added support for OpenBSD's pledge(2) as a sandboxing method.
 
         - Don't mention endianness for ARM and ARM-Thumb filters in
           --long-help. The filters only work for little endian
           instruction encoding but modern ARM processors using
           big endian data access still use little endian
           instruction encoding. So the help text was misleading.
           In contrast, the PowerPC filter is only for big endian
           32/64-bit PowerPC code. Little endian PowerPC would need
           a separate filter.
 
         - Added --experimental-arm64. This will be renamed once the
           filter is finished. Files created with this experimental
           filter will not be supported in the future!
 
         - Added new fields to the output of xz --robot --info-memory.
 
         - Added decompression support for the .lz (lzip) file format
           version 0 and the original unextended version 1. It is
           autodetected by default. See also the option --format on
           the xz man page.
 
     * Scripts now support the .lz format using xz.
 
     * Build systems:
 
         - New #defines in config.h: HAVE_ENCODER_ARM64,
           HAVE_DECODER_ARM64, HAVE_LZIP_DECODER, HAVE_CPUID_H,
           HAVE_FUNC_ATTRIBUTE_CONSTRUCTOR, HAVE_USABLE_CLMUL
 
         - New configure options: --disable-clmul-crc,
           --disable-microlzma, --disable-lzip-decoder, and
           'pledge' is now an option in --enable-sandbox (but
           it's autodetected by default anyway).
 
         - INSTALL was updated to document the new configure options.
 
         - PACKAGERS now lists also --disable-microlzma and
           --disable-lzip-decoder as configure options that must
           not be used in builds for non-embedded use.
 
     * Tests:
 
         - Fix some of the tests so that they skip instead of fail if
           certain features have been disabled with configure options.
           It's still not perfect.
 
         - Other improvements to tests.
 
     * Updated translations: Croatian, Finnish, Hungarian, Polish,
       Romanian, Spanish, Swedish, and Ukrainian.
 
 
 5.3.3alpha (2022-08-22)
 
     * All fixes from 5.2.6.
 
     * liblzma:
 
         - Fixed 32-bit build.
 
         - Added threaded .xz decompressor lzma_stream_decoder_mt().
           It can use multiple threads with .xz files that have multiple
           Blocks with size information in Block Headers. The threaded
           encoder in xz has always created such files.
 
           Single-threaded encoder cannot store the size information in
           Block Headers even if one used LZMA_FULL_FLUSH to create
           multiple Blocks, so this threaded decoder cannot use multiple
           threads with such files.
 
           If there are multiple Streams (concatenated .xz files), one
           Stream will be decompressed completely before starting the
           next Stream.
 
         - A new decoder flag LZMA_FAIL_FAST was added. It makes the
           threaded decompressor report errors soon instead of first
           flushing all pending data before the error location.
 
     * xz:
 
         - Using -T0 (--threads=0) will now use multi-threaded encoder
           even on a single-core system. This is to ensure that output
           from the same xz binary is identical on both single-core and
           multi-core systems.
 
         - A default soft memory usage limit is now used for compression
           when -T0 is used and no explicit limit has been specified.
           This soft limit is used to restrict the number of threads
           but if the limit is exceeded with even one thread then xz
           will continue with one thread using the multi-threaded
           encoder and this limit is ignored. If the number of threads
           is specified manually then no default limit will be used;
           this affects only -T0.
 
           This change helps on systems that have very many cores and
           using all of them for xz makes no sense. Previously xz -T0
           could run out of memory on such systems because it attempted
           to reserve memory for too many threads.
 
           This also helps with 32-bit builds which don't have a large
           amount of address space that would be required for many
           threads. The default limit is 1400 MiB on all 32-bit
           platforms with -T0.
 
           Now xz -T0 should just work. It might use too few threads
           in some cases but at least it shouldn't easily run out of
           memory. It's possible that this will be tweaked before 5.4.0.
 
         - Changes to --memlimit-compress and --no-adjust:
 
           In single-threaded mode, --memlimit-compress can make xz
           scale down the LZMA2 dictionary size to meet the memory usage
           limit. This obviously affects the compressed output. However,
           if xz was in threaded mode, --memlimit-compress could make xz
           reduce the number of threads but it wouldn't make xz switch
           from multi-threaded mode to single-threaded mode or scale
           down the LZMA2 dictionary size. This seemed illogical.
 
           Now --memlimit-compress can make xz switch to single-threaded
           mode if one thread in multi-threaded mode uses too much
           memory. If memory usage is still too high, then the LZMA2
           dictionary size can be scaled down too.
 
           The option --no-adjust was also changed so that it no longer
           prevents xz from scaling down the number of threads as that
           doesn't affect compressed output (only performance). After
           this commit --no-adjust only prevents adjustments that affect
           compressed output, that is, with --no-adjust xz won't switch
           from multithreaded mode to single-threaded mode and won't
           scale down the LZMA2 dictionary size.
 
         - Added a new option --memlimit-mt-decompress=LIMIT. This is
           used to limit the number of decompressor threads (possibly
           falling back to single-threaded mode) but it will never make
           xz refuse to decompress a file. This has a system-specific
           default value because without any limit xz could end up
           allocating memory for the whole compressed input file, the
           whole uncompressed output file, multiple thread-specific
           decompressor instances and so on. Basically xz could
           attempt to use an insane amount of memory even with fairly
           common files.
 
           The new option works together with the existing option
           --memlimit-decompress=LIMIT. The old option sets a hard limit
           that must not be exceeded (xz will refuse to decompress)
           while the new option only restricts the number of threads.
           If the limit set with --memlimit-mt-decompress is greater
           than the limit set with --memlimit-compress, then the latter
           value is used also for --memlimit-mt-decompress.
 
     * Tests:
 
         - Added a few more tests.
 
         - Added tests/code_coverage.sh to create a code coverage report
           of the tests.
 
     * Build systems:
 
         - Automake's parallel test harness is now used to make tests
           finish faster.
 
         - Added the CMake files to the distribution tarball. These were
           supposed to be in 5.2.5 already.
 
         - Added liblzma tests to the CMake build.
 
         - Windows: Fix building of liblzma.dll with the included
           Visual Studio project files.
 
 
 5.3.2alpha (2021-10-28)
 
     This release was made on short notice so that recent erofs-utils can
     be built with LZMA support without needing a snapshot from xz.git.
     Thus many pending things were not included, not even updated
     translations (which would need to be updated for the new --list
     strings anyway).
 
     * All fixes from 5.2.5.
 
     * xz:
 
         - When copying metadata from the source file to the destination
           file, don't try to set the group (GID) if it is already set
           correctly. This avoids a failure on OpenBSD (and possibly on
           a few other OSes) where files may get created so that their
           group doesn't belong to the user, and fchown(2) can fail even
           if it needs to do nothing.
 
         - The --keep option now accepts symlinks, hardlinks, and
           setuid, setgid, and sticky files. Previously this required
           using --force.
 
         - Split the long strings used in --list and --info-memory modes
           to make them much easier for translators.
 
         - If built with sandbox support and enabling the sandbox fails,
           xz will now immediately exit with exit status of 1. Previously
           it would only display a warning if -vv was used.
 
         - Cap --memlimit-compress to 2000 MiB on MIPS32 because on
           MIPS32 userspace processes are limited to 2 GiB of address
           space.
 
     * liblzma:
 
         - Added lzma_microlzma_encoder() and lzma_microlzma_decoder().
           The API is in lzma/container.h.
 
           The MicroLZMA format is a raw LZMA stream (without end marker)
           whose first byte (always 0x00) has been replaced with
           bitwise-negation of the LZMA properties (lc/lp/pb). It was
           created for use in EROFS but may be used in other contexts
           as well where it is important to avoid wasting bytes for
           stream headers or footers. The format is also supported by
           XZ Embedded.
 
           The MicroLZMA encoder API in liblzma can compress into a
           fixed-sized output buffer so that as much data is compressed
           as can be fit into the buffer while still creating a valid
           MicroLZMA stream. This is needed for EROFS.
 
         - Added fuzzing support.
 
         - Support Intel Control-flow Enforcement Technology (CET) in
           32-bit x86 assembly files.
 
         - Visual Studio: Use non-standard _MSVC_LANG to detect C++
           standard version in the lzma.h API header. It's used to
           detect when "noexcept" can be used.
 
     * Scripts:
 
         - Fix exit status of xzdiff/xzcmp. Exit status could be 2 when
           the correct value is 1.
 
         - Fix exit status of xzgrep.
 
         - Detect corrupt .bz2 files in xzgrep.
 
         - Add zstd support to xzgrep and xzdiff/xzcmp.
 
         - Fix less(1) version detection in xzless. It failed if the
           version number from "less -V" contained a dot.
 
     * Fix typos and technical issues in man pages.
 
     * Build systems:
 
         - Windows: Fix building of resource files when config.h isn't
           used. CMake + Visual Studio can now build liblzma.dll.
 
         - Various fixes to the CMake support. It might still need a few
           more fixes even for liblzma-only builds.
 
 
 5.3.1alpha (2018-04-29)
 
     * All fixes from 5.2.4.
 
     * Add lzma_file_info_decoder() into liblzma and use it in xz to
       implement the --list feature.
 
     * Capsicum sandbox support is enabled by default where available
       (FreeBSD >= 10).
 
 
 5.2.12 (2023-05-04)
 
     * Fixed a build system bug that prevented building liblzma as a
       shared library when configured with --disable-threads. This bug
       affected releases 5.2.6 to 5.2.11 and 5.4.0 to 5.4.2.
 
     * Include <intrin.h> for Windows intrinsic functions where they are
       needed. This fixed a bug that prevented building liblzma using
       clang-cl on Windows.
 
     * Minor update to the Croatian translation. The small change
       applies to a string in both 5.2 and 5.4 branches.
 
 
 5.2.11 (2023-03-18)
 
     * Removed all possible cases of null pointer + 0. It is undefined
       behavior in C99 and C17. This was detected by a sanitizer and had
       not caused any known issues.
 
     * Build systems:
 
         - Added a workaround for building with GCC on MicroBlaze Linux.
           GCC 12 on MicroBlaze doesn't support the __symver__ attribute
           even though __has_attribute(__symver__) returns true. The
           build is now done without the extra RHEL/CentOS 7 symbols
           that were added in XZ Utils 5.2.7. The workaround only
           applies to the Autotools build (not CMake).
 
         - CMake: Ensure that the C compiler language is set to C99 or
           a newer standard.
 
         - CMake changes from XZ Utils 5.4.1:
 
             * Added a workaround for a build failure with
               windres from GNU binutils.
 
             * Included the Windows resource files in the xz
               and xzdec build rules.
 
 
 5.2.10 (2022-12-13)
 
     * xz: Don't modify argv[] when parsing the --memlimit* and
       --block-list command line options. This fixes confusing
       arguments in process listing (like "ps auxf").
 
     * GNU/Linux only: Use __has_attribute(__symver__) to detect if
       that attribute is supported. This fixes build on Mandriva where
       Clang is patched to define __GNUC__ to 11 by default (instead
       of 4 as used by Clang upstream).
 
 
 5.2.9 (2022-11-30)
 
     * liblzma:
 
         - Fixed an infinite loop in LZMA encoder initialization
           if dict_size >= 2 GiB. (The encoder only supports up
           to 1536 MiB.)
 
         - Fixed two cases of invalid free() that can happen if
           a tiny allocation fails in encoder re-initialization
           or in lzma_filters_update(). These bugs had some
           similarities with the bug fixed in 5.2.7.
 
         - Fixed lzma_block_encoder() not allowing the use of
           LZMA_SYNC_FLUSH with lzma_code() even though it was
           documented to be supported. The sync-flush code in
           the Block encoder was already used internally via
           lzma_stream_encoder(), so this was just a missing flag
           in the lzma_block_encoder() API function.
 
         - GNU/Linux only: Don't put symbol versions into static
           liblzma as it breaks things in some cases (and even if
           it didn't break anything, symbol versions in static
           libraries are useless anyway). The downside of the fix
           is that if the configure options --with-pic or --without-pic
           are used then it's not possible to build both shared and
           static liblzma at the same time on GNU/Linux anymore;
           with those options --disable-static or --disable-shared
           must be used too.
 
     * New email address for bug reports is <xz@tukaani.org> which
       forwards messages to Lasse Collin and Jia Tan.
 
 
 5.2.8 (2022-11-13)
 
     * xz:
 
         - If xz cannot remove an input file when it should, this
           is now treated as a warning (exit status 2) instead of
           an error (exit status 1). This matches GNU gzip and it
           is more logical as at that point the output file has
           already been successfully closed.
 
         - Fix handling of .xz files with an unsupported check type.
           Previously such printed a warning message but then xz
           behaved as if an error had occurred (didn't decompress,
           exit status 1). Now a warning is printed, decompression
           is done anyway, and exit status is 2. This used to work
           slightly before 5.0.0. In practice this bug matters only
           if xz has been built with some check types disabled. As
           instructed in PACKAGERS, such builds should be done in
           special situations only.
 
         - Fix "xz -dc --single-stream tests/files/good-0-empty.xz"
           which failed with "Internal error (bug)". That is,
           --single-stream was broken if the first .xz stream in
           the input file didn't contain any uncompressed data.
 
         - Fix displaying file sizes in the progress indicator when
           working in passthru mode and there are multiple input files.
           Just like "gzip -cdf", "xz -cdf" works like "cat" when the
           input file isn't a supported compressed file format. In
           this case the file size counters weren't reset between
           files so with multiple input files the progress indicator
           displayed an incorrect (too large) value.
 
     * liblzma:
 
         - API docs in lzma/container.h:
             * Update the list of decoder flags in the decoder
               function docs.
             * Explain LZMA_CONCATENATED behavior with .lzma files
               in lzma_auto_decoder() docs.
 
         - OpenBSD: Use HW_NCPUONLINE to detect the number of
           available hardware threads in lzma_physmem().
 
         - Fix use of wrong macro to detect x86 SSE2 support.
           __SSE2_MATH__ was used with GCC/Clang but the correct
           one is __SSE2__. The first one means that SSE2 is used
           for floating point math which is irrelevant here.
           The affected SSE2 code isn't used on x86-64 so this affects
           only 32-bit x86 builds that use -msse2 without -mfpmath=sse
           (there is no runtime detection for SSE2). It improves LZMA
           compression speed (not decompression).
 
         - Fix the build with Intel C compiler 2021 (ICC, not ICX)
           on Linux. It defines __GNUC__ to 10 but doesn't support
           the __symver__ attribute introduced in GCC 10.
 
     * Scripts: Ignore warnings from xz by using --quiet --no-warn.
       This is needed if the input .xz files use an unsupported
       check type.
 
     * Translations:
 
         - Updated Croatian and Turkish translations.
 
         - One new translations wasn't included because it needed
           technical fixes. It will be in upcoming 5.4.0. No new
           translations will be added to the 5.2.x branch anymore.
 
         - Renamed the French man page translation file from
           fr_FR.po to fr.po and thus also its install directory
           (like /usr/share/man/fr_FR -> .../fr).
 
         - Man page translations for upcoming 5.4.0 are now handled
           in the Translation Project.
 
     * Update doc/faq.txt a little so it's less out-of-date.
 
 
 5.2.7 (2022-09-30)
 
     * liblzma:
 
         - Made lzma_filters_copy() to never modify the destination
           array if an error occurs. lzma_stream_encoder() and
           lzma_stream_encoder_mt() already assumed this. Before this
           change, if a tiny memory allocation in lzma_filters_copy()
           failed it would lead to a crash (invalid free() or invalid
           memory reads) in the cleanup paths of these two encoder
           initialization functions.
 
         - Added missing integer overflow check to lzma_index_append().
           This affects xz --list and other applications that decode
           the Index field from .xz files using lzma_index_decoder().
           Normal decompression of .xz files doesn't call this code
           and thus most applications using liblzma aren't affected
           by this bug.
 
         - Single-threaded .xz decoder (lzma_stream_decoder()): If
           lzma_code() returns LZMA_MEMLIMIT_ERROR it is now possible
           to use lzma_memlimit_set() to increase the limit and continue
           decoding. This was supposed to work from the beginning
           but there was a bug. With other decoders (.lzma or
           threaded .xz decoder) this already worked correctly.
 
         - Fixed accumulation of integrity check type statistics in
           lzma_index_cat(). This bug made lzma_index_checks() return
           only the type of the integrity check of the last Stream
           when multiple lzma_indexes were concatenated. Most
           applications don't use these APIs but in xz it made
           xz --list not list all check types from concatenated .xz
           files. In xz --list --verbose only the per-file "Check:"
           lines were affected and in xz --robot --list only the "file"
           line was affected.
 
         - Added ABI compatibility with executables that were linked
           against liblzma in RHEL/CentOS 7 or other liblzma builds
           that had copied the problematic patch from RHEL/CentOS 7
           (xz-5.2.2-compat-libs.patch). For the details, see the
           comment at the top of src/liblzma/validate_map.sh.
 
           WARNING: This uses __symver__ attribute with GCC >= 10.
           In other cases the traditional __asm__(".symver ...")
           is used. Using link-time optimization (LTO, -flto) with
           GCC versions older than 10 can silently result in
           broken liblzma.so.5 (incorrect symbol versions)! If you
           want to use -flto with GCC, you must use GCC >= 10.
           LTO with Clang seems to work even with the traditional
           __asm__(".symver ...") method.
 
     * xzgrep: Fixed compatibility with old shells that break if
       comments inside command substitutions have apostrophes (').
       This problem was introduced in 5.2.6.
 
     * Build systems:
 
         - New #define in config.h: HAVE_SYMBOL_VERSIONS_LINUX
 
         - Windows: Fixed liblzma.dll build with Visual Studio project
           files. It broke in 5.2.6 due to a change that was made to
           improve CMake support.
 
         - Windows: Building liblzma with UNICODE defined should now
           work.
 
         - CMake files are now actually included in the release tarball.
           They should have been in 5.2.5 already.
 
         - Minor CMake fixes and improvements.
 
     * Added a new translation: Turkish
 
 
 5.2.6 (2022-08-12)
 
     * xz:
 
         - The --keep option now accepts symlinks, hardlinks, and
           setuid, setgid, and sticky files. Previously this required
           using --force.
 
         - When copying metadata from the source file to the destination
           file, don't try to set the group (GID) if it is already set
           correctly. This avoids a failure on OpenBSD (and possibly on
           a few other OSes) where files may get created so that their
           group doesn't belong to the user, and fchown(2) can fail even
           if it needs to do nothing.
 
         - Cap --memlimit-compress to 2000 MiB instead of 4020 MiB on
           MIPS32 because on MIPS32 userspace processes are limited
           to 2 GiB of address space.
 
     * liblzma:
 
         - Fixed a missing error-check in the threaded encoder. If a
           small memory allocation fails, a .xz file with an invalid
           Index field would be created. Decompressing such a file would
           produce the correct output but result in an error at the end.
           Thus this is a "mild" data corruption bug. Note that while
           a failed memory allocation can trigger the bug, it cannot
           cause invalid memory access.
 
         - The decoder for .lzma files now supports files that have
           uncompressed size stored in the header and still use the
           end of payload marker (end of stream marker) at the end
           of the LZMA stream. Such files are rare but, according to
           the documentation in LZMA SDK, they are valid.
           doc/lzma-file-format.txt was updated too.
 
         - Improved 32-bit x86 assembly files:
             * Support Intel Control-flow Enforcement Technology (CET)
             * Use non-executable stack on FreeBSD.
 
         - Visual Studio: Use non-standard _MSVC_LANG to detect C++
           standard version in the lzma.h API header. It's used to
           detect when "noexcept" can be used.
 
     * xzgrep:
 
         - Fixed arbitrary command injection via a malicious filename
           (CVE-2022-1271, ZDI-CAN-16587). A standalone patch for
           this was released to the public on 2022-04-07. A slight
           robustness improvement has been made since then and, if
           using GNU or *BSD grep, a new faster method is now used
           that doesn't use the old sed-based construct at all. This
           also fixes bad output with GNU grep >= 3.5 (2020-09-27)
           when xzgrepping binary files.
 
           This vulnerability was discovered by:
           cleemy desu wayo working with Trend Micro Zero Day Initiative
 
         - Fixed detection of corrupt .bz2 files.
 
         - Improved error handling to fix exit status in some situations
           and to fix handling of signals: in some situations a signal
           didn't make xzgrep exit when it clearly should have. It's
           possible that the signal handling still isn't quite perfect
           but hopefully it's good enough.
 
         - Documented exit statuses on the man page.
 
         - xzegrep and xzfgrep now use "grep -E" and "grep -F" instead
           of the deprecated egrep and fgrep commands.
 
         - Fixed parsing of the options -E, -F, -G, -P, and -X. The
           problem occurred when multiple options were specified in
           a single argument, for example,
 
               echo foo | xzgrep -Fe foo
 
           treated foo as a filename because -Fe wasn't correctly
           split into -F -e.
 
         - Added zstd support.
 
     * xzdiff/xzcmp:
 
         - Fixed wrong exit status. Exit status could be 2 when the
           correct value is 1.
 
         - Documented on the man page that exit status of 2 is used
           for decompression errors.
 
         - Added zstd support.
 
     * xzless:
 
         - Fix less(1) version detection. It failed if the version number
           from "less -V" contained a dot.
 
     * Translations:
 
         - Added new translations: Catalan, Croatian, Esperanto,
           Korean, Portuguese, Romanian, Serbian, Spanish, Swedish,
           and Ukrainian
 
         - Updated the Brazilian Portuguese translation.
 
         - Added French man page translation. This and the existing
           German translation aren't complete anymore because the
           English man pages got a few updates and the translators
           weren't reached so that they could update their work.
 
     * Build systems:
 
         - Windows: Fix building of resource files when config.h isn't
           used. CMake + Visual Studio can now build liblzma.dll.
 
         - Various fixes to the CMake support. Building static or shared
           liblzma should work fine in most cases. In contrast, building
           the command line tools with CMake is still clearly incomplete
           and experimental and should be used for testing only.
 
 
 5.2.5 (2020-03-17)
 
     * liblzma:
 
         - Fixed several C99/C11 conformance bugs. Now the code is clean
           under gcc/clang -fsanitize=undefined. Some of these changes
           might have a negative effect on performance with old GCC
           versions or compilers other than GCC and Clang. The configure
           option --enable-unsafe-type-punning can be used to (mostly)
           restore the old behavior but it shouldn't normally be used.
 
         - Improved API documentation of lzma_properties_decode().
 
         - Added a very minor encoder speed optimization.
 
     * xz:
 
         - Fixed a crash in "xz -dcfv not_an_xz_file". All four options
           were required to trigger it. The crash occurred in the
           progress indicator code when xz was in passthru mode where
           xz works like "cat".
 
         - Fixed an integer overflow with 32-bit off_t. It could happen
           when decompressing a file that has a long run of zero bytes
           which xz would try to write as a sparse file. Since the build
           system enables large file support by default, off_t is
           normally 64-bit even on 32-bit systems.
 
         - Fixes for --flush-timeout:
             * Fix semi-busy-waiting.
             * Avoid unneeded flushes when no new input has arrived
               since the previous flush was completed.
 
         - Added a special case for 32-bit xz: If --memlimit-compress is
           used to specify a limit that exceeds 4020 MiB, the limit will
           be set to 4020 MiB. The values "0" and "max" aren't affected
           by this and neither is decompression. This hack can be
           helpful when a 32-bit xz has access to 4 GiB address space
           but the specified memlimit exceeds 4 GiB. This can happen
           e.g. with some scripts.
 
         - Capsicum sandbox is now enabled by default where available
           (FreeBSD >= 10). The sandbox debug messages (xz -vv) were
           removed since they seemed to be more annoying than useful.
 
         - DOS build now requires DJGPP 2.05 instead of 2.04beta.
           A workaround for a locale problem with DJGPP 2.05 was added.
 
     * xzgrep and other scripts:
 
         - Added a configure option --enable-path-for-scripts=PREFIX.
           It is disabled by default except on Solaris where the default
           is /usr/xpg4/bin. See INSTALL for details.
 
         - Added a workaround for a POSIX shell detection problem on
           Solaris.
 
     * Build systems:
 
         - Added preliminary build instructions for z/OS. See INSTALL
           section 1.2.9.
 
         - Experimental CMake support was added. It should work to build
           static liblzma on a few operating systems. It may or may not
           work to build shared liblzma. On some platforms it can build
           xz and xzdec too but those are only for testing. See the
           comment in the beginning of CMakeLists.txt for details.
 
         - Visual Studio project files were updated.
           WindowsTargetPlatformVersion was removed from VS2017 files
           and set to "10.0" in the added VS2019 files. In the future
           the VS project files will be removed when CMake support is
           good enough.
 
         - New #defines in config.h: HAVE___BUILTIN_ASSUME_ALIGNED,
           HAVE___BUILTIN_BSWAPXX, and TUKLIB_USE_UNSAFE_TYPE_PUNNING.
 
         - autogen.sh has a new optional dependency on po4a and a new
           option --no-po4a to skip that step. This matters only if one
           wants to remake the build files. po4a is used to update the
           translated man pages but as long as the man pages haven't
           been modified, there's nothing to update and one can use
           --no-po4a to avoid the dependency on po4a.
 
     * Translations:
 
         - XZ Utils translations are now handled by the Translation
           Project: https://translationproject.org/domain/xz.html
 
         - All man pages are now included in German too.
 
         - New xz translations: Brazilian Portuguese, Finnish,
           Hungarian, Chinese (simplified), Chinese (traditional),
           and Danish (partial translation)
 
         - Updated xz translations: French, German, Italian, and Polish
 
         - Unfortunately a few new xz translations weren't included due
           to technical problems like too long lines in --help output or
           misaligned column headings in tables. In the future, many of
           these strings will be split and e.g. the table column
           alignment will be handled in software. This should make the
           strings easier to translate.
 
 
 5.2.4 (2018-04-29)
 
     * liblzma:
 
         - Allow 0 as memory usage limit instead of returning
           LZMA_PROG_ERROR. Now 0 is treated as if 1 byte was specified,
           which effectively is the same as 0.
 
         - Use "noexcept" keyword instead of "throw()" in the public
           headers when a C++11 (or newer standard) compiler is used.
 
         - Added a portability fix for recent Intel C Compilers.
 
         - Microsoft Visual Studio build files have been moved under
           windows/vs2013 and windows/vs2017.
 
     * xz:
 
         - Fix "xz --list --robot missing_or_bad_file.xz" which would
           try to print an uninitialized string and thus produce garbage
           output. Since the exit status is non-zero, most uses of such
           a command won't try to interpret the garbage output.
 
         - "xz --list foo.xz" could print "Internal error (bug)" in a
           corner case where a specific memory usage limit had been set.
 
 
 5.2.3 (2016-12-30)
 
     * xz:
 
         - Always close a file before trying to delete it to avoid
           problems on some operating system and file system combinations.
 
         - Fixed copying of file timestamps on Windows.
 
         - Added experimental (disabled by default) sandbox support using
           Capsicum (FreeBSD >= 10). See --enable-sandbox in INSTALL.
 
     * C99/C11 conformance fixes to liblzma. The issues affected at least
       some builds using link-time optimizations.
 
     * Fixed bugs in the rarely-used function lzma_index_dup().
 
     * Use of external SHA-256 code is now disabled by default.
       It can still be enabled by passing --enable-external-sha256
       to configure. The reasons to disable it by default (see INSTALL
       for more details):
 
         - Some OS-specific SHA-256 implementations conflict with
           OpenSSL and cause problems in programs that link against both
           liblzma and libcrypto. At least FreeBSD 10 and MINIX 3.3.0
           are affected.
 
         - The internal SHA-256 is faster than the SHA-256 code in
           some operating systems.
 
     * Changed CPU core count detection to use sched_getaffinity() on
       GNU/Linux and GNU/kFreeBSD.
 
     * Fixes to the build-system and xz to make xz buildable even when
       encoders, decoders, or threading have been disabled from libilzma
       using configure options. These fixes added two new #defines to
       config.h: HAVE_ENCODERS and HAVE_DECODERS.
 
 
 5.2.2 (2015-09-29)
 
     * Fixed bugs in QNX-specific code.
 
     * Omitted the use of pipe2() even if it is available to avoid
       portability issues with some old Linux and glibc combinations.
 
     * Updated German translation.
 
     * Added project files to build static and shared liblzma (not the
       whole XZ Utils) with Visual Studio 2013 update 2 or later.
 
     * Documented that threaded decompression hasn't been implemented
       yet. A 5.2.0 NEWS entry describing multi-threading support had
       incorrectly said "decompression" when it should have said
       "compression".
 
 
 5.2.1 (2015-02-26)
 
     * Fixed a compression-ratio regression in fast mode of LZMA1 and
       LZMA2. The bug is present in 5.1.4beta and 5.2.0 releases.
 
     * Fixed a portability problem in xz that affected at least OpenBSD.
 
     * Fixed xzdiff to be compatible with FreeBSD's mktemp which differs
       from most other mktemp implementations.
 
     * Changed CPU core count detection to use cpuset_getaffinity() on
       FreeBSD.
 
 
 5.2.0 (2014-12-21)
 
     Since 5.1.4beta:
 
     * All fixes from 5.0.8
 
     * liblzma: Fixed lzma_stream_encoder_mt_memusage() when a preset
       was used.
 
     * xzdiff: If mktemp isn't installed, mkdir will be used as
       a fallback to create a temporary directory. Installing mktemp
       is still recommended.
 
     * Updated French, German, Italian, Polish, and Vietnamese
       translations.
 
     Summary of fixes and new features added in the 5.1.x development
     releases:
 
     * liblzma:
 
         - Added support for multi-threaded compression. See the
           lzma_mt structure, lzma_stream_encoder_mt(), and
           lzma_stream_encoder_mt_memusage() in <lzma/container.h>,
           lzma_get_progress() in <lzma/base.h>, and lzma_cputhreads()
           in <lzma/hardware.h> for details.
 
         - Made the uses of lzma_allocator const correct.
 
         - Added lzma_block_uncomp_encode() to create uncompressed
           .xz Blocks using LZMA2 uncompressed chunks.
 
         - Added support for LZMA_IGNORE_CHECK.
 
         - A few speed optimizations were made.
 
         - Added support for symbol versioning. It is enabled by default
           on GNU/Linux, other GNU-based systems, and FreeBSD.
 
         - liblzma (not the whole XZ Utils) should now be buildable
           with MSVC 2013 update 2 or later using windows/config.h.
 
     * xz:
 
         - Fixed a race condition in the signal handling. It was
           possible that e.g. the first SIGINT didn't make xz exit
           if reading or writing blocked and one had bad luck. The fix
           is non-trivial, so as of writing it is unknown if it will be
           backported to the v5.0 branch.
 
         - Multi-threaded compression can be enabled with the
           --threads (-T) option.
           [Fixed: This originally said "decompression".]
 
         - New command line options in xz: --single-stream,
           --block-size=SIZE, --block-list=SIZES,
           --flush-timeout=TIMEOUT, and --ignore-check.
 
         - xz -lvv now shows the minimum xz version that is required to
           decompress the file. Currently it is 5.0.0 for all supported
           .xz files except files with empty LZMA2 streams require 5.0.2.
 
     * xzdiff and xzgrep now support .lzo files if lzop is installed.
       The .tzo suffix is also recognized as a shorthand for .tar.lzo.
 
 
 5.1.4beta (2014-09-14)
 
     * All fixes from 5.0.6
 
     * liblzma: Fixed the use of presets in threaded encoder
       initialization.
 
     * xz --block-list and --block-size can now be used together
       in single-threaded mode. Previously the combination only
       worked in multi-threaded mode.
 
     * Added support for LZMA_IGNORE_CHECK to liblzma and made it
       available in xz as --ignore-check.
 
     * liblzma speed optimizations:
 
         - Initialization of a new LZMA1 or LZMA2 encoder has been
           optimized. (The speed of reinitializing an already-allocated
           encoder isn't affected.) This helps when compressing many
           small buffers with lzma_stream_buffer_encode() and other
           similar situations where an already-allocated encoder state
           isn't reused. This speed-up is visible in xz too if one
           compresses many small files one at a time instead running xz
           once and giving all files as command-line arguments.
 
         - Buffer comparisons are now much faster when unaligned access
           is allowed (configured with --enable-unaligned-access). This
           speeds up encoding significantly. There is arch-specific code
           for 32-bit and 64-bit x86 (32-bit needs SSE2 for the best
           results and there's no run-time CPU detection for now).
           For other archs there is only generic code which probably
           isn't as optimal as arch-specific solutions could be.
 
         - A few speed optimizations were made to the SHA-256 code.
           (Note that the builtin SHA-256 code isn't used on all
           operating systems.)
 
     * liblzma can now be built with MSVC 2013 update 2 or later
       using windows/config.h.
 
     * Vietnamese translation was added.
 
 
 5.1.3alpha (2013-10-26)
 
     * All fixes from 5.0.5
 
     * liblzma:
 
         - Fixed a deadlock in the threaded encoder.
 
         - Made the uses of lzma_allocator const correct.
 
         - Added lzma_block_uncomp_encode() to create uncompressed
           .xz Blocks using LZMA2 uncompressed chunks.
 
         - Added support for native threads on Windows and the ability
           to detect the number of CPU cores.
 
     * xz:
 
         - Fixed a race condition in the signal handling. It was
           possible that e.g. the first SIGINT didn't make xz exit
           if reading or writing blocked and one had bad luck. The fix
           is non-trivial, so as of writing it is unknown if it will be
           backported to the v5.0 branch.
 
         - Made the progress indicator work correctly in threaded mode.
 
         - Threaded encoder now works together with --block-list=SIZES.
 
         - Added preliminary support for --flush-timeout=TIMEOUT.
           It can be useful for (somewhat) real-time streaming. For
           now the decompression side has to be done with something
           else than the xz tool due to how xz does buffering, but this
           should be fixed.
 
 
 5.1.2alpha (2012-07-04)
 
     * All fixes from 5.0.3 and 5.0.4
 
     * liblzma:
 
         - Fixed a deadlock and an invalid free() in the threaded encoder.
 
         - Added support for symbol versioning. It is enabled by default
           on GNU/Linux, other GNU-based systems, and FreeBSD.
 
         - Use SHA-256 implementation from the operating system if one is
           available in libc, libmd, or libutil. liblzma won't use e.g.
           OpenSSL or libgcrypt to avoid introducing new dependencies.
 
         - Fixed liblzma.pc for static linking.
 
         - Fixed a few portability bugs.
 
     * xz --decompress --single-stream now fixes the input position after
       successful decompression. Now the following works:
 
           echo foo | xz > foo.xz
           echo bar | xz >> foo.xz
           ( xz -dc --single-stream ; xz -dc --single-stream ) < foo.xz
 
       Note that it doesn't work if the input is not seekable
       or if there is Stream Padding between the concatenated
       .xz Streams.
 
     * xz -lvv now shows the minimum xz version that is required to
       decompress the file. Currently it is 5.0.0 for all supported .xz
       files except files with empty LZMA2 streams require 5.0.2.
 
     * Added an *incomplete* implementation of --block-list=SIZES to xz.
       It only works correctly in single-threaded mode and when
       --block-size isn't used at the same time. --block-list allows
       specifying the sizes of Blocks which can be useful e.g. when
       creating files for random-access reading.
 
 
 5.1.1alpha (2011-04-12)
 
     * All fixes from 5.0.2
 
     * liblzma fixes that will also be included in 5.0.3:
 
         - A memory leak was fixed.
 
         - lzma_stream_buffer_encode() no longer creates an empty .xz
           Block if encoding an empty buffer. Such an empty Block with
           LZMA2 data would trigger a bug in 5.0.1 and older (see the
           first bullet point in 5.0.2 notes). When releasing 5.0.2,
           I thought that no encoder creates this kind of files but
           I was wrong.
 
         - Validate function arguments better in a few functions. Most
           importantly, specifying an unsupported integrity check to
           lzma_stream_buffer_encode() no longer creates a corrupt .xz
           file. Probably no application tries to do that, so this
           shouldn't be a big problem in practice.
 
         - Document that lzma_block_buffer_encode(),
           lzma_easy_buffer_encode(), lzma_stream_encoder(), and
           lzma_stream_buffer_encode() may return LZMA_UNSUPPORTED_CHECK.
 
         - The return values of the _memusage() functions are now
           documented better.
 
     * Support for multithreaded compression was added using the simplest
       method, which splits the input data into blocks and compresses
       them independently. Other methods will be added in the future.
       The current method has room for improvement, e.g. it is possible
       to reduce the memory usage.
 
     * Added the options --single-stream and --block-size=SIZE to xz.
 
     * xzdiff and xzgrep now support .lzo files if lzop is installed.
       The .tzo suffix is also recognized as a shorthand for .tar.lzo.
 
     * Support for short 8.3 filenames under DOS was added to xz. It is
       experimental and may change before it gets into a stable release.
 
 
 5.0.8 (2014-12-21)
 
     * Fixed an old bug in xzgrep that affected OpenBSD and probably
       a few other operating systems too.
 
     * Updated French and German translations.
 
     * Added support for detecting the amount of RAM on AmigaOS/AROS.
 
     * Minor build system updates.
 
 
 5.0.7 (2014-09-20)
 
     * Fix regressions introduced in 5.0.6:
 
         - Fix building with non-GNU make.
 
         - Fix invalid Libs.private value in liblzma.pc which broke
           static linking against liblzma if the linker flags were
           taken from pkg-config.
 
 
 5.0.6 (2014-09-14)
 
     * xzgrep now exits with status 0 if at least one file matched.
 
     * A few minor portability and build system fixes
 
 
 5.0.5 (2013-06-30)
 
     * lzmadec and liblzma's lzma_alone_decoder(): Support decompressing
       .lzma files that have less common settings in the headers
       (dictionary size other than 2^n or 2^n + 2^(n-1), or uncompressed
       size greater than 256 GiB). The limitations existed to avoid false
       positives when detecting .lzma files. The lc + lp <= 4 limitation
       still remains since liblzma's LZMA decoder has that limitation.
 
       NOTE: xz's .lzma support or liblzma's lzma_auto_decoder() are NOT
       affected by this change. They still consider uncommon .lzma headers
       as not being in the .lzma format. Changing this would give way too
       many false positives.
 
     * xz:
 
         - Interaction of preset and custom filter chain options was
           made less illogical. This affects only certain less typical
           uses cases so few people are expected to notice this change.
 
           Now when a custom filter chain option (e.g. --lzma2) is
           specified, all preset options (-0 ... -9, -e) earlier are on
           the command line are completely forgotten. Similarly, when
           a preset option is specified, all custom filter chain options
           earlier on the command line are completely forgotten.
 
           Example 1: "xz -9 --lzma2=preset=5 -e" is equivalent to "xz -e"
           which is equivalent to "xz -6e". Earlier -e didn't put xz back
           into preset mode and thus the example command was equivalent
           to "xz --lzma2=preset=5".
 
           Example 2: "xz -9e --lzma2=preset=5 -7" is equivalent to
           "xz -7". Earlier a custom filter chain option didn't make
           xz forget the -e option so the example was equivalent to
           "xz -7e".
 
         - Fixes and improvements to error handling.
 
         - Various fixes to the man page.
 
     * xzless: Fixed to work with "less" versions 448 and later.
 
     * xzgrep: Made -h an alias for --no-filename.
 
     * Include the previously missing debug/translation.bash which can
       be useful for translators.
 
     * Include a build script for Mac OS X. This has been in the Git
       repository since 2010 but due to a mistake in Makefile.am the
       script hasn't been included in a release tarball before.
 
 
 5.0.4 (2012-06-22)
 
     * liblzma:
 
         - Fix lzma_index_init(). It could crash if memory allocation
           failed.
 
         - Fix the possibility of an incorrect LZMA_BUF_ERROR when a BCJ
           filter is used and the application only provides exactly as
           much output space as is the uncompressed size of the file.
 
         - Fix a bug in doc/examples_old/xz_pipe_decompress.c. It didn't
           check if the last call to lzma_code() really returned
           LZMA_STREAM_END, which made the program think that truncated
           files are valid.
 
         - New example programs in doc/examples (old programs are now in
           doc/examples_old). These have more comments and more detailed
           error handling.
 
     * Fix "xz -lvv foo.xz". It could crash on some corrupted files.
 
     * Fix output of "xz --robot -lv" and "xz --robot -lvv" which
       incorrectly printed the filename also in the "foo (x/x)" format.
 
     * Fix exit status of "xzdiff foo.xz bar.xz".
 
     * Fix exit status of "xzgrep foo binary_file".
 
     * Fix portability to EBCDIC systems.
 
     * Fix a configure issue on AIX with the XL C compiler. See INSTALL
       for details.
 
     * Update French, German, Italian, and Polish translations.
 
 
 5.0.3 (2011-05-21)
 
     * liblzma fixes:
 
         - A memory leak was fixed.
 
         - lzma_stream_buffer_encode() no longer creates an empty .xz
           Block if encoding an empty buffer. Such an empty Block with
           LZMA2 data would trigger a bug in 5.0.1 and older (see the
           first bullet point in 5.0.2 notes). When releasing 5.0.2,
           I thought that no encoder creates this kind of files but
           I was wrong.
 
         - Validate function arguments better in a few functions. Most
           importantly, specifying an unsupported integrity check to
           lzma_stream_buffer_encode() no longer creates a corrupt .xz
           file. Probably no application tries to do that, so this
           shouldn't be a big problem in practice.
 
         - Document that lzma_block_buffer_encode(),
           lzma_easy_buffer_encode(), lzma_stream_encoder(), and
           lzma_stream_buffer_encode() may return LZMA_UNSUPPORTED_CHECK.
 
         - The return values of the _memusage() functions are now
           documented better.
 
     * Fix command name detection in xzgrep. xzegrep and xzfgrep now
       correctly use egrep and fgrep instead of grep.
 
     * French translation was added.
 
 
 5.0.2 (2011-04-01)
 
     * LZMA2 decompressor now correctly accepts LZMA2 streams with no
       uncompressed data. Previously it considered them corrupt. The
       bug can affect applications that use raw LZMA2 streams. It is
       very unlikely to affect .xz files because no compressor creates
       .xz files with empty LZMA2 streams. (Empty .xz files are a
       different thing than empty LZMA2 streams.)
 
     * "xz --suffix=.foo filename.foo" now refuses to compress the
       file due to it already having the suffix .foo. It was already
       documented on the man page, but the code lacked the test.
 
     * "xzgrep -l foo bar.xz" works now.
 
     * Polish translation was added.
 
 
 5.0.1 (2011-01-29)
 
     * xz --force now (de)compresses files that have setuid, setgid,
       or sticky bit set and files that have multiple hard links.
       The man page had it documented this way already, but the code
       had a bug.
 
     * gzip and bzip2 support in xzdiff was fixed.
 
     * Portability fixes
 
     * Minor fix to Czech translation
 
 
 5.0.0 (2010-10-23)
 
     Only the most important changes compared to 4.999.9beta are listed
     here. One change is especially important:
 
       * The memory usage limit is now disabled by default. Some scripts
         written before this change may have used --memory=max on xz command
         line or in XZ_OPT. THESE USES OF --memory=max SHOULD BE REMOVED
         NOW, because they interfere with user's ability to set the memory
         usage limit himself. If user-specified limit causes problems to
         your script, blame the user.
 
     Other significant changes:
 
       * Added support for XZ_DEFAULTS environment variable. This variable
         allows users to set default options for xz, e.g. default memory
         usage limit or default compression level. Scripts that use xz
         must never set or unset XZ_DEFAULTS. Scripts should use XZ_OPT
         instead if they need a way to pass options to xz via an
         environment variable.
 
       * The compression settings associated with the preset levels
         -0 ... -9 have been changed. --extreme was changed a little too.
         It is now less likely to make compression worse, but with some
         files the new --extreme may compress slightly worse than the old
         --extreme.
 
       * If a preset level (-0 ... -9) is specified after a custom filter
         chain options have been used (e.g. --lzma2), the custom filter
         chain will be forgotten. Earlier the preset options were
         completely ignored after custom filter chain options had been
         seen.
 
       * xz will create sparse files when decompressing if the uncompressed
         data contains long sequences of binary zeros. This is done even
         when writing to standard output that is connected to a regular
         file and certain additional conditions are met to make it safe.
 
       * Support for "xz --list" was added. Combine with --verbose or
         --verbose --verbose (-vv) for detailed output.
 
       * I had hoped that liblzma API would have been stable after
         4.999.9beta, but there have been a couple of changes in the
         advanced features, which don't affect most applications:
 
           - Index handling code was revised. If you were using the old
             API, you will get a compiler error (so it's easy to notice).
 
           - A subtle but important change was made to the Block handling
             API. lzma_block.version has to be initialized even for
             lzma_block_header_decode(). Code that doesn't do it will work
             for now, but might break in the future, which makes this API
             change easy to miss.
 
       * The major soname has been bumped to 5.0.0. liblzma API and ABI
         are now stable, so the need to recompile programs linking against
         liblzma shouldn't arise soon.
 